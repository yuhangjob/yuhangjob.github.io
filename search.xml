<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative 真机运行卡在Runing1 of 1 custom shell scripts]]></title>
    <url>%2FReactNative-%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E5%8D%A1%E5%9C%A8Runing1-of-1-custom-shell-scripts%2F</url>
    <content type="text"><![CDATA[Xcode真机运行ReactNative项目一直卡在Runing1 of 1 custom shell scripts问题 原因就是react-native-xcode.sh. 每次打包安装都重新把RN文件打包成main.jsbundle, 在机械硬盘的渣渣电脑上操作那数以万计个的文件,所以会很慢 解决Build Phases Bundle React Native code and images 12export NODE_BINARY=node../node_modules/react-native/scripts/react-native-xcode.sh 上方添加 1234if [ "$CONFIGURATION" = "Debug" ]; then echo "--- Skip bundle building in 'Debug' mode" exit 0fi 或者 123456DEST=$CONFIGURATION_BUILD_DIR/$UNLOCALIZED_RESOURCES_FOLDER_PATHif [ "$CONFIGURATION" = "Debug" ] &amp;&amp; [ -f "$DEST/main.jsbundle" ]; then echo "--- Skip bundle building in 'Debug' mode" exit 0fi 123456if [ "$CONFIGURATION" = "Debug" ]; thenecho "--- Skip bundle building in 'Debug' mode"exit 0fiexport NODE_BINARY=node../node_modules/react-native/scripts/react-native-xcode.sh]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native Flast 刷新及加载更多]]></title>
    <url>%2FReact-Native-Flast-%E5%88%B7%E6%96%B0%E5%8F%8A%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[ReactNative Flast 刷新及加载更多 FlastList.tsx代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import React, &#123;Component&#125; from 'react'import &#123;Dimensions, FlatList, StyleSheet, View&#125; from 'react-native';import _ from 'lodash'//reduximport &#123;connect&#125; from 'react-redux'//@ts-ignoreimport &#123;Button, Input, ModalIndicator, Toast&#125; from 'teaset';//customimport &#123;Theme&#125; from "../../commons/Theme";import &#123;requestForOrder&#125; from "../../request/RequestHelper";import CommonFlatListFooter, &#123;ROOT_TYPE&#125; from '../../commons/CommonFlatListFooter';import CommonFlatListEmpty from '../../commons/CommonFlatListEmpty';import OrderListCell from './OrderListCell';//为了代码规范TypeScript写法不用可忽略interface OrderListProps &#123; navId:number page:number onPressItem?:(item:OrderListItem) =&gt; void&#125;//为了代码规范TypeScript写法不用可忽略interface OrderListState extends State &#123; orderList:OrderListItem[] page: number, loading: &#123; show: boolean, //控制底部footer状态的枚举 foot: ROOT_TYPE &#125;&#125;class OrderList extends Component&lt;OrderListProps, OrderListState&gt; &#123; pageNumber: number constructor(props: OrderListProps) &#123; super(props) this.state = &#123; orderList:[], page: 1, loading:&#123; show:false, foot:ROOT_TYPE.Ready &#125; &#125; this.pageNumber = 20 &#125; componentDidMount() &#123; this.initData() &#125; showRefreshLoading(show: boolean) &#123; this.setState(&#123; loading: &#123; ...this.state.loading, show: show &#125; &#125;) &#125; initData = () =&gt; &#123; this.showRefreshLoading(true) requestForOrder(this.props.navId,this.props.page) .then(res =&gt; &#123; let foot = ROOT_TYPE.Ready // @ts-ignore if (res.list.length &lt; this.pageNumber) &#123; foot = ROOT_TYPE.Nomore &#125; this.setState(&#123; // @ts-ignore orderList:this.cleanData([],res.list), page: 1, loading: &#123; foot: foot, show: false &#125; &#125;) &#125;) &#125; loadMore = () =&gt; &#123; //如果已无更多数据则return if (this.state.loading.foot === ROOT_TYPE.Nomore) &#123; return &#125; //上拉时foot显示为加载中 this.setState(&#123; loading: &#123; ...this.state.loading, foot: ROOT_TYPE.Loading &#125; &#125;) //页码加1 let pn = this.state.page + 1 requestForOrder(this.props.navId,pn) .then(res =&gt; &#123; //请求完成foot显示为默认的上拉加载更多 let foot = ROOT_TYPE.Ready // 判断是否还有下一页此处也可根据总页数判断 if (res.list.length &lt; this.pageNumber) &#123; //如果当前页返回的数据数小于每页长度foot显示为已无更多 foot = ROOT_TYPE.Nomore &#125; this.setState(&#123; // @ts-ignore orderList: this.cleanData(this.state.orderList, res.list), page: pn, loading: &#123; ...this.state.loading, foot: foot &#125; &#125;) &#125;) &#125; // 清洗数据 cleanData(old:OrderListItem[], news:OrderListItem[])&#123; return _.chain(old).concat(news).uniqBy(i =&gt; i.id).value() &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList style=&#123;&#123;backgroundColor: Theme.color.defaultBackground&#125;&#125; data=&#123;this.state.orderList&#125; renderItem = &#123; (&#123;item,index&#125;) =&gt; &#123; //@ts-ignore return &lt;OrderListCell orderItem=&#123;item&#125; onItemPress=&#123;() =&gt; &#123; this.props.onPressItem &amp;&amp; this.props.onPressItem(item) &#125;&#125;/&gt; &#125; &#125; keyExtractor=&#123;(item,index) =&gt;String(item.id)&#125; refreshing=&#123;this.state.loading.show&#125; onRefresh=&#123;this.initData&#125; onEndReached=&#123;this.loadMore&#125; ListFooterComponent=&#123;&lt;CommonFlatListFooter status=&#123;this.state.loading.foot&#125; /&gt;&#125; ListEmptyComponent=&#123;&lt;CommonFlatListEmpty descriptionStr=&#123;'暂无注单'&#125; /&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;function select(store: any) &#123; return &#123;&#125;&#125;export default connect(select)(OrderList)const &#123;width, height&#125; = Dimensions.get('window')const styles = StyleSheet.create(&#123; scroller: &#123; flex: 1, backgroundColor: Theme.color.defaultBackground, &#125;, container: &#123; flex: 1, backgroundColor: Theme.color.defaultBackground, &#125;&#125;); ListFooterComponent.tsx代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React from 'react'import &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Dimensions,Text &#125; from 'react-native';//reduximport &#123; connect &#125; from 'react-redux'//request//customimport &#123; Theme &#125; from "../commons/Theme";interface CommonFlatListFooter_Props &#123; status: ROOT_TYPE&#125;interface CommonFlatListFooter_State &#123;&#125;class CommonFlatListFooter extends Component&lt;CommonFlatListFooter_Props, CommonFlatListFooter_State&gt; &#123; constructor(props: CommonFlatListFooter_Props) &#123; super(props) this.state = &#123; &#125; &#125; render() &#123; switch (this.props.status) &#123; case ROOT_TYPE.Loading: return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.textColor&#125;&gt;加载中...&lt;/Text&gt; &lt;/View&gt; ); case ROOT_TYPE.Nomore: return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.textColor&#125;&gt;已无更多&lt;/Text&gt; &lt;/View&gt; ) default: return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.textColor&#125;&gt;上拉加载更多&lt;/Text&gt; &lt;/View&gt; ); &#125; &#125;&#125;function select(store: any) &#123; return &#123; &#125;&#125;export default connect(select)(CommonFlatListFooter)export const enum ROOT_TYPE &#123; Loading = 0, Ready = 1, Nomore = 2&#125;const &#123; width, height &#125; = Dimensions.get('window')const styles = StyleSheet.create(&#123; textColor:&#123; color:Theme.color.borderColor &#125;, container:&#123; height:44, justifyContent:'center', alignItems:'center' &#125;&#125;); ListEmptyComponent.tsx代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react'import &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Dimensions, TouchableOpacity,Text&#125; from 'react-native';//reduximport &#123; connect &#125; from 'react-redux'//request//customimport &#123;Theme&#125; from "./Theme";interface CommonFlatListEmpty_Props &#123; descriptionStr?:string touchAction?:() =&gt; void&#125;interface CommonFlatListEmpty_State &#123;&#125;class CommonFlatListEmpty extends Component&lt;CommonFlatListEmpty_Props,CommonFlatListEmpty_State&gt; &#123; constructor(props: CommonFlatListEmpty_Props) &#123; super(props) this.state = &#123; &#125; &#125; render() &#123; return ( &lt;View style=&#123;styles.emptyView&#125;&gt; &lt;TouchableOpacity onPressOut=&#123;this.onPress&#125;&gt; &lt;View&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.props.descriptionStr?this.props.descriptionStr:''&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125; onPress = () =&gt; &#123; this.props.touchAction &amp;&amp; this.props.touchAction() &#125; &#125;function select(store:any) &#123; return &#123; &#125;&#125;export default connect(select)(CommonFlatListEmpty)const &#123;width, height&#125; = Dimensions.get('window')const styles = StyleSheet.create(&#123; emptyView:&#123;flex:1,justifyContent:'center',alignItems:'center',height:108&#125;, text:&#123;color:Theme.color.dividerColor&#125;&#125;);]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 网络请求封装ajax]]></title>
    <url>%2FReact-Native-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85ajax%2F</url>
    <content type="text"><![CDATA[基于ajax的网络请求封装 新建Fetch.tsx(作者采用的是TypeScript)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import _ from 'lodash'import axios, &#123; AxiosError, AxiosRequestConfig, AxiosResponse &#125; from 'axios'import &#123;Toast&#125; from "antd-mobile-rn"import &#123;DeviceEventEmitter&#125; from 'react-native'import config from "./config";interface ajaxOptions &#123; baseURL?: string version?: string headers?: object method?: string data?: object&#125;export const ajax = (url: string, options: ajaxOptions) =&gt; &#123; let axiosOptions: AxiosRequestConfig = &#123;&#125; axiosOptions.baseURL = config.host axiosOptions.headers = &#123;//无请求头可忽略 Authorization:'BasicAuth ' + config.ticket, ...options.headers &#125;//请求方式 axiosOptions.method = options.method || 'get'//超时时间 axiosOptions.timeout = 30 * 1000 if (options.data &amp;&amp; _.includes(['get', 'delete'], options.method)) axiosOptions.params = options.data else axiosOptions.data = options.data return new Promise&lt;AJAXErrorResult&gt;((resolve:any, reject:any) =&gt; &#123; axios(url, axiosOptions) .then(async (res: AxiosResponse&lt;ServerResponseData&gt;) =&gt; &#123; if(res.data.status === 1)&#123; resolve(res.data) return // @ts-ignore &#125; else if (res.data.Status === 1) &#123; resolve(res.data) return &#125; Toast.fail(res.data.error) reject(&#123; ...res, handled:false &#125;) &#125;) .catch(async (err: AxiosError) =&gt; &#123; console.warn(err) console.log(url,axiosOptions) if (!err.response) &#123; Toast.fail('服务繁忙，稍候请重试') reject(&#123; ...err, handled: true &#125;) return &#125; if (err.response.status == 401) &#123; reject(&#123; handled: true &#125;) Toast.info('登录状态失效，请重新登录') DeviceEventEmitter.emit('LogoutEvent',null ) &#125; else if (err.response.status == 400) &#123; reject(&#123; data: err.response.data, message: _.get(err.response.data, 'msg'), handled: false &#125;) &#125; else &#123; reject(&#123; ...err, handled: true &#125;) Toast.fail('服务繁忙，稍候请重试') &#125; &#125;) &#125;)&#125;export const GET = (url: string, options: ajaxOptions) =&gt; ajax(url, &#123; ...options, method: 'get'&#125;)export const PUT = (url: string, options: ajaxOptions) =&gt; ajax(url, &#123; ...options, method: 'put'&#125;)export const POST = (url: string, options: ajaxOptions) =&gt; ajax(url, &#123; ...options, method: 'post'&#125;)export const DEL = (url: string, options: ajaxOptions) =&gt; ajax(url, &#123; ...options, method: 'delete'&#125;) 创建RequestHelper.ts123456789101112131415//引用import &#123; POST, GET, PUT, DEL &#125; from "./Fetch";// 获取验证码export function requestForValidCode() &#123; return GET('/api/User/GetValidateNumKey', &#123;&#125;)&#125;// 登录export function requestForlogin(params: FormLoginModel) &#123; return POST('Api/User/UserLogin', &#123; data: &#123; ...params &#125; &#125;)&#125; 使用RequestHelper1234567891011requestForlogin(&#123; LoginName: phoneStr, LoginPass: password &#125;) .then((res: any) =&gt; &#123; &#125;) .catch((err: any) =&gt; &#123; if (!err.data.handled) &#123; &#125; &#125;)]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决iOS2.1大礼包问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3iOS2-1%E5%A4%A7%E7%A4%BC%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[直接回复以下内容不需要重新提交,一般回复后第二天就会通过审核1234567891011121314151617尊敬的苹果审核委员会， 你好。谢谢你的耐心等待和认真审核， 我们认真排查了你提到的7个审核条款， 我们对此回应如下：1.1.6：我们App并没有包含误导用户的功能和xu假信息，全都是真实的。2.3.0：我们App没有在通过苹果审核后修改任何的概念和功能。2.3.1：我们App没有切换到任何BC或CP的网站，我们是原生App3.1.1：我们App内并没有使用任何第三方支付。4.3.0：我们App内容都是我们自己开发的， 并不存在抄袭或者大量相似。5.2.1：我们App并没有法人实体和版权的风险。5.3.4：我们App并不需要所在地区的生产许可证或者相关授权这是我们经过认真自查之后，得到的结论， 我们的App需要尽快上线，因为我们有大量推广活动在做。希望苹果审核团队能继续审核，感谢。Dear Apple Review Committee, hello.Thank you for your patience and careful review. We carefully investigated the seven review clauses that you mentioned. We respond to this as follows:1.1.6: Our App does not contain misleading features and false information. It is all true.2.3.0: We haven’t modified any of the concepts and features of our App after it was approved by Apple.2.3.1: Our App does not switch to any gambling or lottery website. We are a native App3.1.1: We do not use any third party payment within our App.4.3.0: The contents of our apps are all developed by us. There is no plagiarism or a lot of similarities.5.2.1: Our App does not have the risk of legal entities and copyrights.5.3.4: Our App do not have the necessary licensing and permissions for all the locations where the app is used.This is the conclusion we got after careful self-examination. Our app needs to be online as soon as possible because we have a lot of promotional activities.I hope the Apple audit team can continue to review and thank you.]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>App上架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-push和code-push-server热更新上传到七牛云及阿里云]]></title>
    <url>%2Fcode-push%E5%92%8Ccode-push-server%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[自建 CodePush 服务CodePush 服务主要分为三个部分：服务端、客户端、React Native 项目。 服务端服务端需要使用 code-push-server 和MySQL 所以需要先将这两个安装好。 安装MySQL官网下载后直接双击安装，下载地址；打开“系统设置”，看到最新安装的MySQL，进入并启动服务。 安装 code-push-server 作者发布了两种安装方式（npm安装或源码安装），在此我推荐使用源码安装，为后期我们要基于这个服务修改自己的网页，源码安装方便些。 下载code-push-server代码1234// clone代码git clone https://github.com/lisong/code-push-server.git// 进入项目并安装资源cd code-push-server &amp;&amp; npm install 修改config/config.js 文件，在 db 对象中添加数据库信息，参考如下：12345678910db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, 创建数据库表1./bin/db init --dbhost localhost --dbuser root --dbpassword admin123 --dbname codepush 为了演示我重新创建一个 配置打包后的，bundle存储地址，这里配置loal本地也可以配置qiniu和OSS创建storage和data文件夹，用来保存打包好的资源，供用户更新下载，downloadUrl地址必须为服务器所在的地址，不然用户无法下载到包。主要配置如下： 七牛对象储存地址 123456qiniu: &#123; accessKey: "", //个人面板 &gt; 秘钥管理 &gt; AK secretKey: "", //个人面板 &gt; 秘钥管理 &gt; SK bucketName: "faweapp",//储存空间名称 downloadUrl: "http://babi.lhsea.com" //绑定的域名 &#125;, 阿里云对象储存 12345678oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo",//储存空间名称 prefix: "storage", // 目录文件夹名称 downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", //下载地址 &#125;, config.js文件路径：code-push-server/config/config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var os = require('os');var config = &#123;&#125;;config.development = &#123; // Config for database, only support mysql. db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, // Config for qiniu (http://www.qiniu.com/) cloud storage when storageType value is "qiniu". qiniu: &#123; accessKey: "", secretKey: "", bucketName: "faweapp", downloadUrl: "http://babi.lhsea.com" // Binary files download host address.http://pby2wik41.bkt.clouddn.com/Fi_BSD0I9yokJRdors-4LsZucE4_ &#125;, // Config for Amazon s3 (https://aws.amazon.com/cn/s3/) storage when storageType value is "s3". s3: &#123; accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY, sessionToken: process.env.AWS_SESSION_TOKEN, //(optional) bucketName: process.env.BUCKET_NAME, region: process.env.REGION, downloadUrl: process.env.DOWNLOAD_URL, // binary files download host address. &#125;, // Config for Aliyun OSS (https://www.aliyun.com/product/oss) when storageType value is "oss". oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo", prefix: "storage", // Key prefix in object key downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", // binary files download host address. &#125;, // Config for tencentyun COS (https://cloud.tencent.com/product/cos) when storageType value is "oss". tencentcloud: &#123; accessKeyId: "", secretAccessKey: "", bucketName: "", region: "", downloadUrl: "", // binary files download host address. &#125;, // Config for local storage when storageType value is "local". local: &#123; // Binary files storage dir, Do not use tmpdir and it's public download dir. storageDir: process.env.STORAGE_DIR || "/Users/mac/Desktop/workspaces/storage", //文件下载地址 CodePush Server 地址 + '/download' download对应app.js里面的地址 downloadUrl: process.env.LOCAL_DOWNLOAD_URL || "http://localhost:3000/download",//注意此地方是否是你的本机ip地址(如果是模拟器的话，无须更改） // public static download spacename. public: '/download' &#125;, jwt: &#123; // Recommended: 63 random alpha-numeric characters // Generate using: https://www.grc.com/passwords.htm tokenSecret: process.env.TOKEN_SECRET ||'fnoQkK2w9zEp2Sj03lYaGCkWDgkVEvaTqrYPxbaZvq2MM3ivnXKNMLzrn96MTmn' &#125;, common: &#123; /* * tryLoginTimes is control login error times to avoid force attack. * if value is 0, no limit for login auth, it may not safe for account. when it's a number, it means you can * try that times today. but it need config redis server. */ tryLoginTimes: 0, // CodePush Web(https://github.com/lisong/code-push-web) login address. //codePushWebUrl: "http://127.0.0.1:3001/login", // create patch updates's number. default value is 3 diffNums: 3, // data dir for caclulate diff files. it's optimization. dataDir: process.env.DATA_DIR || "/Users/mac/Desktop/workspaces/data", // storageType which is your binary package files store. options value is ("local" | "qiniu" | "s3"| "oss" || "tencentcloud") //选择存储类型，目前支持local,oss,qiniu,s3配置 storageType: process.env.STORAGE_TYPE || "qiniu", // options value is (true | false), when it's true, it will cache updateCheck results in redis. updateCheckCache: false, // options value is (true | false), when it's true, it will cache rollout results in redis rolloutClientUniqueIdCache: false, &#125;, 改好之后，启动服务1./bin/www 在浏览其中输入：http://127.0.0.1:3000 能加载到CodePushServer登录界面即表示启动成功。点击登录，输入用户名：admin和密码：123456点击登录，然后点击获取token： 进入项目根目录1cd /Users/mac/Desktop/RNCPProject 登入1code-push login http://127.0.0.1:3000 会自动打开浏览器登录,获取token,把获取到的token粘贴过来, 回车 查看 1whoami 添加一个应用123testApp //应用名称code-push app add testApp ios react-nativecode-push app add testApp android react-native 配置Xcode info.plist 把我们获取的Staging对应的CodePushDeploymentKey填到上面就行了。 运行Xcode 启动项目以更改导航标题为示例 更改项目执行123456789101112code-push release-react testApp ios//发布命令（打包文件并上传到服务器）$ code-push release-react &lt;appName&gt; &lt;OS&gt; &lt;updateContents&gt; &lt;deploymentNmae&gt; &lt;description&gt; &lt;disabled&gt; &lt;mandatory&gt;&lt;appName&gt; //必须 app名称&lt;OS&gt; //必须 发布平台iOS/Android&lt;updateContents&gt; //非必须 Bundle文件所在目录&lt;targetBinaryVersion&gt; //非必须 需要热更的app 版本&lt;deploymentNmae&gt; //必须 需要发布的部署&lt;description&gt; //非必须 描述 (更新客户端不可见必须有"hide" eg: --description "hide xxxx")&lt;disabled&gt; //非必须 该版本客户端是否可以获得更新,默认为false&lt;mandatory&gt; //非必须 如果有则表示app强制更新 1234567//查看历史版本code-push deployment history &lt;应用名&gt; Staging/Productioncode-push deployment history testApp Staging//清空历史版本code-push deployment clear testApp Staging//查看keycode-push deployment ls testApp -k 集成CodePush SDKAndroid下面我们通过如下步骤在Android项目中集成CodePush。 第一步：在项目中安装 react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步：在Android project中安装插件。CodePush提供了两种方式：RNPM 和 Manual，本次演示所使用的是RNPM。运行npm i -g rnpm，来安装RNPM。 在React Native v0.27及以后版本RNPM已经被集成到了 React Native CL中，就不需要再进行安装了 第三步：运行 rnpm link react-native-code-push。这条命令将会自动帮我们在anroid文件中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 第四步： 在 android/app/build.gradle文件里面添如下代码：1apply from: "../../node_modules/react-native-code-push/android/codepush.gradle" 然后在/android/settings.gradle中添加如下代码: 12include ':react-native-code-push'project(':react-native-code-push').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app') 第五步: 运行code-push deployment -k ls &lt;appName&gt;获取 部署秘钥。默认的部署名是 staging，所以 部署秘钥（deployment key ） 就是 staging。第六步： 添加配置。当APP启动时我们需要让app向CodePush咨询JS bundle的所在位置，这样CodePush就可以控制版本。更新 MainApplication.java文件：1234567891011121314151617181920212223242526public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected String getJSBundleFile() &#123; return CodePush.getJSBundleFile(); &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; // 3. Instantiate an instance of the CodePush runtime and add it to the list of // existing packages, specifying the right deployment key. If you don't already // have it, you can run "code-push deployment ls &lt;appName&gt; -k" to retrieve your key. return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush("deployment-key-here", MainApplication.this, BuildConfig.DEBUG) ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125;&#125; 关于deployment-key的设置 在上述代码中我们在创建CodePush实例的时候需要设置一个deployment-key,因为deployment-key分生产环境与测试环境两种,所以建议大家在build.gradle中进行设置。在build.gradle中的设置方法如下: 打开android/app/build.gradle文件,找到android { buildTypes {} }然后添加如下代码即可: 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_STAGING_KEY&gt;"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_PRODUCTION_KEY&gt;"' ... &#125; &#125; ...&#125; 心得:另外,我们也可以将deployment-key存放在local.properties中: 12code_push_key_production=erASzHa1-wTdODdPJDh6DBF2Jwo94JFH08Kvbcode_push_key_staging=mQY75RkFbX6SiZU1kVT1II7OqWst4JFH08Kvb 如图: 然后在就可以在android/app/build.gradle可以通过下面方式来引用它了: 12345678910111213141516171819202122232425Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_production")+'"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_staging")+'"' ... &#125; &#125; ...&#125; 在android/app/build.gradle设置好deployment-key之后呢,我们就可以这样使用了: 12345678@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( ... new CodePush(BuildConfig.CODEPUSH_KEY, MainApplication.this, BuildConfig.DEBUG), // Add/change this line. ... );&#125; 第七步：修改versionName。在 android/app/build.gradle中有个android.defaultConfig.versionName属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。 12345android&#123; defaultConfig&#123; versionName "1.0.0" &#125;&#125; 至此Code Push for Android的SDK已经集成完成。 iOSCodePush官方提供RNPM、CocoaPods与手动三种在iOS项目中集成CodePush的方式，接下来我就以RNPM的方式来讲解一下如何在iOS项目中集成CodePush。 第一步：在项目中安装react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步： 运行rnpm link react-native-code-push。这条命令将会自动帮我们在ios中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 关于deployment-key的设置在我们想CodePush注册App的时候，CodePush会给我们两个deployment-key分别是在生产环境与测试环境时使用的，我们可以通过如下步骤来设置deployment-key。 用Xcode 打开项目 ➜ Xcode的项目导航视图中的PROJECT下选择你的项目 ➜ 选择Info页签 ➜ 在Configurations节点下单击 + 按钮 ➜ 选择Duplicate &quot;Release ➜ 输入Staging(名称可以自定义)； 然后选择Build Settings页签 ➜ 单击 + 按钮然后选择添加User-Defined Setting 然后输入CODEPUSH_KEY(名称可以自定义) 提示：你可以通过code-push deployment ls &lt;APP_NAME&gt; -k命令来查看deployment key。 打开 Info.plist文件，在CodePushDeploymentKey列的Value中输入$(CODEPUSH_KEY) 参考: https://www.jianshu.com/p/ca4beb5973bb https://www.jianshu.com/p/417a165ca9d7 React Native应用部署/热更新-CodePush最新集成总结(新)]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>code-push</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS摇骰子动画]]></title>
    <url>%2FiOS%E6%91%87%E9%AA%B0%E5%AD%90%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[效果演示 初始化123456789#import "YHBaseViewController.h"@interface LYHK3ChooseCPViewController : YHBaseViewController&lt;CAAnimationDelegate&gt;#define kSeZiWidth 46.0&#123; UIImageView *image1,*image2,*image3,*image4,*image5,*image6; UIImageView *dong1,*dong2,*dong3,*dong4,*dong5,*dong6;&#125;@end 动画开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//隐藏初始位置的骰子 image1.hidden = YES; image2.hidden = YES; dong1.hidden = YES; dong2.hidden = YES; image3.hidden = YES; dong3.hidden = YES; //转动骰子的载入 NSArray *myImages = [NSArray arrayWithObjects: [UIImage imageNamed:@"k3dong1"], [UIImage imageNamed:@"k3dong2"], [UIImage imageNamed:@"k3dong3"], [UIImage imageNamed:@"k3dong4"], [UIImage imageNamed:@"k3dong5"], [UIImage imageNamed:@"k3dong6"],nil]; //骰子1的转动图片切换 UIImageView *dong11 = [UIImageView alloc]; [dong11 initWithFrame:CGRectMake(85.0, 115.0, kSeZiWidth, kSeZiWidth)]; dong11.animationImages = myImages; dong11.animationDuration = 0.5; [dong11 startAnimating]; [self.view addSubview:dong11]; dong1 = dong11; //骰子2的转动图片切换 UIImageView *dong12 = [UIImageView alloc]; [dong12 initWithFrame:CGRectMake(135.0, 115.0, kSeZiWidth, kSeZiWidth)]; dong12.animationImages = myImages; dong12.animationDuration = 0.5; [dong12 startAnimating]; [self.view addSubview:dong12]; dong2 = dong12; //骰子3的转动图片切换 UIImageView *dong13 = [UIImageView alloc]; [dong13 initWithFrame:CGRectMake(120.0, 145.0, kSeZiWidth, kSeZiWidth)]; dong13.animationImages = myImages; dong13.animationDuration = 0.5; [dong13 startAnimating]; [self.view addSubview:dong13]; dong3 = dong13; //******************旋转动画****************** //设置动画 CABasicAnimation *spin = [CABasicAnimation animationWithKeyPath:@"transform.rotation"]; [spin setToValue:[NSNumber numberWithFloat:M_PI * 10.0 * 0]]; [spin setDuration:2.0]; //******************位置变化****************** //骰子1的位置变化 CGPoint p1 = CGPointMake(80, SHEIGTH /2 - 200); CGPoint p2 = CGPointMake(120, SHEIGTH /2 - 100); CGPoint p3 = CGPointMake(SWIDTH / 2 - 25.5, SHEIGTH /2 + 80); CGPoint p4 = CGPointMake(SWIDTH / 2 - 10 - kSeZiWidth / 2, SHEIGTH /2); NSArray *keypoint = [[NSArray alloc] initWithObjects:[NSValue valueWithCGPoint:p1],[NSValue valueWithCGPoint:p2],[NSValue valueWithCGPoint:p3],[NSValue valueWithCGPoint:p4], nil]; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; [animation setValues:keypoint]; [animation setDuration:2.0]; [animation setDelegate:self]; [dong1.layer setPosition:CGPointMake(SWIDTH / 2 - 42.5, SHEIGTH /2)]; //骰子2的位置变化 CGPoint p21 = CGPointMake(SWIDTH / 2 + 22.5, 115.0); CGPoint p22 = CGPointMake(SWIDTH / 2 + 52.5, 158.0); CGPoint p23 = CGPointMake(SWIDTH / 2 + 62.5, SHEIGTH /2 + 50); CGPoint p24 = CGPointMake(SWIDTH / 2 + 10 + kSeZiWidth / 2, SHEIGTH /2); NSArray *keypoint2 = [[NSArray alloc] initWithObjects:[NSValue valueWithCGPoint:p21],[NSValue valueWithCGPoint:p22],[NSValue valueWithCGPoint:p23],[NSValue valueWithCGPoint:p24], nil]; CAKeyframeAnimation *animation2 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; [animation2 setValues:keypoint2]; [animation2 setDuration:2.0]; [animation2 setDelegate:self]; [dong2.layer setPosition:CGPointMake(SWIDTH / 2 + 10, SHEIGTH /2)]; //骰子3的位置变化 CGPoint p31 = CGPointMake(SWIDTH / 2 + 12.5, 115.0); CGPoint p32 = CGPointMake(SWIDTH / 2 + 22.5, 158.0); CGPoint p33 = CGPointMake(SWIDTH / 2 + 32.5, SHEIGTH /2 + 150); CGPoint p34 = CGPointMake(SWIDTH / 2, SHEIGTH /2 + kSeZiWidth + 20); NSArray *keypoint3 = [[NSArray alloc] initWithObjects:[NSValue valueWithCGPoint:p31],[NSValue valueWithCGPoint:p32],[NSValue valueWithCGPoint:p33],[NSValue valueWithCGPoint:p34], nil]; CAKeyframeAnimation *animation3 = [CAKeyframeAnimation animationWithKeyPath:@"position"]; [animation3 setValues:keypoint3]; [animation3 setDuration:2.0]; [animation3 setDelegate:self]; [dong3.layer setPosition:CGPointMake(SWIDTH / 2, SHEIGTH /2 + kSeZiWidth + 20)]; //******************动画组合****************** //骰子1的动画组合 CAAnimationGroup *animGroup = [CAAnimationGroup animation]; animGroup.animations = [NSArray arrayWithObjects: animation, spin,nil]; animGroup.duration = 2.0; animGroup.fillMode = kCAFillModeForwards; animGroup.removedOnCompletion = NO; [animGroup setDelegate:self]; [[dong1 layer] addAnimation:animGroup forKey:@"1positionfir"]; //骰子2的动画组合 CAAnimationGroup *animGroup2 = [CAAnimationGroup animation]; animGroup2.animations = [NSArray arrayWithObjects: animation2, spin,nil]; animGroup2.duration = 2.0; animGroup2.fillMode = kCAFillModeForwards; animGroup2.removedOnCompletion = NO; [animGroup2 setDelegate:self]; [[dong2 layer] addAnimation:animGroup2 forKey:@"2positionfir"]; //骰子3的动画组合 CAAnimationGroup *animGroup3 = [CAAnimationGroup animation]; animGroup3.animations = [NSArray arrayWithObjects: animation3, spin,nil]; animGroup3.duration = 2.0; animGroup3.fillMode = kCAFillModeForwards; animGroup3.removedOnCompletion = NO; [animGroup3 setDelegate:self]; [[dong3 layer] addAnimation:animGroup3 forKey:@"3positionfir"]; delegate123456789101112131415161718192021- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag if (anim == [dong1.layer animationForKey:@"position2"]) &#123; self.yaoButton.enabled = YES; &#125; //停止骰子自身的转动DH [dong1 stopAnimating]; [dong2 stopAnimating]; [dong3 stopAnimating]; //[anim valueForKey:@"1positionfir"] if (anim == [dong1.layer animationForKey:@"1positionfir"]) &#123; //根据摇出的号码显示不同的骰子图片 dong1.image = [UIImage imageNamed:[NSString stringWithFormat:@"k3%@",self.imageName1]]; [self performSelector:@selector(endMoveAnimation1) withObject:nil afterDelay:1.0]; &#125;else if (anim == [dong2.layer animationForKey:@"2positionfir"])&#123; dong2.image = [UIImage imageNamed:[NSString stringWithFormat:@"k3%@",self.imageName2]]; [self performSelector:@selector(endMoveAnimation2) withObject:nil afterDelay:1.0]; &#125;else if (anim == [dong3.layer animationForKey:@"3positionfir"])&#123; dong3.image = [UIImage imageNamed:[NSString stringWithFormat:@"k3%@",self.imageName3]]; [self performSelector:@selector(endMoveAnimation3) withObject:nil afterDelay:1.0]; &#125;&#125; 骰子滚动到相应的号码12345678910111213141516171819202122232425262728293031323334353637- (void)endMoveAnimation &#123; CGFloat toHeight; NSArray *allPoint; toHeight = 216; allPoint = [[NSArray alloc] initWithObjects: [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 0.5 + 10, toHeight)], [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 1.5 + 25, toHeight)], [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 2.5 + 40, toHeight)], [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 0.5 + 10, toHeight + 90)], [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 1.5 + 25, toHeight + 90)], [NSValue valueWithCGPoint:CGPointMake((SWIDTH - 50)/3 * 2.5 + 40, toHeight + 90)],nil]; CGPoint toPoint = [allPoint[[self.imageName1 integerValue] - 1] CGPointValue]; CABasicAnimation *moveAnima = [CABasicAnimation animationWithKeyPath:@"position"]; moveAnima.fromValue = [NSValue valueWithCGPoint:dong1.center]; moveAnima.toValue = [NSValue valueWithCGPoint:toPoint]; moveAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; CABasicAnimation *opacityAnima = [CABasicAnimation animationWithKeyPath:@"opacity"]; opacityAnima.fromValue = [NSNumber numberWithFloat:1.0f]; opacityAnima.toValue = [NSNumber numberWithFloat:0.0f]; CAAnimationGroup *dong1animGroup = [CAAnimationGroup animation]; dong1animGroup.animations = [NSArray arrayWithObjects: moveAnima, opacityAnima,nil]; dong1animGroup.duration = 1.2; dong1animGroup.fillMode = kCAFillModeForwards; dong1animGroup.removedOnCompletion = NO; [dong1animGroup setDelegate:self]; [[dong1 layer] addAnimation:dong1animGroup forKey:@"position2"];&#125;// 2, 3写法类似1 可以把一改成通用方法- (void)endMoveAnimation2 &#123;&#125;- (void)endMoveAnimation3 &#123;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列组合计算公式]]></title>
    <url>%2F%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#pragma mark - 组合计算公式- (NSMutableArray *)zuHeSuanFa:(NSMutableArray *)array chooseCount:(int)m&#123; int n = [array count]; if (m &gt; n) &#123; return nil; &#125; NSMutableArray *allChooseArray = [[NSMutableArray alloc] init]; NSMutableArray *retArray = [array copy]; // (1,1,1,0,0) for(int i = 0;i &lt; n;i++) &#123; if (i &lt; m) &#123; [array replaceObjectAtIndex:i withObject:@"1"]; &#125; else &#123; [array replaceObjectAtIndex:i withObject:@"0"]; &#125; &#125; NSMutableArray *firstArray = [[NSMutableArray alloc] init]; for(int i = 0; i&lt;n; i++) &#123; if ([[array objectAtIndex:i] intValue] == 1) &#123; // [firstArray addObject:[NSString stringWithFormat:@"%d",i+1]]; [firstArray addObject:[retArray objectAtIndex:i]]; &#125; &#125; [allChooseArray addObject:firstArray]; // [firstArray release]; int count = 0; for(int i = 0; i &lt; n-1; i++) &#123; if ([[array objectAtIndex:i] intValue] == 1 &amp;&amp; [[array objectAtIndex:(i + 1)] intValue] == 0) &#123; [array replaceObjectAtIndex:i withObject:@"0"]; [array replaceObjectAtIndex:(i + 1) withObject:@"1"]; // i = 2, (1,1,0,1,0) for (int k = 0; k &lt; i; k++) &#123; if ([[array objectAtIndex:k] intValue] == 1) &#123; count ++; &#125; &#125; if (count &gt; 0) &#123; for (int k = 0; k &lt; i; k++) &#123; if (k &lt; count) &#123; // k = 1, (1,1,0,1,0) [array replaceObjectAtIndex:k withObject:@"1"]; &#125; else &#123; [array replaceObjectAtIndex:k withObject:@"0"]; &#125; &#125; &#125; NSMutableArray *middleArray = [[NSMutableArray alloc] init]; for (int k = 0; k &lt; n; k++) &#123; if ([[array objectAtIndex:k] intValue] == 1) &#123; // [middleArray addObject:[NSString stringWithFormat:@"%d",k + 1]]; [middleArray addObject:[retArray objectAtIndex:k]]; &#125; &#125; [allChooseArray addObject:middleArray]; // [middleArray release]; i = -1; count = 0; &#125; &#125; return allChooseArray;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10中使用HTTPS(转)]]></title>
    <url>%2FiOS-10-%E4%B8%AD%E4%BD%BF%E7%94%A8HTTPS%2F</url>
    <content type="text"><![CDATA[由于苹果规定2017年1月1日以后，所有APP都要使用HTTPS进行网络请求，否则无法上架，因此研究了一下在iOS中使用HTTPS请求的实现。网上搜索了一些比较有用资料,大家可以参考下 苹果强制升级的HTTPS不仅仅是在接口HTTP上加个S那么简单:它所有满足的是iOS9中新增App Transport Security（简称ATS）特性: 那满足ATS我们需要做什么呢1.必须是苹果信任的CA证书机构颁发的证书 2.后台传输协议必须满足: TLS1.2 (这很重要, 后面的自制证书满足这个条件是前提) 3.签字算法只能是下面的一种: 1234567891011TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 4.证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥。 目前有两种升级到HTTPS得方法: 1.第三方认证的颁发CA证书(推荐) 2.自己制作证书(这种不知道能不能满足苹果的审核) 第三方认证的颁发CA证书:证书到底长什么样子呢? 取个栗子: 大家请打开 https://www.baidu.com 然后看到 那些证书机构颁发的证书能用:苹果官方信任证书 收费SSL证书: 网上百度一大把, 收费还挺贵的,自己可以多找几个对比一下免费SSL证书: 除了收费的CA证书机构, 你还可以去腾讯云申请免费的SSL证书, 教程免费在腾讯云申请SSL证书的方法 沃通(WoSign)免费的SSL证书最近被苹果封杀了, 能不能用大家可以看一下苹果的公告: 您的苹果手机轻点“设置”&gt;“通用”&gt;“关于本机”&gt;”证书信任设置”&gt;”进一步了解被信任的证书”去了解检测你的接口是否满足苹果的ATS要求, 有以下两种方法: 腾讯云提供的检测页面检测 终端输入 nsurl –ats-diagnostics –verbose 你的接口地址 大家可以参考这篇文章,里面的说的很明白: 关于iOS9中的App Transport Security相关说明及适配(更新于2016.7.1)里面会详细说明你的证书哪点不符合ATS要求当然下面自己制作证书去实现HTTPS的,检测不通过的,所以我觉得审核会被拒这种方法配置好了, 在手机端就什么都不用配置就可以请求了 自己制作证书苹果官方信任证书里说到有三种证书: 可信的根证书用于建立信任链，以验证由可信的根签署的其他证书，例如，与 Web 服务器建立安全连接。当 IT 管理员创建 iPhone、iPad 或 iPod touch 的配置描述文件时，无需提供这些可信的根证书。 始终询问的证书不受信任，但不受阻止。使用其中一个证书时，系统将提示您选择是否信任该证书。 已阻止的证书视为被盗用，将不再受信任。自制证书我觉得应该就是属于第二种情况, 所以这种方法我也不知道能不能通过苹果的审核, 只是提供一个方法给大家参考, 看到网上有人说可以,有人说不可以, 不到1月1号,自己没试过都不敢说大话这种方式拿到后台的接口用谷歌浏览器打开跟百度的证书是有区别的 很明显没有绿锁, 当打开的时候会询问是否连接这个不受信任的连接才会进一步打开, 下面就来一步步的实现(包括怎么制作证书)iOS使用自签名证书实现HTTPS请求iOS Https协议 自签证书访问数据参考这个例子的时候,博主自带的Demo AFN框架请求不了数据, 我用了最新AFN版本的成功返回数据还可以参考一下iOS 10 适配 ATS app支持https通过App Store审核 我在利用原生的代码测试时遇到的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionDataTask *task = [session dataTaskWithURL:[NSURL URLWithString:@"https://www.baidu.com"] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; NSLog(@"%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;]; [task resume];&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; NSLog(@"接收到服务器响应"); //注意：这里需要使用completionHandler回调告诉系统应该如何处理服务器返回的数据 //默认是取消 /** NSURLSessionResponseCancel = 0, 默认的处理方式，取消 NSURLSessionResponseAllow = 1, 接收服务器返回的数据 NSURLSessionResponseBecomeDownload = 2, 变成一个下载请求 NSURLSessionResponseBecomeStream 变成一个流 */ completionHandler(NSURLSessionResponseAllow);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; NSLog(@"获取到服务段数据"); NSLog(@"%@",[self jsonToDictionary:data]);&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(nullable NSError *)error &#123; NSLog(@"请求完成%@", error);&#125;- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123; NSLog(@"证书认证"); if ([[[challenge protectionSpace] authenticationMethod] isEqualToString: NSURLAuthenticationMethodServerTrust]) &#123; do &#123; SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust]; NSCAssert(serverTrust != nil, @"serverTrust is nil"); if(nil == serverTrust) break; /* failed */ /** * 导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA），请替换掉你的证书名称 */ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"ca" ofType:@"cer"];//自签名证书 NSData* caCert = [NSData dataWithContentsOfFile:cerPath]; NSCAssert(caCert != nil, @"caCert is nil"); if(nil == caCert) break; /* failed */ SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert); NSCAssert(caRef != nil, @"caRef is nil"); if(nil == caRef) break; /* failed */ //可以添加多张证书 NSArray *caArray = @[(__bridge id)(caRef)]; NSCAssert(caArray != nil, @"caArray is nil"); if(nil == caArray) break; /* failed */ //将读取的证书设置为服务端帧数的根证书 OSStatus status = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray); NSCAssert(errSecSuccess == status, @"SecTrustSetAnchorCertificates failed"); if(!(errSecSuccess == status)) break; /* failed */ SecTrustResultType result = -1; //通过本地导入的证书来验证服务器的证书是否可信 status = SecTrustEvaluate(serverTrust, &amp;result); if(!(errSecSuccess == status)) break; /* failed */ NSLog(@"stutas:%d",(int)status); NSLog(@"Result: %d", result); BOOL allowConnect = (result == kSecTrustResultUnspecified) || (result == kSecTrustResultProceed); if (allowConnect) &#123; NSLog(@"success"); &#125;else &#123; NSLog(@"error"); &#125; /* kSecTrustResultUnspecified and kSecTrustResultProceed are success */ if(! allowConnect) &#123; break; /* failed */ &#125;#if 0 /* Treat kSecTrustResultConfirm and kSecTrustResultRecoverableTrustFailure as success */ /* since the user will likely tap-through to see the dancing bunnies */ if(result == kSecTrustResultDeny || result == kSecTrustResultFatalTrustFailure || result == kSecTrustResultOtherError) break; /* failed to trust cert (good in this case) */#endif // The only good exit point NSLog(@"信任该证书"); NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential,credential); return [[challenge sender] useCredential: credential forAuthenticationChallenge: challenge]; &#125; while(0); &#125; // Bad dog NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge,credential); return [[challenge sender] cancelAuthenticationChallenge: challenge]; &#125;- (NSDictionary *)jsonToDictionary:(NSData *)jsonData &#123; NSError *jsonError; NSDictionary *resultDic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableLeaves error:&amp;jsonError]; return resultDic; &#125;@end 下面说说我在配置自己制作证书过程中遇到的问题:1.转换证书: 把后台给你的.crt证书转化为.cer后缀终端命令行openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 2.利用系统的方法来不到 1234- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123; NSLog(@"证书认证");&#125; 这个方法的时候, 是因为后台的传输协议还没升级到TLS1.2, 叫后台升级后就可以来到验证证书的这个方法了. 3.拖入证书读取不出证书数据 参考: https的证书错误，错误码-1012问题及解决方案SDWebImage: 项目中大家用到AFN请求网络数据, 升级验证SSL证书的方案相信你看完上面的参考文章已经没问题了, 我给出的代码, 自定义网络请求也没问题了, 还有就是SDWebImage框架的请求HTTPS的图片时,大家可以绕过证书验证去加载图片 1[imageView sd_setImageWithURL:[NSURL URLWithString:urlString] placeholderImage:self.placeholder options:SDWebImageAllowInvalidSSLCertificates];]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信支付本地签名]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%9C%AC%E5%9C%B0%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132#pragma mark - 微信支付本地签名//创建发起支付时的sign签名-(NSString *)createMD5SingForPayWithAppID:(NSString *)appid_key partnerid:(NSString *)partnerid_key prepayid:(NSString *)prepayid_key package:(NSString *)package_key noncestr:(NSString *)noncestr_key timestamp:(UInt32)timestamp_key&#123; NSMutableDictionary *signParams = [NSMutableDictionary dictionary]; [signParams setObject:appid_key forKey:@"appid"];//微信appid 例如wxfb132134e5342 [signParams setObject:noncestr_key forKey:@"noncestr"];//随机字符串 [signParams setObject:package_key forKey:@"package"];//扩展字段 参数为 Sign=WXPay [signParams setObject:partnerid_key forKey:@"partnerid"];//商户账号 [signParams setObject:prepayid_key forKey:@"prepayid"];//此处为统一下单接口返回的预支付订单号 [signParams setObject:[NSString stringWithFormat:@"%u",(unsigned int)timestamp_key] forKey:@"timestamp"];//时间戳 NSMutableString *contentString =[NSMutableString string]; NSArray *keys = [signParams allKeys]; //按字母顺序排序 NSArray *sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2 options:NSNumericSearch]; &#125;]; //拼接字符串 for (NSString *categoryId in sortedArray) &#123; if ( ![[signParams objectForKey:categoryId] isEqualToString:@""] &amp;&amp; ![[signParams objectForKey:categoryId] isEqualToString:@"sign"] &amp;&amp; ![[signParams objectForKey:categoryId] isEqualToString:@"key"] ) &#123; [contentString appendFormat:@"%@=%@&amp;", categoryId, [signParams objectForKey:categoryId]]; &#125; &#125; //添加商户密钥key字段 商户平台自己去创建 [contentString appendFormat:@"key=%@", @"BAF174AC2D041C2BAFE72302368E0A58"]; NSString *result = [contentString MD5_32BIT];//md5加密 return result;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[图解 git git概述git简介?1.什么是git? &gt; git是一款开源的分布式版本控制工具 &gt; 在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的 2. git的起源? &gt; 作者是Linux之父：Linus Benedict Torvalds &gt; 当初开发git仅仅是为了辅助Linux内核的开发（管理源代码） 3.git的现状? &gt; 在国外已经非常普及，国内并未普及（在慢慢普及） &gt; 越来越多的开源项目已经转移到git 常见的源代码管理工具有哪些? CVS - 开启版本控制之门 - 1990年诞生，“远古时代”的主流源代码管理工具 SVN - 全称是Subversion，集中式版本控制之王者 - 是CVS的接班人，速度比CVS快，功能比CVS多且强大 - 在国内软件企业中使用最为普遍（70%-90%） ClearCase - 收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢 - 能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多 VSS - 微软的集中式版本控制工具，集成在Visual Studio中 集中式版本控制所有的代码都集中在一块, 统一进行管理 分布式版本控制在每个客户端都有一份完整的代码仓库, 可以在每个客户端自行管理 git 和 svn的简单对比 速度 在很多情况下，git的速度远远比SVN快结构 SVN是集中式管理，git是分布式管理其他 SVN使用分支比较笨拙，git可以轻松拥有无限个分支 SVN必须联网才能正常工作，git支持本地版本控制工作 旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git SVN工作流程和GIT工作流程对比 svn checkout —— git clone svn 只下载代码， git 会连同代码仓库一起下载下来 svn commit —— git commit svn 是提交到服务器，git 中是提交到本地仓库，需要使用push才能提交到服务器 svn update - git pull 都是从服务器下载最新被修改的代码 分布式和集中式最大的区别在于：在分布式下，本地有个代码仓库,开发者可以在本地提交; 而集中式版本控制, 只有在服务器才有一个代码仓库, 只能在服务器进行统一管理 工作原理 工作区 与.git文件夹同级的其他文件夹或者子文件夹 版本控制库暂缓区分支(Git不像SVN那样有主干和分支的概念. 仅仅存在分支,其中master分支为默认被创建的分支,类似于SVN中的主干)切换分支:通过控制HEAD指针指向不同的分支,就可以切换* 操作原则: 所有新添加/删除/修改的文件 必须先添加到暂缓区,然后才能提交到HEAD指向的当前分支中 git使用环境1.单人开发只需要一个本地库 :原因:不需要与他人共享代码,只负责管理自己代码即可;例如提交代码,删除代码,版本控制等等 2.多人开发时需要一个共享版本库 共享版本库的形式: 本地共享库:文件夹/U盘/硬盘 远程共享库:自己搭建git服务器/ 托管到第三方平台(例如github, oschina) 3.使用环境 无论是单人开发还是多人开发,客户端都可以使用命令行或者图形界面使用git SourceTree 下载地址：http://www.sourcetreeapp.com/download/ GitHub 下载地址：https://mac.github.com 不过它是专门为GitHub网站而设计的 Xcode 虽然集成较好,但是只能做一些常用的简单操作,复杂操作还要使用命令行 Git命令行演练-个人开发如何学习git指令&gt; git help [子命令] &gt; 和学习SVN指令是一样的，只不过git是通过使用指南的形式展示给用户看（不能编辑的vim编辑器），使用q退出vim编辑器，按空格进入下一页，ctrl + B 回到上一页； /关键字 进行搜索 初始化一个本地仓库&gt; 原因: 管理本地代码,修改上传,版本回退 &gt; 命令: git init 配置仓库&gt; 告诉git你是谁？ 原因: 追踪修改记录 命令: git config user.name “shunzi” &gt; 告诉git怎样联系你？ 原因: 多人合作开发时, 沟通交流 命令: git config user.email &quot;shunzi@qq.com&quot; &gt; 查看配置信息（.git -&gt; config打开） 命令: git config -l 个人开发演练 &gt; 创建文件并提交 命令: touch main.c git add . git commit -m “注释” &gt; 修改文件并提交 命令: git add . git commit -m “注释” &gt; 删除文件并提交 命令: git rm person.h git commit -m “注释” &gt; 日志查看 命令: git log git reflog &gt; 版本回退 命令: git reset —hard HEAD 重置到当前版本 git reset —hard HEAD^^ 重置到上上个版本 git reset ——hard HEAD2 重置到往上2个版本 git reset —hard 七位版本号 重置到指定版本:: 备注补充文件状态(git status)&gt; 颜色含义 红色: 代表被添加或者修改的文件没有被添加到暂缓区 绿色: 代表文件在暂缓区,等待提交 &gt; 版本号的含义 版本号是一个由SHA1生成的40位哈希值 这样做的目的是保证版本号的唯一 vim编辑器的使用 命令模式:等待编辑命令输入;所有输入的内容都被当做命令来执行 插入模式:输入的所有内容都被显示,并被当做文件内容处理 命令行模式:执行待定命令(保存文件并退出vim : wq ; 强制退出不保存: q! ) 日志查看配置命令如下: git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\&lt;%an\&gt;%Creset&apos; --abbrev-commit&quot; 配置别名git config alias.st status git config alias.ci commit -m –global的作用可以进行全局配置,所有的版本库共享此配置 查看全局配置（桌面前往-&gt;个人-&gt;.gitconfig 个人电脑上建议使用全局配置 Git命令行演练-团队开发团队开发必须有一个共享库,这样成员之间才可以进行协作开发 共享库分类&gt; 本地共享库(只能在本地面对面操作) - 电脑文件夹/U盘/移动硬盘 &gt; 远程共享库(可通过网络远程操作) - 自己搭建Git服务器(**不建议**) - 在Github上托管项目(** 建议**) Github网址(https://github.com); 公开项目免费, 私有项目收费 - 在OSChina上托管项目(** 推荐**) OSChina网址(https://git.oschina.net) 安全免费,在国内访问速度快 搭建本地共享库原因: 多人合作开发,代码共享 命令: git init —-bare 经理初始化项目到本地共享库命令: git clone 本地代码仓库地址 演示多人开发&gt; 创建文件夹manager, niuda 命令: mkdir manager mkdir niuda &gt; 分别进入到两个文件夹从共享库clone项目到本地 命令: git clone 本地代码仓库地址 git clone 本地代码仓库地址 &gt; 演练新增文件同步 命令: touch person.h git add . git commit -m “创建person.h” git push git pull &gt; 演练修改文件同步 命令: git add . git commit -m “注释” git push git pull &gt; 演练删除文件同步 命令: git rm filename git commit -m “注释” git push git pull &gt; 演练冲突解决 命令: git pull &gt; 演练忽略文件 命令: touch .gitignore open .gitignore 加入忽略文件名 git add . git commit -m “注释” .gitignore文件配置规则: http://www.cnblogs.com/haiq/archive/2012/12/26/2833746.html 备注笔记&gt; 关于忽略文件 在真实开发中,配置.gitignore文件 ， 去github里面搜索gitignore 选择OC版本的，拷贝到本地仓库即可,记得添加到本地版本库 &gt; 常见问题 fetch first 代表当前文件过期,需要从远程共享库更新 git pull Git-XCode演练-团队开发搭建本地共享版本库命令: git init —-bare 经理初始化项目到共享版本库**注意: 添加忽略文件, 不然Xcode有可能会把没必要的文件提交** **必须在使用Xcode之前把忽略文件添加进来, 因为Xcode创建工程时, 默认直接把所有文件添加到暂缓区, 加进去之后忽略文件对其就无效了** 牛大,牛二使用Xcode 克隆项目演练添加文件同步演练修改文件同步演练删除文件同步演练冲突github的使用托管项目到github1.打开github网站:https://www.github.com 2.注册账号(OneShunzi) 3.点击创建新仓库:https://github.com/new 4.填入项目名称,描述等信息 5.创建完成 6.可根据生成的版本库地址进行克隆下来进行操作 怎样加入合作伙伴1.点击”个人” -&gt; setting -&gt; SSH keys -&gt; Add SSH key 2.将你小伙伴生成的公钥添加进来即可.(以下是生成公钥私钥方法) https://help.github.com/articles/generating-ssh-keys/ 怎样将其他著名框架添加到我们的代码仓库?1.搜索到对应的框架 2.点击fork 3.当项目被移到自己代码仓库中,就可以根据地址克隆下来进行操作 注意: 你可以针对此框架进行任意修改,但是仅仅作用在你的本地仓库中的副本,对原作者项目没有任何影响. 如果想向原作者提建议,可以直接使用,pull request操作. 提交完成后,原作者可以在pull request中看到你的提交.至于是否采纳,就是原作者的意愿 OSChina的使用托管项目到OSChina1.打开oschina网站:[https://git.oschina.net] 2.注册账号(OneShunzi) 3.点击创建新仓库[https://git.oschina.net/projects/new] 4.填入项目名称,描述等信息 5.创建完成 6.可根据生成的版本库地址进行克隆下来进行操作 怎样加入合作伙伴?1.点击”管理”-&gt;项目成员管理-&gt;选择成员权限进行创建 2.或者直接只用SSH(以下是生成公钥私钥方法) &gt; 部署公钥允许以只读的方式访问项目，主要用于项目在生产服务器的部署上，免去HTTP方式每次操作都要输入密码和普通SSH方式担心不小心修改项目代码的麻烦。 &gt; https://help.github.com/articles/generating-ssh-keys/ 怎样将其他著名框架添加到我们的代码仓库?1.搜索到对应的框架 2.点击fork 3.当项目被移到自己代码仓库中,就可以根据地址克隆下来进行操作 注意: 你可以针对此框架进行任意修改,但是仅仅作用在你的本地仓库中的副本,对原作者项目没有任何影响. 如果想向原作者提建议,可以直接使用,pull request操作. 提交完成后,原作者可以在pull request中看到你的提交.至于是否采纳,就是原作者的意愿 新人服务器搭建(补充了解)新人服务器搭建概念原因?概念: 搭建一个临时共享版本库, 供新人专用 原因: 防止新人刚到时，搞乱服务器上的项目 新建一个文件夹，newBee，作为新人服务器进入文件夹 使用git init —-bare 初始化仓库经理打开自己项目所在文件夹，执行PULL ,更新到最新然后source control -&gt;项目master -&gt; configure 项目&gt; 选择Remotes 选项 代表当前所连的远程服务器地址 &gt; 点击+号 添加 将newBee文件路径作为另外一个远程服务器地址 file:// 协议开头 结尾以/结尾 &gt; Done 经理将最新代码提交到新人远程仓库经理分配新人服务器地址给新人新人各种折腾经理建立文件夹，从新人服务器下载代码检查图解 Git版本备份/分支管理(补充了解)在git中不是通过拷贝代码来解决备份和开启分支的 git 直接打标签， 通过控制head指向，来回到任一版本 版本备份建立共享库&gt; 创建文件夹shareWeibo &gt; 进入文件夹后,初始化共享库 git init ——bare 经理克隆项目后开发完1.0版本,打标签后,上传共享库&gt; 创建manager文件夹 &gt; 进入文件夹后 git clone 共享库绝对路径 &gt; 进入工作区,配置姓名,邮箱 git config user.name “manager” git config user.email “manager@qq.com” &gt; 经理创建文件,并修改部分代码,提交代码,上传到共享库,完成v1.0版本 touch main.c open main.c:: 打开后写入abc git add . git commit -m “完成1.0版本开发” git push &gt; 经理给此版本打标签,并将标签上传到共享库 git tag -a v1.0 -m “标记1.0版本” git push origin v1.0 &gt; 经理继续开发2.0版本......并提交 git add . git commit -m “2.0部分功能” git push 已发布版本bug修复在以上步骤基础上做以下操作 牛大克隆项目,根据1.0版本创建分支,修复bug&gt; 创建niuda文件夹 &gt; 进入文件夹后 git clone 共享库绝对路径 &gt; 进入工作区,配置姓名,邮箱 git config user.name “niuda” git config user.email “niuda@qq.com” &gt; 根据v1.0版本建立新分支v1.0fixbug并切换到此分支 git checkout v1.0 -b v1.0fixbug:: &gt; 修复bug后提交到本地版本库 注意此处提交到的是HEAD指向的分支-v1.0fixbug git add . git commit -m “修复bug” 牛大修复bug后,打标签v1.1作版本备份,并上传共享库git tag -a v1.1 -m “1.1版本备份” git push origin v1.1 牛大上传整个分支到共享版本库git push origin v1.0fixbug —至此,分支修复bug结束,下面经理要合并分支— 经理从共享库更新代码到本地库git pull 经理查看当前服务器都有哪些分支git branch -r 经理切换到master分支后,将v1.0fixbug分支合并过来git checkout master git merge origin/v1.0fixbug -m “合并分支” 经理合并完成后提交到共享库git add . git commit -m “合并分支” git push 合并完成后,可以删除共享库的分支git branch -r -d origin/v1.0fixbug 查看版本标签,至此结束!!git tag 视频学习地址https://pan.baidu.com/s/1Dea7Q8cdyHj3Ekj4wGNSQA]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入环信SDK时碰到这个样的一个问题]]></title>
    <url>%2F%E5%AF%BC%E5%85%A5%E7%8E%AF%E4%BF%A1SDK%E6%97%B6%E7%A2%B0%E5%88%B0%E8%BF%99%E4%B8%AA%E6%A0%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[导入环信SDK时碰到这个样的一个问题12345Undefined symbols for architecture i386: "_fwrite$UNIX2003", referenced from: _hex_dump_internal in libEaseMobClientSDK.a(dump.o) _pkt_dump_internal in libEaseMobClientSDK.a(dump.o)ld: symbol(s) not found for architecture i386 解决方案一:将AppDelegate.m改为AppDelegate.mm 在AppDelegate.mm中添加下面代码: 12345678910extern"C"&#123; size_t fwrite$UNIX2003( const void *a, size_t b, size_t c, FILE *d ) &#123; return fwrite(a, b, c, d); &#125; char* strerror$UNIX2003( int errnum ) &#123; return strerror(errnum); &#125;&#125; 解决方案二 :在环信的demo 中有这样一个文件: 把这FixFopen.c个导入你的工程就ok了.]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>环信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环信最新 SDK 及 UI 集成 分分钟实现即时通讯]]></title>
    <url>%2F%E7%8E%AF%E4%BF%A1%E6%9C%80%E6%96%B0-SDK-%E5%8F%8A-UI-%E9%9B%86%E6%88%90-%E5%88%86%E5%88%86%E9%92%9F%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[demo 下载地址在最下边 第一部分 SDK集成SDK 集成 将想用的SDK 拖入工程 添加 相应的依赖库详情: http://docs.easemob.com/im/300iosclientintegration/20iossdkimport 注意: SDK 不支持 bitcode，向 Build Settings → Linking → Enable Bitcode 中设置 NO Build Settings → Other Linker Flags → 设置 -all_load 这样SDK 部分就完成了 第二部分 使用环信的UI 去环信官网下载最先的 EaseUI文件 将文件夹中的这四个文件拖到工程里面 3 .打开这个文件在其中引用 1 #import &quot;EaseUI.h&quot; Build Settings → Prefix Header → 将 EaseUI-Prefix.pch 拖进去 在环信的Demo中找到ChatView 文件并拖到 工程当中 点开.m文件 作如下处理 编译还会报错 将报错的部分全部注释掉 (只注释报错的 不要讲整个方法都注释了) 这样就可以使用环信的SDK 实现聊天了 123 ChatViewController *chat = [[ChatViewController alloc]initWithConversationChatter:@"想要聊天的账号" conversationType:EMConversationTypeChat]; [self.navigationController pushViewController:chat animated:YES]; Demo地址:https://github.com/yuhangjob/IM3.0.git 下载后报错重复操作 3 4 步骤]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>环信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 摄像头,进行音视频的数据采集]]></title>
    <url>%2FiOS-%E6%91%84%E5%83%8F%E5%A4%B4-%E8%BF%9B%E8%A1%8C%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[iOS 摄像头,进行音视频的数据采集，主要分为以下几个步骤： 1 音视频的采集，ios 中，利用 AVCaptureSession和AVCaptureDevice 可以采集到原始的音视频数据流。 2 对视频进行 H264 编码，对音频进行 AAC 编码，在 ios 中分别有已经封装好的编码库来实现对音视频的编码。 3 对编码后的音、视频数据进行组装封包； 4 建立 RTMP 连接并上推到服务端。 ps：由于编码库大多使用 c 语言编写，需要自己使用时编译，对于 ios，可以使用已经编译好的编码库。 x264编码：https://github.com/kewlbear/x264-ios（复制此链接到浏览器打开） faac编码：https://github.com/fflydev/faac-ios-build（操作同上） ffmpeg编码：https://github.com/kewlbear/FFmpeg-iOS-build-script（操作同上）iOS 使用 FFmpeg:http://www.jianshu.com/p/b72ae2446747 视音频编解码技术零基础学习方法: http://blog.csdn.net/leixiaohua1020/article/details/18893769 关于如果想给视频增加一些特殊效果，例如增加滤镜等，一般在编码前给使用滤镜库，但是这样也会造成一些耗时，导致上传视频数据有一定延时。]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS直播视频音频采集及H264 AAC编码]]></title>
    <url>%2FiOS%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E9%87%87%E9%9B%86%E5%8F%8AH264-AAC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本人也是刚接触直播参考网上的资料的学习一下，有很多不足之处敬请谅解！ 附Demo地址:https://github.com/yuhangjob/VideoAndAudioCapture H264编码.h1234567891011121314151617181920212223242526272829//// H264Encoder.h// AVCaptureSession//// Created by 刘宇航 on 16/7/4.// Copyright © 2016年 刘宇航. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;VideoToolbox/VideoToolbox.h&gt;@protocol H264EncoderDelegate &lt;NSObject&gt;- (void)gotSpsPps:(NSData*)sps pps:(NSData*)pps;- (void)gotEncodedData:(NSData*)data isKeyFrame:(BOOL)isKeyFrame;@end@interface H264Encoder : NSObject- (void) initWithConfiguration;- (void) start:(int)width height:(int)height;- (void) initEncode:(int)width height:(int)height;- (void) encode:(CMSampleBufferRef )sampleBuffer;- (void) End;@property (weak, nonatomic) NSString *error;@property (weak, nonatomic) id&lt;H264EncoderDelegate&gt; delegate;@end H264编码.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331//// H264Encoder.m// AVCaptureSession//// Created by 刘宇航 on 16/7/4.// Copyright © 2016年 刘宇航. All rights reserved.//#import "H264Encoder.h"@implementation H264Encoder&#123; NSString * yuvFile; VTCompressionSessionRef EncodingSession; dispatch_queue_t aQueue; CMFormatDescriptionRef format; CMSampleTimingInfo * timingInfo; BOOL initialized; int frameCount; NSData *sps; NSData *pps;&#125;@synthesize error;- (void) initWithConfiguration&#123; EncodingSession = nil; initialized = true; aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); frameCount = 0; sps = NULL; pps = NULL; &#125;void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer )&#123; // NSLog(@"didCompressH264 called with status %d infoFlags %d", (int)status, (int)infoFlags); if (status != 0) return; if (!CMSampleBufferDataIsReady(sampleBuffer)) &#123; NSLog(@"didCompressH264 data is not ready "); return; &#125; H264Encoder* encoder = (__bridge H264Encoder*)outputCallbackRefCon; // Check if we have got a key frame first bool keyframe = !CFDictionaryContainsKey( (CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync); if (keyframe) &#123; CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer); // CFDictionaryRef extensionDict = CMFormatDescriptionGetExtensions(format); // Get the extensions // From the extensions get the dictionary with key "SampleDescriptionExtensionAtoms" // From the dict, get the value for the key "avcC" size_t sparameterSetSize, sparameterSetCount; const uint8_t *sparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 ); if (statusCode == noErr) &#123; // Found sps and now check for pps size_t pparameterSetSize, pparameterSetCount; const uint8_t *pparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 ); if (statusCode == noErr) &#123; // Found pps encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize]; encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize]; if (encoder-&gt;_delegate) &#123; [encoder-&gt;_delegate gotSpsPps:encoder-&gt;sps pps:encoder-&gt;pps]; &#125; &#125; &#125; &#125; CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); size_t length, totalLength; char *dataPointer; OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer); if (statusCodeRet == noErr) &#123; size_t bufferOffset = 0; static const int AVCCHeaderLength = 4; while (bufferOffset &lt; totalLength - AVCCHeaderLength) &#123; // Read the NAL unit length uint32_t NALUnitLength = 0; memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength); // Convert the length value from Big-endian to Little-endian NALUnitLength = CFSwapInt32BigToHost(NALUnitLength); NSData* data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength]; [encoder-&gt;_delegate gotEncodedData:data isKeyFrame:keyframe]; // Move to the next NAL unit in the block buffer bufferOffset += AVCCHeaderLength + NALUnitLength; &#125; &#125; &#125;- (void) start:(int)width height:(int)height&#123; int frameSize = (width * height * 1.5); if (!initialized) &#123; NSLog(@"H264: Not initialized"); error = @"H264: Not initialized"; return; &#125; dispatch_sync(aQueue, ^&#123; // For testing out the logic, lets read from a file and then send it to encoder to create h264 stream // Create the compression session OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)(self), &amp;EncodingSession); NSLog(@"H264: VTCompressionSessionCreate %d", (int)status); if (status != 0) &#123; NSLog(@"H264: Unable to create a H264 session"); error = @"H264: Unable to create a H264 session"; return ; &#125; // Set the properties VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanFalse); VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, 240); VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_High_AutoLevel); // Tell the encoder to start encoding VTCompressionSessionPrepareToEncodeFrames(EncodingSession); // Start reading from the file and copy it to the buffer // Open the file using POSIX as this is anyway a test application int fd = open([yuvFile UTF8String], O_RDONLY); if (fd == -1) &#123; NSLog(@"H264: Unable to open the file"); error = @"H264: Unable to open the file"; return ; &#125; NSMutableData* theData = [[NSMutableData alloc] initWithLength:frameSize] ; NSUInteger actualBytes = frameSize; while (actualBytes &gt; 0) &#123; void* buffer = [theData mutableBytes]; NSUInteger bufferSize = [theData length]; actualBytes = read(fd, buffer, bufferSize); if (actualBytes &lt; frameSize) [theData setLength:actualBytes]; frameCount++; // Create a CM Block buffer out of this data CMBlockBufferRef BlockBuffer = NULL; OSStatus status = CMBlockBufferCreateWithMemoryBlock(NULL, buffer, actualBytes,kCFAllocatorNull, NULL, 0, actualBytes, kCMBlockBufferAlwaysCopyDataFlag, &amp;BlockBuffer); // Check for error if (status != noErr) &#123; NSLog(@"H264: CMBlockBufferCreateWithMemoryBlock failed with %d", (int)status); error = @"H264: CMBlockBufferCreateWithMemoryBlock failed "; return ; &#125; // Create a CM Sample Buffer CMSampleBufferRef sampleBuffer = NULL; CMFormatDescriptionRef formatDescription; CMFormatDescriptionCreate ( kCFAllocatorDefault, // Allocator kCMMediaType_Video, 'I420', NULL, &amp;formatDescription ); CMSampleTimingInfo sampleTimingInfo = &#123;CMTimeMake(1, 300)&#125;; OSStatus statusCode = CMSampleBufferCreate(kCFAllocatorDefault, BlockBuffer, YES, NULL, NULL, formatDescription, 1, 1, &amp;sampleTimingInfo, 0, NULL, &amp;sampleBuffer); // Check for error if (statusCode != noErr) &#123; NSLog(@"H264: CMSampleBufferCreate failed with %d", (int)statusCode); error = @"H264: CMSampleBufferCreate failed "; return; &#125; CFRelease(BlockBuffer); BlockBuffer = NULL; // Get the CV Image buffer CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); // Create properties CMTime presentationTimeStamp = CMTimeMake(frameCount, 300); //CMTime duration = CMTimeMake(1, DURATION); VTEncodeInfoFlags flags; // Pass it to the encoder statusCode = VTCompressionSessionEncodeFrame(EncodingSession, imageBuffer, presentationTimeStamp, kCMTimeInvalid, NULL, NULL, &amp;flags); // Check for error if (statusCode != noErr) &#123; NSLog(@"H264: VTCompressionSessionEncodeFrame failed with %d", (int)statusCode); error = @"H264: VTCompressionSessionEncodeFrame failed "; // End the session VTCompressionSessionInvalidate(EncodingSession); CFRelease(EncodingSession); EncodingSession = NULL; error = NULL; return; &#125; // NSLog(@"H264: VTCompressionSessionEncodeFrame Success"); &#125; // Mark the completion VTCompressionSessionCompleteFrames(EncodingSession, kCMTimeInvalid); // End the session VTCompressionSessionInvalidate(EncodingSession); CFRelease(EncodingSession); EncodingSession = NULL; error = NULL; close(fd); &#125;); &#125;- (void) initEncode:(int)width height:(int)height&#123; dispatch_sync(aQueue, ^&#123; // For testing out the logic, lets read from a file and then send it to encoder to create h264 stream // Create the compression session OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)(self), &amp;EncodingSession); NSLog(@"H264: VTCompressionSessionCreate %d", (int)status); if (status != 0) &#123; NSLog(@"H264: Unable to create a H264 session"); error = @"H264: Unable to create a H264 session"; return ; &#125; // Set the properties VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); VTSessionSetProperty(EncodingSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_Main_AutoLevel); // Tell the encoder to start encoding VTCompressionSessionPrepareToEncodeFrames(EncodingSession); &#125;);&#125;- (void) encode:(CMSampleBufferRef )sampleBuffer&#123; dispatch_sync(aQueue, ^&#123; frameCount++; // Get the CV Image buffer CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); // Create properties CMTime presentationTimeStamp = CMTimeMake(frameCount, 1000); //CMTime duration = CMTimeMake(1, DURATION); VTEncodeInfoFlags flags; // Pass it to the encoder OSStatus statusCode = VTCompressionSessionEncodeFrame(EncodingSession, imageBuffer, presentationTimeStamp, kCMTimeInvalid, NULL, NULL, &amp;flags); // Check for error if (statusCode != noErr) &#123; NSLog(@"H264: VTCompressionSessionEncodeFrame failed with %d", (int)statusCode); error = @"H264: VTCompressionSessionEncodeFrame failed "; // End the session VTCompressionSessionInvalidate(EncodingSession); CFRelease(EncodingSession); EncodingSession = NULL; error = NULL; return; &#125; // NSLog(@"H264: VTCompressionSessionEncodeFrame Success"); &#125;); &#125;- (void) End&#123; // Mark the completion VTCompressionSessionCompleteFrames(EncodingSession, kCMTimeInvalid); // End the session VTCompressionSessionInvalidate(EncodingSession); CFRelease(EncodingSession); EncodingSession = NULL; error = NULL; &#125;@end AAC编码.h1234567891011121314151617181920//// AACEncoder.h// AVCaptureSession//// Created by 刘宇航 on 16/7/4.// Copyright © 2016年 刘宇航. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;AudioToolbox/AudioToolbox.h&gt;@interface AACEncoder : NSObject@property (nonatomic) dispatch_queue_t encoderQueue;@property (nonatomic) dispatch_queue_t callbackQueue;- (void) encodeSampleBuffer:(CMSampleBufferRef)sampleBuffer completionBlock:(void (^)(NSData *encodedData, NSError* error))completionBlock;@end AAC编码.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208//// AACEncoder.m// AVCaptureSession//// Created by 刘宇航 on 16/7/4.// Copyright © 2016年 刘宇航. All rights reserved.//#import "AACEncoder.h"@interface AACEncoder()@property (nonatomic) AudioConverterRef audioConverter;@property (nonatomic) uint8_t *aacBuffer;@property (nonatomic) NSUInteger aacBufferSize;@property (nonatomic) char *pcmBuffer;@property (nonatomic) size_t pcmBufferSize;@end@implementation AACEncoder- (void) dealloc &#123; AudioConverterDispose(_audioConverter); free(_aacBuffer);&#125;- (id) init &#123; if (self = [super init]) &#123; _encoderQueue = dispatch_queue_create("AAC Encoder Queue", DISPATCH_QUEUE_SERIAL); _callbackQueue = dispatch_queue_create("AAC Encoder Callback Queue", DISPATCH_QUEUE_SERIAL); _audioConverter = NULL; _pcmBufferSize = 0; _pcmBuffer = NULL; _aacBufferSize = 1024; _aacBuffer = malloc(_aacBufferSize * sizeof(uint8_t)); memset(_aacBuffer, 0, _aacBufferSize); &#125; return self;&#125;- (void) setupEncoderFromSampleBuffer:(CMSampleBufferRef)sampleBuffer &#123; AudioStreamBasicDescription inAudioStreamBasicDescription = *CMAudioFormatDescriptionGetStreamBasicDescription((CMAudioFormatDescriptionRef)CMSampleBufferGetFormatDescription(sampleBuffer)); AudioStreamBasicDescription outAudioStreamBasicDescription = &#123;0&#125;; // Always initialize the fields of a new audio stream basic description structure to zero, as shown here: ... outAudioStreamBasicDescription.mSampleRate = inAudioStreamBasicDescription.mSampleRate; // The number of frames per second of the data in the stream, when the stream is played at normal speed. For compressed formats, this field indicates the number of frames per second of equivalent decompressed data. The mSampleRate field must be nonzero, except when this structure is used in a listing of supported formats (see “kAudioStreamAnyRate”). outAudioStreamBasicDescription.mFormatID = kAudioFormatMPEG4AAC; // kAudioFormatMPEG4AAC_HE does not work. Can't find `AudioClassDescription`. `mFormatFlags` is set to 0. outAudioStreamBasicDescription.mFormatFlags = kMPEG4Object_AAC_LC; // Format-specific flags to specify details of the format. Set to 0 to indicate no format flags. See “Audio Data Format Identifiers” for the flags that apply to each format. outAudioStreamBasicDescription.mBytesPerPacket = 0; // The number of bytes in a packet of audio data. To indicate variable packet size, set this field to 0. For a format that uses variable packet size, specify the size of each packet using an AudioStreamPacketDescription structure. outAudioStreamBasicDescription.mFramesPerPacket = 1024; // The number of frames in a packet of audio data. For uncompressed audio, the value is 1. For variable bit-rate formats, the value is a larger fixed number, such as 1024 for AAC. For formats with a variable number of frames per packet, such as Ogg Vorbis, set this field to 0. outAudioStreamBasicDescription.mBytesPerFrame = 0; // The number of bytes from the start of one frame to the start of the next frame in an audio buffer. Set this field to 0 for compressed formats. ... outAudioStreamBasicDescription.mChannelsPerFrame = 1; // The number of channels in each frame of audio data. This value must be nonzero. outAudioStreamBasicDescription.mBitsPerChannel = 0; // ... Set this field to 0 for compressed formats. outAudioStreamBasicDescription.mReserved = 0; // Pads the structure out to force an even 8-byte alignment. Must be set to 0. AudioClassDescription *description = [self getAudioClassDescriptionWithType:kAudioFormatMPEG4AAC fromManufacturer:kAppleSoftwareAudioCodecManufacturer]; OSStatus status = AudioConverterNewSpecific(&amp;inAudioStreamBasicDescription, &amp;outAudioStreamBasicDescription, 1, description, &amp;_audioConverter); if (status != 0) &#123; NSLog(@"setup converter: %d", (int)status); &#125;&#125;- (AudioClassDescription *)getAudioClassDescriptionWithType:(UInt32)type fromManufacturer:(UInt32)manufacturer&#123; static AudioClassDescription desc; UInt32 encoderSpecifier = type; OSStatus st; UInt32 size; st = AudioFormatGetPropertyInfo(kAudioFormatProperty_Encoders, sizeof(encoderSpecifier), &amp;encoderSpecifier, &amp;size); if (st) &#123; NSLog(@"error getting audio format propery info: %d", (int)(st)); return nil; &#125; unsigned int count = size / sizeof(AudioClassDescription); AudioClassDescription descriptions[count]; st = AudioFormatGetProperty(kAudioFormatProperty_Encoders, sizeof(encoderSpecifier), &amp;encoderSpecifier, &amp;size, descriptions); if (st) &#123; NSLog(@"error getting audio format propery: %d", (int)(st)); return nil; &#125; for (unsigned int i = 0; i &lt; count; i++) &#123; if ((type == descriptions[i].mSubType) &amp;&amp; (manufacturer == descriptions[i].mManufacturer)) &#123; memcpy(&amp;desc, &amp;(descriptions[i]), sizeof(desc)); return &amp;desc; &#125; &#125; return nil;&#125;static OSStatus inInputDataProc(AudioConverterRef inAudioConverter, UInt32 *ioNumberDataPackets, AudioBufferList *ioData, AudioStreamPacketDescription **outDataPacketDescription, void *inUserData)&#123; AACEncoder *encoder = (__bridge AACEncoder *)(inUserData); UInt32 requestedPackets = *ioNumberDataPackets; //NSLog(@"Number of packets requested: %d", (unsigned int)requestedPackets); size_t copiedSamples = [encoder copyPCMSamplesIntoBuffer:ioData]; if (copiedSamples &lt; requestedPackets) &#123; //NSLog(@"PCM buffer isn't full enough!"); *ioNumberDataPackets = 0; return -1; &#125; *ioNumberDataPackets = 1; //NSLog(@"Copied %zu samples into ioData", copiedSamples); return noErr;&#125;- (size_t) copyPCMSamplesIntoBuffer:(AudioBufferList*)ioData &#123; size_t originalBufferSize = _pcmBufferSize; if (!originalBufferSize) &#123; return 0; &#125; ioData-&gt;mBuffers[0].mData = _pcmBuffer; ioData-&gt;mBuffers[0].mDataByteSize = _pcmBufferSize; _pcmBuffer = NULL; _pcmBufferSize = 0; return originalBufferSize;&#125;- (void) encodeSampleBuffer:(CMSampleBufferRef)sampleBuffer completionBlock:(void (^)(NSData * encodedData, NSError* error))completionBlock &#123; CFRetain(sampleBuffer); dispatch_async(_encoderQueue, ^&#123; if (!_audioConverter) &#123; [self setupEncoderFromSampleBuffer:sampleBuffer]; &#125; CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); CFRetain(blockBuffer); OSStatus status = CMBlockBufferGetDataPointer(blockBuffer, 0, NULL, &amp;_pcmBufferSize, &amp;_pcmBuffer); NSError *error = nil; if (status != kCMBlockBufferNoErr) &#123; error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil]; &#125; //NSLog(@"PCM Buffer Size: %zu", _pcmBufferSize); memset(_aacBuffer, 0, _aacBufferSize); AudioBufferList outAudioBufferList = &#123;0&#125;; outAudioBufferList.mNumberBuffers = 1; outAudioBufferList.mBuffers[0].mNumberChannels = 1; outAudioBufferList.mBuffers[0].mDataByteSize = _aacBufferSize; outAudioBufferList.mBuffers[0].mData = _aacBuffer; AudioStreamPacketDescription *outPacketDescription = NULL; UInt32 ioOutputDataPacketSize = 1; status = AudioConverterFillComplexBuffer(_audioConverter, inInputDataProc, (__bridge void *)(self), &amp;ioOutputDataPacketSize, &amp;outAudioBufferList, outPacketDescription); //NSLog(@"ioOutputDataPacketSize: %d", (unsigned int)ioOutputDataPacketSize); NSData *data = nil; if (status == 0) &#123; NSData *rawAAC = [NSData dataWithBytes:outAudioBufferList.mBuffers[0].mData length:outAudioBufferList.mBuffers[0].mDataByteSize]; NSData *adtsHeader = [self adtsDataForPacketLength:rawAAC.length]; NSMutableData *fullData = [NSMutableData dataWithData:adtsHeader]; [fullData appendData:rawAAC]; data = fullData; &#125; else &#123; error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil]; &#125; if (completionBlock) &#123; dispatch_async(_callbackQueue, ^&#123; completionBlock(data, error); &#125;); &#125; CFRelease(sampleBuffer); CFRelease(blockBuffer); &#125;);&#125;/** * Add ADTS header at the beginning of each and every AAC packet. * This is needed as MediaCodec encoder generates a packet of raw * AAC data. * * Note the packetLen must count in the ADTS header itself. * See: http://wiki.multimedia.cx/index.php?title=ADTS * Also: http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations **/- (NSData*) adtsDataForPacketLength:(NSUInteger)packetLength &#123; int adtsLength = 7; char *packet = malloc(sizeof(char) * adtsLength); // Variables Recycled by addADTStoPacket int profile = 2; //AAC LC //39=MediaCodecInfo.CodecProfileLevel.AACObjectELD; int freqIdx = 4; //44.1KHz int chanCfg = 1; //MPEG-4 Audio Channel Configuration. 1 Channel front-center NSUInteger fullLength = adtsLength + packetLength; // fill in ADTS data packet[0] = (char)0xFF; // 11111111 = syncword packet[1] = (char)0xF9; // 1111 1 00 1 = syncword MPEG-2 Layer CRC packet[2] = (char)(((profile-1)&lt;&lt;6) + (freqIdx&lt;&lt;2) +(chanCfg&gt;&gt;2)); packet[3] = (char)(((chanCfg&amp;3)&lt;&lt;6) + (fullLength&gt;&gt;11)); packet[4] = (char)((fullLength&amp;0x7FF) &gt;&gt; 3); packet[5] = (char)(((fullLength&amp;7)&lt;&lt;5) + 0x1F); packet[6] = (char)0xFC; NSData *data = [NSData dataWithBytesNoCopy:packet length:adtsLength freeWhenDone:YES]; return data;&#125;@end ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306//// ViewController.m// AVCaptureSession//// Created by 刘宇航 on 16/7/1.// Copyright © 2016年 刘宇航. All rights reserved.//#import "ViewController.h"#import &lt;AVFoundation/AVFoundation.h&gt;#import "AACEncoder.h"#import "H264Encoder.h"#import "avformat.h"#define CAPTURE_FRAMES_PER_SECOND 20#define SAMPLE_RATE 44100#define VideoWidth 480#define VideoHeight 640@interface ViewController ()&lt;AVCaptureVideoDataOutputSampleBufferDelegate,AVCaptureAudioDataOutputSampleBufferDelegate,H264EncoderDelegate&gt;// 负责输如何输出设备之间的数据传递@property (nonatomic, strong) AVCaptureSession *session;// 队列@property (nonatomic, strong) dispatch_queue_t videoQueue;@property (nonatomic, strong) dispatch_queue_t AudioQueue;// 负责从 AVCaptureDevice 获得输入数据@property (nonatomic, strong) AVCaptureDeviceInput *captureDeviceInput;@property (nonatomic, strong) AVCaptureVideoDataOutput *videoOutput;@property (nonatomic, strong) AVCaptureConnection *videoConnection;@property (nonatomic, strong) AVCaptureConnection *audioConnection;// 拍摄预览图层@property (nonatomic, strong) AVCaptureVideoPreviewLayer *previewLayer;@property (nonatomic, strong) H264Encoder *h264Encoder;@property (nonatomic, strong) AACEncoder *aacEncoder;@property (nonatomic, strong) NSMutableData *data;@property (nonatomic, copy ) NSString *h264File;@property (nonatomic, strong) NSFileHandle *fileHandle;@property (nonatomic, strong) UIButton *startBtn;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _data = [NSMutableData new]; //初始化AVCaptureSession _session = [AVCaptureSession new]; // [self setupAudioCapture];// [self setupVideoCapture]; [self initStartBtn];&#125;#pragma mark - 设置音频- (void)setupAudioCapture &#123; self.aacEncoder = [AACEncoder new]; AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio]; NSError *error = nil; AVCaptureDeviceInput *audioInput = [[AVCaptureDeviceInput alloc]initWithDevice:audioDevice error:&amp;error]; if (error) &#123; NSLog(@"Error getting audio input device:%@",error.description); &#125; if ([self.session canAddInput:audioInput]) &#123; [self.session addInput:audioInput]; &#125; self.AudioQueue = dispatch_queue_create("Audio Capture Queue", DISPATCH_QUEUE_SERIAL); AVCaptureAudioDataOutput *audioOutput = [AVCaptureAudioDataOutput new]; [audioOutput setSampleBufferDelegate:self queue:self.AudioQueue]; if ([self.session canAddOutput:audioOutput]) &#123; [self.session addOutput:audioOutput]; &#125; self.audioConnection = [audioOutput connectionWithMediaType:AVMediaTypeAudio]; &#125;- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position&#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for ( AVCaptureDevice *device in devices ) if ( device.position == position ) return device; return nil;&#125;#pragma mark - 设置视频 capture- (void)setupVideoCapture &#123; self.h264Encoder = [H264Encoder new]; [self.h264Encoder initWithConfiguration]; [self.h264Encoder initEncode:480 height:640]; self.h264Encoder.delegate = self; if ([_session canSetSessionPreset:AVCaptureSessionPreset1280x720]) &#123; // 设置分辨率 _session.sessionPreset = AVCaptureSessionPreset1280x720; &#125;// //设置采集的 Video 和 Audio 格式，这两个是分开设置的，也就是说，你可以只采集视频。 //配置采集输入源(摄像头) NSError *error = nil; //获得一个采集设备, 例如前置/后置摄像头 AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; // videoDevice = [self cameraWithPosition:AVCaptureDevicePositionBack]; // videoDevice.position = AVCaptureDevicePositionBack; //用设备初始化一个采集的输入对象 AVCaptureDeviceInput *videoInput = [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&amp;error]; if (error) &#123; NSLog(@"Error getting video input device:%@",error.description); &#125; if ([_session canAddInput:videoInput]) &#123; [_session addInput:videoInput]; &#125; //配置采集输出,即我们取得视频图像的接口 _videoQueue = dispatch_queue_create("Video Capture Queue", DISPATCH_QUEUE_SERIAL); _videoOutput = [AVCaptureVideoDataOutput new]; [_videoOutput setSampleBufferDelegate:self queue:_videoQueue]; // 配置输出视频图像格式 NSDictionary *captureSettings = @&#123;(NSString*)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)&#125;; _videoOutput.videoSettings = captureSettings; _videoOutput.alwaysDiscardsLateVideoFrames = YES; if ([_session canAddOutput:_videoOutput]) &#123; [_session addOutput:_videoOutput]; &#125; // 保存Connection,用于SampleBufferDelegate中判断数据来源(video or audio?) _videoConnection = [_videoOutput connectionWithMediaType:AVMediaTypeVideo]; // 启动session [_session startRunning]; //将当前硬件采集视频图像显示到屏幕 _previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:_session]; _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; // 设置预览时的视频缩放方式 [[_previewLayer connection] setVideoOrientation:AVCaptureVideoOrientationPortrait]; // 设置视频的朝向 _previewLayer.frame = CGRectMake(0, 20, self.view.frame.size.height, self.view.frame.size.height - 80); [self.view.layer addSublayer:_previewLayer]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths firstObject]; self.h264File = [documentsDirectory stringByAppendingString:@"lyh.h264"]; [fileManager removeItemAtPath:self.h264File error:nil]; [fileManager createFileAtPath:self.h264File contents:nil attributes:nil]; self.fileHandle = [NSFileHandle fileHandleForWritingAtPath:self.h264File]; &#125;#pragma mark - 实现 AVCaptureOutputDelegate：- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; CMTime pts = CMSampleBufferGetDuration(sampleBuffer); double dPTS = (double)(pts.value) / pts.timescale; NSLog(@"DPTS is %f",dPTS); // 这里的sampleBuffer就是采集到的数据了，但它是Video还是Audio的数据，得根据connection来判断 if (connection == _videoConnection) &#123; // Video //NSLog(@"在这里获得video sampleBuffer，做进一步处理（编码H.264）"); // 取得当前视频尺寸信息 CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); NSInteger width = CVPixelBufferGetWidth(pixelBuffer); NSInteger height = CVPixelBufferGetHeight(pixelBuffer); [self.h264Encoder encode:sampleBuffer]; &#125; else if (connection == _audioConnection) &#123; // Audio //NSLog(@"这里获得audio sampleBuffer，做进一步处理（编码AAC）"); [self.aacEncoder encodeSampleBuffer:sampleBuffer completionBlock:^(NSData *encodedData, NSError *error) &#123; if (encodedData) &#123; NSLog(@"Audio data (%lu):%@", (unsigned long)encodedData.length,encodedData.description);#pragma mark - 音频数据(encodedData) [self.data appendData:encodedData]; &#125;else &#123; NSLog(@"Error encoding AAC: %@", error); &#125; &#125;]; &#125; &#125;- (void)gotSpsPps:(NSData*)sps pps:(NSData*)pps &#123; const char bytes[] = "\x00\x00\x00\x01"; size_t length = (sizeof bytes) - 1; //string literals have implicit trailing '\0' NSData *ByteHeader = [NSData dataWithBytes:bytes length:length]; [_fileHandle writeData:ByteHeader]; [_fileHandle writeData:sps]; [_fileHandle writeData:ByteHeader]; [_fileHandle writeData:pps]; // avformat_alloc_output_context2(&lt;#AVFormatContext **ctx#&gt;, &lt;#AVOutputFormat *oformat#&gt;, &lt;#const char *format_name#&gt;, &lt;#const char *filename#&gt;) &#125;- (void)gotEncodedData:(NSData*)data isKeyFrame:(BOOL)isKeyFrame &#123; NSLog(@"Video data (%lu):%@", (unsigned long)data.length,data.description); if (_fileHandle != NULL) &#123; const char bytes[] = "\x00\x00\x00\x01"; size_t length = (sizeof bytes) - 1; //string literals have implicit trailing '\0' NSData *ByteHeader = [NSData dataWithBytes:bytes length:length]; #pragma mark#pragma mark - 视频数据(data) [_fileHandle writeData:ByteHeader]; //[fileHandle writeData:UnitHeader]; [_fileHandle writeData:data]; &#125; &#125;#pragma mark - 录制- (void)startBtnClicked:(UIButton *)btn&#123; btn.selected = !btn.selected; if (btn.selected) &#123; [self startCamera]; [_startBtn setTitle:@"Stop" forState:UIControlStateNormal]; &#125; else &#123; [_startBtn setTitle:@"Start" forState:UIControlStateNormal]; [self stopCarmera]; &#125; &#125;- (void) startCamera&#123; [self setupAudioCapture]; [self setupVideoCapture]; [self.session commitConfiguration]; [self.session startRunning];&#125;- (void) stopCarmera&#123;// [_h264Encoder End]; [_session stopRunning];// //close(fd); [_fileHandle closeFile]; _fileHandle = NULL;// // 获取程序Documents目录路径 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; NSMutableString * path = [[NSMutableString alloc]initWithString:documentsDirectory]; [path appendString:@"/AACFile"]; [_data writeToFile:path atomically:YES]; &#125;- (void)initStartBtn&#123; _startBtn = [UIButton buttonWithType:UIButtonTypeCustom]; _startBtn.frame = CGRectMake(0, 0, 100, 40); _startBtn.backgroundColor = [UIColor lightGrayColor]; _startBtn.center = CGPointMake([UIScreen mainScreen].bounds.size.width / 2, [UIScreen mainScreen].bounds.size.height - 30); [_startBtn addTarget:self action:@selector(startBtnClicked:) forControlEvents:UIControlEventTouchUpInside]; [_startBtn setTitle:@"Start" forState:UIControlStateNormal]; [_startBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [self.view addSubview:_startBtn];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类似网易新闻的滑动菜单]]></title>
    <url>%2FSwift-%E7%B1%BB%E4%BC%BC%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E7%9A%84%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[简单实现类似这种的 滑动菜单 新手Swift新手 大神就别看了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import UIKitclass HomeViewController: UIViewController,UICollectionViewDelegate,UICollectionViewDataSource,UIScrollViewDelegate &#123; let WIDTH = UIScreen.mainScreen().bounds.width / 375 let HEIGTH = UIScreen.mainScreen().bounds.height / 667 let SCREENWIDTH = UIScreen.mainScreen().bounds.width let SCREENHEIGTH = UIScreen.mainScreen().bounds.height var collectionView: UICollectionView! var buttonsArray: NSMutableArray! var titlesArray: NSMutableArray! var lineView: UIView! override func viewDidLoad() &#123; super.viewDidLoad() self.automaticallyAdjustsScrollViewInsets = false self.navigationController?.automaticallyAdjustsScrollViewInsets = false self.initButtons() self.initCollectionView() &#125; func initButtons() &#123; buttonsArray = NSMutableArray() titlesArray = ["分类","品牌","首页","专题","品牌"] for var i = 0;i&lt;titlesArray.count;i++ &#123; let button = UIButton.init(type: .System) button.frame = CGRectMake(SCREENWIDTH * CGFloat (i) / 5.0, 0, SCREENWIDTH / 5.0, 40 * HEIGTH) button.tag = i button.backgroundColor = UIColor.blackColor() button.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) if i == 2 &#123; button.titleLabel?.font = UIFont.systemFontOfSize(16.0 * WIDTH) button.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; button.titleLabel?.font = UIFont.systemFontOfSize(15.0 * WIDTH) button.setTitle(titlesArray[i] as? String, forState: .Normal) button.addTarget(self, action: "click:", forControlEvents: .TouchUpInside) self.view.addSubview(button) buttonsArray.addObject(button) &#125; lineView = UIView.init(frame: CGRectMake(15 * WIDTH + (SCREENWIDTH / 5.0) * 2, 38 * HEIGTH, SCREENWIDTH / 5.0 - 30 * WIDTH, 2 * HEIGTH)) lineView.backgroundColor = UIColor.whiteColor() self.view.addSubview(lineView) &#125; func click (btn: UIButton) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; btn.titleLabel?.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) self.collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forItem: btn.tag, inSection: 0), atScrollPosition: .None, animated: true) UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (btn.tag), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125;) &#123;(Bool) -&gt; Void in &#125; &#125; func initCollectionView() &#123; let flowLayout = UICollectionViewFlowLayout() flowLayout.scrollDirection = .Horizontal flowLayout.itemSize = CGSizeMake(UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH) flowLayout.minimumLineSpacing = 0 flowLayout.minimumInteritemSpacing = 0 collectionView = UICollectionView.init(frame: CGRectMake(0, 40 * HEIGTH, UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH), collectionViewLayout: flowLayout) collectionView.delegate = self collectionView.dataSource = self collectionView.pagingEnabled = true collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forRow: 2, inSection: 0), atScrollPosition: .None, animated: true) self.view.addSubview(collectionView) collectionView.registerClass(HomeCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "hCell") collectionView.registerClass(KindCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "kCell") collectionView.registerClass(BrandCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "bCell") collectionView.registerClass(SubjectCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "sCell") collectionView.registerClass(GiftCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "gCell") &#125; func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 5 &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; if indexPath.item == 0 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("kCell", forIndexPath: indexPath) as! KindCollectionViewCell weak var weakSelf = self cell.initClosure(&#123; (str) -&gt; Void? in // let url = "http://mobile.iliangcang.com/goods/goodsShare?a=b&amp;page=1&amp;count=10&amp;coverId=1&amp;cat_code=$&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" let common = CommonViewController()// common.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: str) common.urlStr = str common.hidesBottomBarWhenPushed = true weakSelf!.navigationController?.pushViewController(common, animated: true) return nil &#125;) return cell &#125;else if indexPath.item == 1 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("bCell", forIndexPath: indexPath) as! BrandCollectionViewCell return cell &#125;else if indexPath.item == 2 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("hCell", forIndexPath: indexPath) as! HomeCollectionViewCell cell.myClosure = &#123; (content_id: String) -&gt; Void in let shopVC = ShopViewController() let url = "http://mobile.iliangcang.com/goods/goodsList?a=b&amp;list_id=$&amp;count=10&amp;page=1&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" shopVC.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: content_id) self.navigationController?.pushViewController(shopVC, animated: true) &#125; return cell &#125;else if indexPath.item == 3 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("sCell", forIndexPath: indexPath) as! SubjectCollectionViewCell return cell &#125;else &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("gCell", forIndexPath: indexPath) as! GiftCollectionViewCell return cell &#125; &#125; func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; UIView.animateWithDuration(0.3) &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (self.collectionView.contentOffset.x / (UIScreen.mainScreen().bounds.width)), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125; let btn = buttonsArray.objectAtIndex(Int(self.collectionView.contentOffset.x / UIScreen.mainScreen().bounds.width)) btn.titleLabel?!.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift tableViewCell 高度自适应]]></title>
    <url>%2FSwift-tableViewCell-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[1234567891011 static func cellhight (content: String) -&gt; CGFloat &#123; let rect: CGRect = content.boundingRectWithSize( CGSizeMake(SCREENWIDTH - 20, 0), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName: UIFont.systemFontOfSize(14)], context: nil) return rect.height + 61 &#125; 在返回cell 的高度的方法中直接调用return TableViewCell.cellhight(“这里面填想要自适应的文字”)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS视频图片压缩上传]]></title>
    <url>%2FiOS-%E8%A7%86%E9%A2%91%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[iOS视频图片压缩上传 上传方法: iOS-AFNetworking-3-0-上传图片视频到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 获取当前时间- (NSString *)getCurrentTime&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSString *dateTime = [formatter stringFromDate:[NSDate date]];// NSString *str = [NSString stringWithFormat:@"%@mdxx",dateTime];// NSString *tokenStr = [str stringToMD5:str]; return dateTime; &#125;#pragma mark - 视频压缩/** * 视频压缩 * * @param url 视频文件的url * * @return 压缩后的url */ - (NSURL *)condenseVideoNewUrl: (NSURL *)url&#123; // 沙盒目录 NSString *docuPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *destFilePath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyh%@.MOV",[self getCurrentTime]]]; NSURL *destUrl = [NSURL fileURLWithPath:destFilePath]; //将视频文件copy到沙盒目录中 NSFileManager *manager = [NSFileManager defaultManager]; NSError *error = nil; [manager copyItemAtURL:url toURL:destUrl error:&amp;error]; NSLog(@"压缩前--%.2fk",[self getFileSize:destFilePath]); // 播放视频 /* NSURL *videoURL = [NSURL fileURLWithPath:destFilePath]; AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.view.bounds; [self.view.layer addSublayer:playerLayer]; [player play]; */ // 进行压缩 AVAsset *asset = [AVAsset assetWithURL:destUrl]; //创建视频资源导出会话 /** NSString *const AVAssetExportPresetLowQuality; // 低质量 NSString *const AVAssetExportPresetMediumQuality; NSString *const AVAssetExportPresetHighestQuality; //高质量 */ AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:asset presetName:AVAssetExportPresetLowQuality]; // 创建导出的url NSString *resultPath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyhg%@.MOV",[self getCurrentTime]]]; session.outputURL = [NSURL fileURLWithPath:resultPath]; // 必须配置输出属性 session.outputFileType = @"com.apple.quicktime-movie"; // 导出视频 [session exportAsynchronouslyWithCompletionHandler:^&#123; NSLog(@"压缩后---%.2fk",[self getFileSize:resultPath]); NSLog(@"视频导出完成"); &#125;]; return session.outputURL;&#125;// 获取视频的大小- (CGFloat) getFileSize:(NSString *)path&#123; NSFileManager *fileManager = [[NSFileManager alloc] init] ; float filesize = -1.0; if ([fileManager fileExistsAtPath:path]) &#123; NSDictionary *fileDic = [fileManager attributesOfItemAtPath:path error:nil];//获取文件的属性 unsigned long long size = [[fileDic objectForKey:NSFileSize] longLongValue]; filesize = 1.0*size/1024; &#125; return filesize;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma mark - Picker delgate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info &#123; NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) &#123; NSLog(@"选取的是照片"); // self.imageView.image = info[UIImagePickerControllerEditedImage]; // 压缩图片 NSData *fileData = UIImageJPEGRepresentation(info[UIImagePickerControllerEditedImage], 0.5); //保存到Documents NSString *imageStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *imageFile = [imageStr stringByAppendingPathComponent:@"image.jpg"]; NSLog(@"%@",imageFile); [fileData writeToFile:imageFile atomically:YES]; //保存至相册 UIImageWriteToSavedPhotosAlbum(info[UIImagePickerControllerEditedImage], self, @selector(image:didFinishSavingWithError:contextInfo:), nil); // 上传图片 NSDictionary *dict = @&#123;@"mem_id":@"600209"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:fileData name:@"photo" fileName:@"abc.jpg" mimeType:@"image/jpeg" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"success:%@ %@",responseObject, [responseObject objectForKey:@"msg"]); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125;else&#123; // 如果是视频 NSURL *url = info[UIImagePickerControllerMediaURL]; // 获取视频总时长 CGFloat lengthTime = [self getVideoLength:url]; NSLog(@"%f",lengthTime); // 保存视频至相册 (异步线程) NSString *urlStr = [url path]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(urlStr)) &#123; UISaveVideoAtPathToSavedPhotosAlbum(urlStr, self, @selector(video:didFinishSavingWithError:contextInfo:), nil); &#125; &#125;); //压缩视频 NSData *videoData = [NSData dataWithContentsOfURL:[self condenseVideoNewUrl:url]]; //视频上传 if (lengthTime &gt;10.0f) &#123; NSLog(@"文件过大只允许上传10s视频"); &#125;else &#123; NSDictionary *dict = @&#123;@"username":@"syl"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:videoData name:@"file" fileName:@"video.mov" mimeType:@"video/quicktime" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"上传成功%@",responseObject); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125;// 获取视频时间- (CGFloat) getVideoLength:(NSURL *)URL&#123; AVURLAsset *avUrl = [AVURLAsset assetWithURL:URL]; CMTime time = [avUrl duration]; int second = ceil(time.value/time.timescale); return second;&#125;#pragma mark 图片保存完毕的回调- (void) image: (UIImage *) image didFinishSavingWithError:(NSError *) error contextInfo: (void *)contextIn &#123; NSLog(@"照片保存成功");&#125;#pragma mark 视频保存完毕的回调- (void)video:(NSString *)videoPath didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextIn &#123; if (error) &#123; NSLog(@"保存视频过程中发生错误，错误信息:%@",error.localizedDescription); &#125;else&#123; NSLog(@"视频保存成功."); &#125;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS AFNetworking 3.0 上传图片视频到服务器]]></title>
    <url>%2FiOS-AFNetworking-3-0-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于AFNetworking 3.0图片上传的封装 .h1234567891011typedef NS_ENUM(NSUInteger, ResposeStyle) &#123; JSON, XML, Data,&#125;;typedef NS_ENUM(NSUInteger, RequestStyle) &#123; RequestJSON, RequestString, RequestDefault&#125;; .m @param url 服务器地址 @param parameters 字典 token @param fileData 要上传的数据 @param name 服务器参数名称 后台给你 @param fileName 文件名称 图片:xxx.jpg,xxx.png 视频:video.mov @param mimeType 文件类型 图片:image/jpg,image/png 视频:video/quicktime @param style 返回的数据类型 @param progress @param success @param failure 123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (void)upLoadToUrlString:(NSString *)url parameters:(NSDictionary *)parameters fileData:(NSData *)fileData name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType response:(ResposeStyle)style progress:(void (^)(NSProgress *))progress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123; //1.获取单例的网络管理对象 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.根据style 的类型 去选择返回值得类型 switch (style) &#123; case JSON: manager.responseSerializer = [AFJSONResponseSerializer serializer]; break; case XML: manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; break; case Data: manager.responseSerializer = [AFHTTPResponseSerializer serializer]; break; default: break; &#125; //3.设置相应数据支持的类型 [manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript",@"text/html",@"text/css",@"text/plain", @"application/javascript",@"application/json", @"application/x-www-form-urlencoded", nil]]; [manager POST:url parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; [formData appendPartWithFileData:fileData name:name fileName:fileName mimeType:mimeType]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(task, responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(task, error); &#125; &#125;];&#125; PS:上传图片前，必须先压缩图片，不然图片过大，可能会导致上传失败！ 具体上传操作:iOS-视频图片压缩上传]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView添加类似微信的进度条]]></title>
    <url>%2FiOS-WKWebView%E6%B7%BB%E5%8A%A0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[WKWebView添加类似微信的进度条 1.m中声明两个属性@property (nonatomic, strong) WKWebView *wkWebView;@property (nonatomic, strong) UIProgressView *progressView;@property (nonatomic, assign) NSUInteger loadCount; 2.初始化方法…省略 3.添加KVO12通过监听estimatedProgress可以获取它的加载进度 还可以监听它的title ,URL, loading[wkWebView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:nil]; 4.计算进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@"loading"]) &#123; &#125; else if ([keyPath isEqualToString:@"title"]) &#123; self.title = self.wKWebView.title; &#125; else if ([keyPath isEqualToString:@"URL"]) &#123; &#125; else if ([keyPath isEqualToString:@"estimatedProgress"]) &#123; self.progressView.progress = self.wKWebView.estimatedProgress; &#125; if (object == self.wKWebView &amp;&amp; [keyPath isEqualToString:@"estimatedProgress"]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; if (newprogress == 1) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; [self.progressView setProgress:newprogress animated:YES]; &#125; &#125;&#125; - (void)setLoadCount:(NSUInteger)loadCount &#123; _loadCount = loadCount; if (loadCount == 0) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; CGFloat oldP = self.progressView.progress; CGFloat newP = (1.0 - oldP) / (loadCount + 1) + oldP; if (newP &gt; 0.95) &#123; newP = 0.95; &#125; [self.progressView setProgress:newP animated:YES]; &#125;&#125;// 页面开始加载时调用 - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123; self.loadCount ++;&#125;// 内容返回时 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123; self.loadCount --; &#125;//失败 - (void)webView:(WKWebView *)webView didFailNavigation: (null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123; self.loadCount --; NSLog(@"%@",error);&#125; 最后别忘记在dealloc 中取消监听]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 线程同步方法]]></title>
    <url>%2FiOS-GCD-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们使用GCD的时候如何让线程同步，目前我能想到的就三种 dispatch_group dispatch_barrier dispatch_semaphore dispatch_group 线程组线程组，是一种同步机制，可以让某些线程先执行，某些线程最后执行，以控制线程的执行顺序。 有这么一个需要，分别执行2个耗时的异步操作，等2个异步操作都执行完毕后在回到主线程执行操作。如果想要快速高效地实现这个需求，可以考虑使用线程组。 线程组的创建代码如下： 创建dispatch_group_t1dispatch_group_t group = dispatch_group_create(); 往线程组里面添加任务的函数如下自己创建队列：使用dispatch_group_async。 无法直接使用队列变量（如使用AFNetworking添加异步任务）：使用dispatch_group_enter，dispatch_group_leave 调用了dispatch_group_enter(dispatch_group_t group) 之后,必须有与之对应的dispatch_group_leave(dispatch_group_t group) 才行 第一种: 12345678group 负责监控任务，queue 负责调度任务 dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; i = 1; &#125;); dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; j = 2; &#125;); 第二种: 1234567891011121314151617AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];//Enter groupdispatch_group_enter(group);[manager GET:@"http://www.baidu.com" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //Deal with result... //Leave group dispatch_group_leave(group);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //Deal with error... //Leave group dispatch_group_leave(group);&#125;];//More request... 监听所有任务完成 － 等到 group 中的所有任务执行完毕后，”由队列调度 block 中的任务异步执行”在当前线程阻塞的同步等待：dispatch_group_wait。 添加一个异步执行的任务作为结束任务：dispatch_group_notify 123 dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"%d",i+j); &#125;); 适用于后台批量下载 结束后主线程统一刷新UI dispatch_barrier 栅栏块 dispatch_barrier_async,对于同一个队列中的不同任务而言，在dispatch_barrier_async之前的先执行，在dispatch_barrier_async后面的后执行 . 123456789101112131415161718192021222324_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);- (NSString *)someString&#123; __weak NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString *)someString&#123; // barrier dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 函数dispatch_barrier_sync和 dispatch_barrier_async可以让队列中派发的 block 变成 barrier（栅栏） 使用，这种 block 称为 barrier block。队列中的 barrier block 必须等当前并发队列中的 block 都执行结束才开始执行，时序图如下： 在这个并发队列中,读取操作是用普通的块来实现的,而写入操作则是用栅栏块来实现的,读取操作可以并行,但写入操作必须单独执行,因为他是栅栏快.注意dispatch_barrier_async的同步控制和线程组、信号量的同步机制是不一样的，dispatch_barrier_async是对于同一个队列中的不同任务而言的，线程组和信号量是对于不同线程而言的。 dispatch_semaphore 信号量 创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要先去增加它的数量（增加信号量也叫作发射信号量）。 初始value = 0时，信号量–，小于0，wait线程阻塞。然后执行signal，信号量++，激活wait线程。 123456789101112131415 dispatch_semaphore_t sema = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); NSLog(@"等你"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"发送信号"); [NSThread sleepForTimeInterval:5]; dispatch_semaphore_signal(sema); &#125;);]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>多线程</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 的使用技巧]]></title>
    <url>%2FiOS-GCD-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用dispatch_once来执行只需要运行一次的线程安全代码假设写一个ViewController类的单例方法 12345678+ (id)sharedInstance&#123; static ViewController *vc = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; vc = [ViewController new]; &#125;); return vc;&#125; 注: 使用dispatch_once 可以简化代码并且彻底保证线程安全，根本无需担心加锁或同步。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。把该变量定义在static作用域中，可以保证保证编译器在每次执行sharedInstance方法时都会复用这个变量而不会创建新的变量。采用dispatch_once方式来实现sharedInstance方法的速度几乎是@synchronized的两倍。 dispatch_after功能：延迟一段时间把一项任务提交到队列中执行，返回之后就不能取消，常用来在在主队列上延迟执行一项任务 官方文档说明: 1Enqueue a block for execution at the specified time. Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中 代码示例: 12345 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"延迟5s在这执行..."); &#125;); 注意 : 使用dispatch_after实现延迟执行某动作，时间并不是很精确，实际上是过多久将Block追加到main Queue中，而不是执行该动作，如果此时main queue中的任务很多，没有执行完毕，那么新添加的这个动作就要继续推迟。 如果对时间的精确度没有高要求，只是为了推迟执行，那么使用dispatch_after还是很不错的。 正确创建dispatch_time_t 用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用dispatch_time函数，其原型如下： 1dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta )*;* 第一个参数一般是DISPATCH_TIME_NOW，表示从现在开始。那么第二个参数就是真正的延时的具体时间。 这里要特别注意的是，delta参数是“纳秒！”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下： 123#define NSEC_PER_SEC 1000000000ull#define USEC_PER_SEC 1000000ull#define NSEC_PER_USEC 1000ull 关键词解释：NSEC：纳秒。USEC：微妙。SEC：秒PER：每 所以：NSEC_PER_SEC，每秒有多少纳秒。USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）NSEC_PER_USEC，每毫秒有多少纳秒。 所以，延时1秒可以写成如下几种： 123dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC)dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC)dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC) 最后一个“USEC_PER_SEC * NSEC_PER_USEC”，翻译过来就是“每秒的毫秒数乘以每毫秒的纳秒数”，也就是“每秒的纳秒数”。 dispatch_suspend dispatch_resume 挂起、恢复队列代码示例: 123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create("", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"5s后执行此操作"); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"5s后执行此操作"); &#125;); //挂起 dispatch_suspend(queue); NSLog(@"挂起"); // 恢复 dispatch_resume(queue); NSLog(@"恢复"); 这里要注意的是: dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧 dispatch_applydispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，其实就是简化了用循环去向队列依次添加block任务。代码示例: //创建异步串行队列1234567 dispatch_queue_t queue = dispatch_queue_create("test.gcd", DISPATCH_QUEUE_SERIAL); //运行block3次 dispatch_apply(3, queue, ^(size_t i) &#123; NSLog(@"%zu", i); &#125;); //打印信息 NSLog(@"After apply"); 注意: dispatch_apply会“等待”其所有的循环运行完毕才往下执行.会阻塞主线程]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>多线程</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 的简单使用(基础)]]></title>
    <url>%2FiOS-GCD-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言在iOS开发中，苹果提供了三种多线程技术，分别是： NSThread NSOperation GCD 简单介绍一下GCD的使用。GCD全称 Grand Central Dispatch，可以称之为大中央调度。实际上GCD是管理着一个线程池，如何创建线程，如何回收线程，以及分配多少个线程，这些都是GCD来控制的。在开发中，程序员是不用操作线程的相关事情，程序员只需要把应该做的操作放到相应的队列里面即可。 自定义队列GCD中有多种队列，其中自定义的队列有两种：串行队列和并行队列 串行队列：队列中的任务只会顺序执行，且一次只能够执行一个任务。也就是说，执行完一个任务后，才会执行下一个任务。 并行队列：可以一次执行多个任务。比如说并行队列中有10个任务，可以一次执行3个任务，这三个任务哪个先执行完了，再接着执行剩下的任务。 注意：无论是串行队列还是并行队列，他们都是FIFO（先进先出）的。也就是说，无论是哪种队列，任务进队列的时间越早，其执行的时间就越早（只不过某些情况下任务执行的结束时间是不确定的）。 GCD中有两种操作，分别是同步操作和异步操作 同步操作：不会新开线程 异步操作：会开启新的线程 两种操作和两种队列，组合为4种情况，实际上，在开发中，有些组合基本上是不会用到的。下面用程序描述一下四种组合。 串行队列 + 同步操作 (不会新建线程，而且任务是一个一个的执行，因此实际上就是顺序执行），代码如下：1234567891011121314- (void)serialAndSync &#123; dispatch_queue_t queue = dispatch_queue_create("serialSync", DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ -- %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: number = 1,说明是主线程，没有新开线程。 串行队列+异步操作（因为任务要一个一个的执行，但是因为是异步操作，所以会开启一个新的线程，所有的任务都在新的线程上执行），代码如下：123456789101112- (void)serialAndAsync &#123; dispatch_queue_t queue = dispatch_queue_create("serialAsync", DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@ -- %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: number = 2，说明开启了一个新的子线程，但仍然是顺序执行。 并行队列+同步操作（因为同步操作不会开启新的线程，因此，即使并行队列可以一次开始多个任务，但实际上仍旧是每个任务都在主线程上执行，且按顺序执行）。代码如下：12345678910- (void)concurrentAndSync &#123; dispatch_queue_t queue = dispatch_queue_create("concurrentSync", DISPATCH_QUEUE_CONCURRENT); for(int i = 0; i &lt; 10; ++i)&#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125;&#125; 运行结果: 没有开启新的线程，且按顺序执行。 并行队列+异步操作（并行队列会一次开始多个任务，且异步操作可以开启新的线程，因此同一时刻可能会同时执行多个任务，开启多个线程，且每个任务的结束时间是不确定的）。代码如下：12345678910- (void)concurrentAndAsync &#123; dispatch_queue_t queue = dispatch_queue_create("concurrentAsync", DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@%d",[NSThread currentThread],i); &#125;); &#125;&#125; 运行结果: 可以看到，开启了多个线程，且任务不是按顺序执行完的。 全局队列为了方便开发，苹果还提供了有全局队列，全局队列实际上是并行队列，因此，全局队列的执行结果和并行队列的执行结果是一致的。代码如下： 全局队列+同步任务：1234567891011- (void)globalSync &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int i = 0; i &lt; 10; ++i)&#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 全局队列+异步任务：12345678910- (void)golbalAsync &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int i = 0; i &lt; 10; ++i)&#123; dispatch_async(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 主队列苹果还提供了一种队列是主队列，主队列是串行队列，但是和串行队列又有差异。主队列上的任务都应该在主线程上顺序执行，没有异步的概念。也就是说，即使是异步任务在主队列上执行，也不会开启新的线程。 主队列+异步任务：1234567891011- (void)mainAsync &#123; dispatch_queue_t queue = dispatch_get_main_queue(); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 主队列+同步任务（会阻塞线程），代码如下：1234567891011- (void)mainSync &#123; dispatch_queue_t queue = dispatch_get_main_queue(); for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 阻塞原因： 主队列中本身是有一个任务A的（主任务），且该任务A还没有执行完。在执行任务A的过程中，又插入了新的同步任务B。我们知道，串行队列中，必须先执行完一个任务后，才能继续执行另一个任务。此时的情况时：若想继续执行任务A，需要先把任务B执行完，若想继续执行任务B，需要先把任务A执行完，因此造成了阻塞。在开发中，应该避免这种阻塞的情况。]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>多线程</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS的三种多线程技术]]></title>
    <url>%2FiOS%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[iOS的三种多线程技术 NSThread 每个NSThread对象对应一个线程，量级较轻（真正的多线程） 以下两点是苹果专门开发的“并发”技术，使得程序员可以不再去关心线程的具体使用问题 NSOperation/NSOperationQueue 面向对象的线程技术 GCD —— Grand Central Dispatch（派发） 是基于C语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术 以上这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的，在项目中很多框架技术分别使用了不同多线程技术。 三种多线程技术的对比NSThread: 优点：NSThread 比其他两个轻量级，使用简单 缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销 NSOperation： 不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上 NSOperation是面向对象的 GCD： Grand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术 GCD是基于C语言的 三种多线程技术的实现NSThread的多线程技术，类方法直接开启后台线程，并执行选择器方法detachNewThreadSelector 123//新建一个线程，调用@selector方法 [NSThread detachNewThreadSelector:@selector(bigDemo) toTarget:self withObject:nil]; 成员方法，在实例化线程对象之后，需要使用start执行选择器方法initWithTarget 1234//成员方法 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(bigDemo) object:nil]; // 启动start线程[thread start]; 对于NSThread的简单使用，可以用NSObject的performSelectorInBackground替代 12//performSelectorInBackground是将bigDemo的任务放在后台线程中执行[self performSelectorInBackground:@selector(bigDemo) withObject:nil]; 同时，在NSThread调用的方法中，同样要使用autoreleasepool进行内存管理，否则容易出现内存泄露。 12345// 自动释放池// 负责其他线程上的内存管理，在使用NSThread或者NSObject的线程方法时，一定要使用自动释放池// 否则容易出现内存泄露。 @autoreleasepool &#123; &#125; NSOperation，面向对象的多线程技术使用步骤：实例化操作队列_queue = [[NSOperationQueue alloc] init]; //NSInvocationOperation 123456NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(opAction) object:nil];// 如果使用start，会在当前线程启动操作// [op1 start];// 一旦将操作添加到操作队列，操作就会启动 [_queue addOperation:op1]; //NSBlockOpera 123456789101112131415161718192021222324252627#pragma mark 模仿下载网络图像- (IBAction)operationDemo3:(id)sender&#123; // 1. 下载 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"下载 %@" , [NSThread currentThread]); &#125;]; // 2. 滤镜 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"滤镜 %@" , [NSThread currentThread]); &#125;]; // 3. 显示 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"更新UI %@" , [NSThread currentThread]); &#125;]; // 添加操作之间的依赖关系，所谓“依赖”关系，就是等待前一个任务完成后，后一个任务才能启动 // 依赖关系可以跨线程队列实现 // 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。 [op2 addDependency:op1]; [op3 addDependency:op2];// [op1 addDependency:op3]; [_queue addOperation:op1]; [_queue addOperation:op2]; [[NSOperationQueue mainQueue] addOperation:op3];&#125; 将操作添加到队列NSOperationQueue即可启动多线程执行12[_queue addOperation:op1];[_queue addOperation:op2]; 更新UI使用主线程队列12345//两方式[NSOpeationQueue mainQueue] addOperation ^&#123; &#125;; [[NSOperationQueue mainQueue] addOperation:op3]; 3.操作队列的setMaxConcurrentOperationCount可以设置同时并发的线程数量！12// 控制同时最大并发的线程数量[_queue setMaxConcurrentOperationCount:2]; 提示：此功能仅有NSOperation有 使用addDependency可以设置任务的执行先后顺序，同时可以跨操作队列指定依赖关系123456// 添加操作之间的依赖关系，所谓“依赖”关系，就是等待前一个任务完成后，后一个任务才能启动// 依赖关系可以跨线程队列实现// 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。[op2 addDependency:op1];[op3 addDependency:op2];[op1 addDependency:op3]; 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。 GCD，C语言GCD就是为了在“多核”上使用多线程技术 要使用GCD，所有的方法都是dispatch开头的名词解释 global 全局 queue 队列 async 异步 sync 同步 要执行异步的任务，就在全局队列中执行即可 dispatch_async 异步执行控制不住先后顺序 关于GCD的队列全局队列: dispatch_get_global_queue123456参数：优先级 `DISPATCH_QUEUE_PRIORITY_DEFAULT` 始终是 0dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);可同步 可异步 串行队列:dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);是创建得到的，不能直接获取只能同步 主队列: dispatch_get_main_queue1234dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"main - &gt; %@", [NSThread currentThread]);&#125;);只能同歩 异步和同步与方法名无关，与运行所在的队列有关！同步主要用来控制方法的被调用的顺序]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现对UIAlertController和UIAlertView判断系统后的简单封装]]></title>
    <url>%2F%E5%AE%9E%E7%8E%B0%E5%AF%B9UIAlertController%E5%92%8CUIAlertView%E5%88%A4%E6%96%AD%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[iOS8之后用UIAlertController代替了UIAlertView,所以每次有需要弹窗的时候,都需要先判断系统,最近在做的项目中弹窗较多,如果每次都判断,真是太麻烦了,索性对UIAlertController和UIAlertView进行的封装了,封装在一个工具类中,在工具类中就对系统进行判断,然后在你需要弹窗的界面直接调用这个工具类的方法就可以了,减少了代码的耦合. 这个工具类其实也封装的特别简单,因为都是用的系统的,分享出来给大家参考下: 首先是.h文件12345[objc] view plaincopy@interface UIAlertTool : NSObject-(void)showAlertView:(UIViewController *)viewController :(NSString *)title :(NSString *)message :(NSString *)cancelButtonTitle :(NSString *)otherButtonTitle :(void (^)())confirm :(void (^)())cancle;@end 只有这么一个简单的方法 把你需要在弹窗中显示的内容以参数的形式传入就可以了 然后是.m文件的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[objc] view plaincopy#define IAIOS8 ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)#import "UIAlertTool.h"typedef void (^confirm)();typedef void (^cancle)();@interface UIAlertTool()&#123; confirm confirmParam; cancle cancleParam;&#125;@end@implementation UIAlertTool-(void)showAlertView:(UIViewController *)viewController :(NSString *)title :(NSString *)message :(NSString *)cancelButtonTitle :(NSString *)otherButtonTitle :(void (^)())confirm :(void (^)())cancle&#123; confirmParam=confirm; cancleParam=cancle; if (IAIOS8) &#123; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title message:message preferredStyle:UIAlertControllerStyleAlert]; // Create the actions. UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:cancelButtonTitle style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; cancle(); &#125;]; UIAlertAction *otherAction = [UIAlertAction actionWithTitle:otherButtonTitle style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123; confirm(); &#125;]; // Add the actions. [alertController addAction:cancelAction]; [alertController addAction:otherAction]; [viewController presentViewController:alertController animated:YES completion:nil]; &#125; else&#123; UIAlertView *TitleAlert = [[UIAlertView alloc] initWithTitle:title message:message delegate:self cancelButtonTitle:otherButtonTitle otherButtonTitles:cancelButtonTitle,nil]; [TitleAlert show]; &#125;&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex==0) &#123; confirmParam(); &#125; else&#123; cancleParam(); &#125;&#125;@end]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS9 新增 UIStackView 官方文档翻译]]></title>
    <url>%2FiOS9-%E6%96%B0%E5%A2%9E-UIStackView-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[iOS9 新增 UIStackView 官方文档翻译 一、继承关系、遵守协议、隶属框架及可用平台 UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。Stack视图管理着所有在它的 arrangedSubviews 属性中的视图的布局。这些视图根据它们在 arrangedSubviews 数组中的顺序沿着 Stack 视图的轴向排列。精确的布局变量根据 Stack 视图的 axis, distribution,alignment, spacing, 和其它属性共同决定。 使用 stack 视图，打开一个你希望编辑的 Storyboard，从对象库中拖拽出一个 Horizontal Stack View 或者一个 Vertical Stack View，并放置到你希望的位置上 。下一步，将控件或视图拖拽放置到 stack 中,也可以先拖拽控件再合并为 Stack View，如果需要你可以继续添加视图或者控件给指定的 stack。Interface Builder 将根据 stack 的内容自动调节尺寸。你也可以通过修改属性面板中 Stack视图的属性调整 stack 内容的外观。 注意：你需要负责指定 stack 视图的位置和尺寸（可选的）。然后 stack 视图将管理其内容的布局和尺寸。 二、Stack 视图与自动布局Stack 视图使用自动布局来定位和控制其管理的视图的尺寸。stack 视图沿着它的轴向拼凑第一个和最后一个被管理视图，使其边界平齐。对于一个水平 stack 视图，这意味着第一个被管理视图的左边界是与 stack 的左边界平齐的，并且最后一个被管理视图右边界与 stack的右边界平齐。对于垂直 stack，上边界和下边界是各自平齐的。如果你设置了 stack 视图的 layoutMarginsRelativeArrangement 属性为 YES，stack 视图将使用相关的边距与其内容对齐，而不是边界。 对于除去 UIStackViewDistributionFillEqually 分布以外的分布方式，stack 视图使用被管理视图的 intrinsicContentSize 属性来计算沿着 stack 轴向的视图尺寸。UIStackViewDistributionFillEqually 分布将调节所有被管理视图的在 stack 轴向上拥有相同尺寸，以填充 stack 视图。如果可能，stack 视图将拉伸所有被管理视图，来匹配其在 stack 轴向上最长的原有尺寸（译注：保证长宽比的情况下根据 stack 轴向长度拉伸视图）。 对于除去 UIStackViewAlignmentFill 对齐方式以外的对齐方式，stack 视图使用其管理的视图的 intrinsicContentSize 属性来计算视图垂直于 stack 轴向的尺寸。 UIStackViewAlignmentFill 重新调节了所有其管理的视图，使这些视图填充 stack 视图垂直于其轴向空间。如果可能，stack 视图将拉伸其所有管理的视图来匹配其垂直于 stack 轴向的最大固有尺寸。 三、定位和调整 Stack 视图尺寸当 Stack 视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位 stack 视图。通常情况下，这意味着需要拼凑至少两个边界相邻的stack来定义它的位置。没有额外约束的情况下，系统会为 stack 视图计算一个尺寸来适应其内容： 沿着 stack 视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和； 垂直于 stack 视图轴向，其适应尺寸等于其管理的视图中最大的视图的尺寸； 如果 stack 视图的 layoutMarginsRelativeArrangement 属性设置为 YES，stack 视图的适应尺寸会包括边距空间。 你可以提供额外的约束来具体说明 stack 视图的高度、宽度或者两者兼有。在这些情况下，stack 视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据 stack 视图的属性获得。可以通过查看 UIStackViewDistribution 和 UIStackViewAlignment 枚举，以获得一个完整的 stack 视图在其内容空间多余或空间不足情况下的处理描述。 你也可以根据 stack 视图的第一条或最后一条基线定位它，而不是使用顶部、底部或者中心的Y值。类似于 stack 视图的适应尺寸，这些基线都是基于 stack 视图的内容计算得到的。 一个水平的 stack 视图调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法时返回它最高的视图。如果最高的视图也是一个 stack 视图，那么其返回的将是在嵌套的 stack 视图上调用 viewForFirstBaselineLayout 方法或viewForLastBaselineLayout 方法的结果。 一个垂直的 stack 视图当调用 viewForFirstBaselineLayout 方法时返回的是其管理的第一个视图，当调用viewForLastBaselineLayout 方法时返回的是其管理的最后一个视图。如果这两个视图之一也是 stack 视图，那么其返回的将是在嵌套的 stack 视图上对应调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法的结果。 注意：基线对齐方式只作用于那些高度匹配其原本内容高度的视图。如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。 四、通用 Stack 视图布局 这有一些通用方法用于 stack 视图。这个清单是要高亮一些有用的示例来显示 stack 视图的灵活性。目前这还不是一个完整的清单。 只是定义位置。你可以通过固定两个与其父视图相邻的边界来定义 stack 视图的位置。在这里，stack 视图的尺寸将根据其管理的视图在两个维度上自由扩展。当你想要 stack 视图的内容展现其原有内容尺寸，和你想要管理其他与 stack 视图有关联的用户接口元素时是特别有用的。 举个例子，在 Figure 1中，stack 视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基线校准。这对于相对于其本身左对齐的 stack 视图内容是有效的。 Figure 1.定义位置 定义沿着 stack 视图轴向的尺寸。这里，你固定了沿着 stack 视图轴向相对于其父视图的两个边界，定义了 stack 视图沿着其轴向的尺寸。你将需要固定其他边界中的一个来定义 stack 视图的位置。stack 视图将沿着其轴向改变尺寸和位置来填充定义的空间；然而，未固定的边界将根据其管理的最大视图的尺寸自由移动。 举例如 Figure 2，stack 视图的左、上、右边界都已经相对于其父视图固定了。使用 UIStackViewDistributionFill 分布使得其内容重设尺寸来填充它的宽度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。 Figure 2.定义沿着 stack 视图轴向的尺寸 定义垂直于 stack 视图轴向的尺寸。这类似于上一个示例，但是你固定了垂直于 stack 视图轴向的两个边界和沿着轴向的一个边界。这使得 stack 视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了 UIStackViewDistributionFillEqually 分布，被管理的视图将根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其 stack 视图的对其模式在其定义的范围内平铺。 举例，Figure 3展示了一个包含了四个标签和一个按钮的垂直 stack 视图。这个 stack 视图使用了8个点的间隙和UIStackViewAlignmentCenter 对齐方式。stack 视图的高度将根据 stack 内部的元素的增减而增大或回缩。 Figure 3.定义垂直于 stack 视图轴向的尺寸 同时定义 stack 视图的位置和尺寸。这里你固定了 stack 视图的所有四个边界。stack 视图将在提供的范围之内平铺其内容。举例，Figure 4展示了一个所有四个边界都相对于其父视图固定的垂直 stack 视图。通过使用 UIStackViewAlignmentCenter 对齐方式和UIStackViewDistributionFill 分布方式，stack 视图确保其内容将水平和垂直居中填充屏幕。然而，获得想要的布局需要两个额外的步骤。默认情况下，stack视图会垂直拉伸标签而不是图片。要缩放图片控件，就要降低其内容紧凑优先级到低于标签。额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit。增加一个图片视图与 stack 视图间宽度相等约束将有助于确保图片将被缩放来填充可用范围。 Figure 4.同时定义 stack 视图的位置和尺寸 五、管理 Stack 视图的展现UIStackView 是 UIView 的非渲染型子类。它没有提供其自有的任何用户接口。相反的，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如 backgroundColor)在 stack 视图上是无效的。类似的，你无法重写 layerClass，drawRect: 或 drawLayer:inContext: 方法。 这里有一系列的属性来定义 stack 视图如何平铺其内容。 axis(轴向) 属性决定了 stack 的朝向，只有垂直或水平；distribution(分布) 属性决定了其管理的视图在沿着其轴向上的布局； alignment(对齐) 属性决定了其管理的视图在垂直于其轴向上的布局； spacing(空隙) 属性决定了其管理的视图间的最小间隙； baselineRelativeArrangement 属性决定了其视图间的垂直间隙是否根据基线测量得到； layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距 通常情况下，你会使用一个 stack 视图来布局小数量的视图。你可以通过在其他 stack 视图中嵌套多个 stack 视图的方式创建更加复杂的视图层次结构。举例，Figure 5展示了一个包含两个水平 stack 视图的垂直 stack 视图。每一个水平 stack 视图各包含一个标签和一个文本框。 Figure 5.Stack 视图的嵌套 你也可以通过增加被管理的视图的额外约束来完美的调节一个被管理视图的展现。举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度。或者你可以定义一个长宽比。当平铺其内容时，stack 视图将使用这些约束。举例来说，在Figure 4中，当图片被缩放时，图片视图的一个长宽比约束被强行赋予了一个长宽比常数。 注意：当给一个 stack 视图内的视图增加约束时要特别注意避免传入冲突。作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容尺寸，那么你可以安全的在这个维度上增加约束。 六、维护其管理的视图与子视图之间的统一性Stack 视图确保它的 arrangedSubviews 属性将一直是其 subviews 属性的子集合。明确的说，stack 视图强制实施了以下规定： 无论何时 stack 视图增加了一个视图到它的 arrangedSubviews 数组，其也将把这个视图作为子视图增加，如果还未增加的话。 无论何时一个子视图从 stack 视图中被移除，那么 stack 视图也将将其从 arrangedSubviews 数组中移除。 从 arrangedSubviews 移除一个视图并不会将其作为子视图移除。stack 视图将不再管理该视图的尺寸和位置，但是该视图仍将是视图结构的一部分，并且当其可见的情况下仍会被渲染到屏幕上。 当 arrangedSubviews 数组一直包含着 subviews 数组的子集合，这些数组间的顺序仍然是独立的。 arrangedSubviews 数组的顺序定义了展现在 stack 中的视图的顺序。对于水平 stack 视图，这些视图将以阅读顺序平铺，即较小索引的视图在较大索引视图的左侧。对于垂直 stack 视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。 subviews 数组中的顺序定义了子视图在Z轴上是顺序。如果视图重叠，有较小索引的子视图将出现在有较大索引的子视图后方。 七、动态改变 Stack 视图内容当视图被加入、移出或插入 arrangedSubviews 数组时，或当一个被管理的子视图的 hidden 属性改变时，stack 视图都会自动更新它的布局。 OC代码如下 : 1234// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES; Swift代码如下： 12345// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. let firstView = stackView.arrangedSubviews[0] firstView.hidden = true stack 视图也会自动响应其任何属性的改变。举例，你可以更新 stack 视图的 axis 属性来动态改变的朝向。 OC代码如下： 12345678// Toggle between a vertical and horizontal stackif (self.stackView.axis == UILayoutConstraintAxisHorizontal) &#123; self.stackView.axis = UILayoutConstraintAxisVertical;&#125;else &#123; self.stackView.axis = UILayoutConstraintAxisHorizontal;&#125; Swift代码如下： 123456789// Toggle between a vertical and horizontal stackif stackView.axis == .Horizontal &#123; stackView.axis = .Vertical&#125;else &#123; stackView.axis = .Horizontal&#125; 对于被管理的子视图的 hidden 属性的变化和 stack 视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画方式展现。 OC代码如下： 12345// Animates removing the first item in the stack.[UIView animateWithDuration:0.25 animations:^&#123; UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES;&#125;]; Swift代码如下： 12345// Animates removing the first item in the stack.UIView.animateWithDuration(0.25) &#123; () -&gt; Void in let firstView = stackView.arrangedSubviews[0] firstView.hidden = true&#125; 最后，你可以直接在Interface Builder中给很多 stack 视图属性定义特定的 “尺寸类” 类型值。系统将在 stack 视图的尺寸类改变时动画展现这些改变。 八、常用的方法创建 Stack 视图 - initWithArrangedSubviews: (New in iOS 9.0) 管理安排的子视图 1234567addArrangedSubview: (New in iOS 9.0)arrangedSubviews Property (New in iOS 9.0)insertArrangedSubview:atIndex: (New in iOS 9.0)removeArrangedSubview: (New in iOS 9.0) 设置布局 1234567891011alignment Property (New in iOS 9.0)axis Property (New in iOS 9.0)baselineRelativeArrangement Property (New in iOS 9.0)distribution Property (New in iOS 9.0)layoutMarginsRelativeArrangement Property (New in iOS 9.0)spacing Property (New in iOS 9.0) 常量 12UIStackViewDistributionUIStackViewAlignment]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO的底层实现]]></title>
    <url>%2FKVO%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[了解一下KVO的底层实现原理: KVO 是基于 RunTime 机制实现的 当某个类的对象第一次被观察时,系统就会在运行期动态的创建该类的一个派生类,在这个派生类中重写基类中任何被观察属性的setter方法.派生类在被重写的setter方法实现真正的通知机制 (Person → NSKVONotifying Person) 代码实现部分:首先创建一个Person类和一个Dog 类 (类名可以随便) 并在Person类中声明一个age 属性来做被监听的属性1234567#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) NSInteger age;@end 在ViewController的.m 中实现以下代码1234567891011121314151617181920212223242526#import "ViewController.h"#import "Person.h"#import "Dog.h"@interface ViewController ()@property (nonatomic, strong) Person *person;@property (nonatomic, strong) Dog *dog;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [Person new]; self.dog = [Dog new]; // 让self.dog 监听 self.person的age 属性的改变 [self.person addObserver:self.dog forKeyPath:@"age" options:0 context:nil]; &#125;// 点击屏幕改变self.person 的age属性- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; self.person.age = 10; &#125; 在Dog类的.m文件中调用KVO的监听方法代码如下:123456789#import "Dog.h"@implementation Dog- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; NSLog(@"监听到了%@的%@属性改变了",object, keyPath); &#125; 这时当我们点击屏幕的时候就会触发监听方法打印内容如下: 以上就是KVO的实现 但是他的底层是怎么实现的呢 ? 接下来我们来了解一下 首先我们再新建一个Person的子类NSKVONotifying Person类 注意:想要监听一个属性的改变就需要调用这个属性的setter方法令他的属性改变,但是在那里调用呢 ? 这时系统就会自动生成一个继承于Person 的类也就是我们所创建的NSKVONotifying Person类,在这个类中会调用Person类中所有发生变化的属性的Setter方法 然后将OC的isa指针指向新创建的class（这个指针告诉oc运行时某个object到底是哪种类型的object 如下:12345678910111213#import "NSKVONotifyingPerson.h"@implementation NSKVONotifyingPerson- (void)setAge:(NSInteger)age &#123; [super setAge:age]; // 将要改变age属性 [self willChangeValueForKey:@"age"]; // 已经改变了age属性 [self didChangeValueForKey:@"age"]; &#125;@end 这时我们注意到上面的setter方法中调用了两个方法:1234//将要改变age属性[self willChangeValueForKey:@"age"]; // 已经改变了age属性 [self didChangeValueForKey:@"age"]; 这两个方法的内部就会主动调用Dog类中的监听方法12345- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; NSLog(@"监听到了%@的%@属性改变了",object, keyPath); &#125; 我们可以通过打印Person类的isa 指针来观察他的变化,这时我们需要用到运行时机制并引入两个头文件12#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt; 我们分别在这两个位置打印Person的isa指针123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; self.person = [Person new]; NSLog(@&quot;初始化的self.person的类型%@&quot;,object_getClass(self.person )); self.dog = [Dog new]; // 让self.dog 监听 self.person的age 属性的改变 [self.person addObserver:self.dog forKeyPath:@&quot;age&quot; options:0 context:nil]; &#125; 上面的打印结果为: 第二处打印 123456// 点击屏幕改变self.person 的age属性- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; self.person.age = 10; NSLog(@"setter方法赋值是self.person的类型%@",object_getClass(self.person ));&#125; 打印结果为: 总结:通过观察上面的对比我们就会发现self.person的类型发生了改变由原来的 Person类 变为NSKVONotifying_Person类]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block理论]]></title>
    <url>%2FBlock%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[什么是block对于闭包（block),有很多定义，其中闭包就是能够读取其它函数内部变量的函数，这个定义即接近本质又较好理解。对于刚接触Block的同学，会觉得有些绕，因为我们习惯写这样的程序main(){ funA();} funA(){funB();} funB(){…..}; 就是函数main调用函数A，函数A调用函数B… 函数们依次顺序执行，但现实中不全是这样的，例如项目经理M，手下有3个程序员A、B、C，当他给程序员A安排实现功能F1时，他并不等着A完成之后，再去安排B去实现F2，而是安排给A功能F1，B功能F2，C功能F3，然后可能去写技术文档，而当A遇到问题时，他会来找项目经理M，当B做完时，会通知M，这就是一个异步执行的例子。在这种情形下，Block便可大显身手，因为在项目经理M，给A安排工作时，同时会告诉A若果遇到困难，如何能找到他报告问题（例如打他手机号），这就是项目经理M给A的一个回调接口，要回掉的操作，比如接到电话，百度查询后，返回网页内容给A，这就是一个Block，在M交待工作时，已经定义好，并且取得了F1的任务号（局部变量），却是在当A遇到问题时，才调用执行，跨函数在项目经理M查询百度，获得结果后回调该block。 block 实现原理Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑（需求）。下面是两篇很好的介绍block实现的博文iOS中block实现的探究谈Objective-C Block的实现 block的使用使用实例cocoaTouch框架下动画效果的Block的调用 使用typed声明block 1typedef void(^didFinishBlock) (NSObject *ob); 这就声明了一个didFinishBlock类型的block，然后便可用 1@property (nonatomic,copy) didFinishBlock finishBlock; 声明一个block对象，注意对象属性设置为copy，接到block 参数时，便会自动复制一份。 __block是一种特殊类型，使用该关键字声明的局部变量，可以被block所改变，并且其在原函数中的值会被改变。 常见系列面试题面试时，面试官会先问一些，是否了解block，是否使用过block，这些问题相当于开场白，往往是下面一系列问题的开始，所以一定要如实根据自己的情况回答。 使用block和使用delegate完成委托模式有什么优点？首先要了解什么是委托模式，委托模式在iOS中大量应用，其在设计模式中是适配器模式中的对象适配器，Objective-C中使用id类型指向一切对象，使委托模式更为简洁。了解委托模式的细节：iOS设计模式—-委托模式使用block实现委托模式，其优点是回调的block代码块定义在委托对象函数内部，使代码更为紧凑；适配对象不再需要实现具体某个protocol，代码更为简洁。 多线程与blockGCD与Block使用 dispatch_async 系列方法，可以以指定的方式执行blockGCD编程实例 dispatch_async的完整定义 123void dispatch_async( dispatch_queue_t queue, dispatch_block_t block); 功能：在指定的队列里提交一个异步执行的block，不阻塞当前线程 通过queue来控制block执行的线程。主线程执行前文定义的 finishBlock对象 12345dispatch_async(dispatch_get_main_queue(),^(void)&#123; finishBlock(); &#125;);]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解RunLoop]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop%2F</url>
    <content type="text"><![CDATA[RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。 目录 RunLoop 的概念 RunLoop 与线程的关系 RunLoop 对外的接口 RunLoop 的 Mode RunLoop 的内部逻辑 RunLoop 的底层实现 苹果用 RunLoop 实现的功能 AutoreleasePool 事件响应 手势识别 界面更新 定时器 PerformSelecter 关于GCD 关于网络请求 RunLoop 的实际应用举例 AFNetworking AsyncDisplayKit RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit); &#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 1234567struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... &#125;; 1234567struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// ? 一个基于 port 的Source 的事件。 /// ? 一个 Timer 到时间了 /// ? RunLoop 自身的超时时间到了 /// ? 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次： 应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。 应用框架层即开发人员接触到的 Cocoa 等框架。 核心框架层包括各种核心框架、OpenGL 等内容。 Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。 XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。 BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。 IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t;typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg(mach_msg_header_t *msg,mach_msg_option_t option,mach_msg_size_t send_size,mach_msg_size_t rcv_size,mach_port_name_t rcv_name,mach_msg_timeout_t timeout,mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing)。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里的中文翻译 。 关于Mach的历史可以看看这篇很有趣的文章：Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePool App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别 当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新 当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器 NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD 实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求 iOS 中，关于网络请求的接口自下至上有如下几层: 123CFSocket CFNetwork -&gt;ASIHttpRequest NSURLConnection -&gt;AFNetworking NSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworking AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"AFNetworking"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKit AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。 UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry介绍与使用实践]]></title>
    <url>%2FMasonry%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Masonry介绍与使用实践前言MagicNumber -&gt; autoresizingMask -&gt; autolayout 以上是纯手写代码所经历的关于页面布局的三个时期 在iphone1-iphone3gs时代 window的size固定为(320,480) 我们只需要简单计算一下相对位置就好了 在iphone4-iphone4s时代 苹果推出了retina屏 但是给了码农们非常大的福利:window的size不变 在iphone5-iphone5s时代 window的size变了(320,568) 这时autoresizingMask派上了用场(为啥这时候不用Autolayout? 因为还要支持ios5呗) 简单的适配一下即可 在iphone6+时代 window的width也发生了变化(相对5和5s的屏幕比例没有变化) 终于是时候抛弃autoresizingMask改用autolayout了(不用支持ios5了 相对于屏幕适配的多样性来说autoresizingMask也已经过时了) 那如何快速的上手autolayout呢? 说实话 当年ios6推出的同时新增了autolayout的特性 我看了一下官方文档和demo 就立马抛弃到一边了 因为实在过于的繁琐和啰嗦(有过经验的朋友肯定有同感) 直到iPhone6发布之后 我知道使用autolayout势在必行了 这时想起了以前在浏览Github看到过的一个第三方库Masonry 在花了几个小时的研究使用后 我就将autolayout掌握了(重点是我并没有学习任何的官方文档或者其他的关于autolayout的知识) 这就是我为什么要写下这篇文章来推荐它的原因. 介绍Masonry 源码：https://github.com/Masonry/Masonry Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。 我们先来看一段官方的sample code来认识一下Masonry 123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).with.insets(padding);&#125;]; 看到block里面的那句话: make edges equalTo superview with insets 通过链式的自然语言 就把view1给autolayout好了 是不是简单易懂? 使用看一下Masonry支持哪一些属性1234567891011@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;@property (nonatomic, strong, readonly) MASConstraint *leading;@property (nonatomic, strong, readonly) MASConstraint *trailing;@property (nonatomic, strong, readonly) MASConstraint *width;@property (nonatomic, strong, readonly) MASConstraint *height;@property (nonatomic, strong, readonly) MASConstraint *centerX;@property (nonatomic, strong, readonly) MASConstraint *centerY;@property (nonatomic, strong, readonly) MASConstraint *baseline; 在ios8发布后 又新增了一堆奇奇怪怪的属性(有兴趣的朋友可以去瞅瞅) Masonry暂时还不支持(不过你要支持ios6,ios7 就没必要去管那么多了) 在讲实例之前 先介绍一个MACRO #define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self; 快速的定义一个weakSelf 当然是用于block里面啦 下面进入正题(为了方便 我们测试的superView都是一个size为(300,300)的UIView) 下面 通过一些简单的实例来简单介绍如何轻松愉快的使用Masonry: [基础] 居中显示一个view123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view. WS(ws); UIView *sv = [UIView new]; [sv showPlaceHolder]; sv.backgroundColor = [UIColor blackColor]; [self.view addSubview:sv]; [sv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(ws.view); make.size.mas_equalTo(CGSizeMake(300, 300)); &#125;];&#125; 代码效果 使用我之间写的MMPlaceHolder 可以看到superview已经按照我们预期居中并且设置成了适当的大小 那么先看看这几行代码 //从此以后基本可以抛弃CGRectMake了1UIView *sv = [UIView new]; //在做autoLayout之前 一定要先将view添加到superview上 否则会报错 1[self.view addSubview:sv]; //mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了 123456[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;//将sv居中(很容易理解吧?) make.center.equalTo(ws.view); //将size设置成(300,300) make.size.mas_equalTo(CGSizeMake(300, 300));&#125;]; 这里有两个问题要分解一下首先在Masonry中能够添加autolayout约束有三个函数 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 其次 equalTo 和 mas_equalTo的区别在哪里呢? 其实 mas_equalTo是一个MACRO #define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) #define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__))) 可以看到 mas_equalTo只是对其参数进行了一个BOX操作(装箱) MASBoxValue的定义具体可以看看源代码 太长就不贴出来了 所支持的类型 除了NSNumber支持的那些数值类型之外 就只支持CGPoint CGSize UIEdgeInsets 介绍完这几个问题 我们就继续往下了 PS:刚才定义的sv会成为我们接下来所有sample的superView [初级] 让一个view略小于其superView(边距为10)12345678910111213141516UIView *sv1 = [UIView new];[sv1 showPlaceHolder];sv1.backgroundColor = [UIColor redColor];[sv addSubview:sv1];[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); /* 等价于 make.top.equalTo(sv).with.offset(10); make.left.equalTo(sv).with.offset(10); make.bottom.equalTo(sv).with.offset(-10); make.right.equalTo(sv).with.offset(-10); */ /* 也等价于 make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); */&#125;]; 代码效果 这里写图片描述可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事 那么为什么bottom和right里的offset是负数呢? 因为这里计算的是绝对的数值 计算的bottom需要小鱼sv的底部高度 所以要-10 同理用于right 这里有意思的地方是and和with 其实这两个函数什么事情都没做 123456- (MASConstraint *)with &#123; return self;&#125;- (MASConstraint *)and &#123; return self;&#125; 但是用在这种链式语法中 就非常的巧妙和易懂 不得不佩服作者的心思(虽然我现在基本都会省略) [初级] 让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算其宽度)123456789101112131415int padding1 = 10;[sv2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv.mas_left).with.offset(padding1); make.right.equalTo(sv3.mas_left).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv3);&#125;];[sv3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv2.mas_right).with.offset(padding1); make.right.equalTo(sv.mas_right).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv2);&#125;]; 代码效果 这里我们在两个子view之间互相设置的约束 可以看到他们的宽度在约束下自动的被计算出来了 [中级] 在UIScrollView顺序排列一些view并自动计算contentSize123456789101112131415161718192021222324252627282930313233343536373839404142434445UIScrollView *scrollView = [UIScrollView new];scrollView.backgroundColor = [UIColor whiteColor];[sv addSubview:scrollView];[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(5,5,5,5));&#125;];UIView *container = [UIView new];[scrollView addSubview:container];[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(scrollView); make.width.equalTo(scrollView);&#125;];int count = 10;UIView *lastView = nil;for ( int i = 1 ; i &lt;= count ; ++i )&#123; UIView *subv = [UIView new]; [container addSubview:subv]; subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 ) saturation:( arc4random() % 128 / 256.0 ) + 0.5 brightness:( arc4random() % 128 / 256.0 ) + 0.5 alpha:1]; [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(container); make.height.mas_equalTo(@(20*i)); if ( lastView ) &#123; make.top.mas_equalTo(lastView.mas_bottom); &#125; else &#123; make.top.mas_equalTo(container.mas_top); &#125; &#125;]; lastView = subv;&#125;[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(lastView.mas_bottom);&#125;]; 头部效果 尾部效果 从scrollView的scrollIndicator可以看出 scrollView的内部已如我们所想排列好了 这里的关键就在于container这个view起到了一个中间层的作用 能够自动的计算uiscrollView的contentSize [高级] 横向或者纵向等间隙的排列一组view很遗憾 autoLayout并没有直接提供等间隙排列的方法(Masonry的官方demo中也没有对应的案例) 但是参考案例3 我们可以通过一个小技巧来实现这个目的 为此我写了一个Category 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@implementation UIView(Masonry_LJC)- (void) distributeSpacingHorizontallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(ws.mas_left); make.centerY.equalTo(((UIView*)views[0]).mas_centerY); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(lastSpace.mas_right); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(obj.mas_right); make.centerY.equalTo(obj.mas_centerY); make.width.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.right.equalTo(ws.mas_right); &#125;];&#125;- (void) distributeSpacingVerticallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(ws.mas_top); make.centerX.equalTo(((UIView*)views[0]).mas_centerX); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(lastSpace.mas_bottom); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(obj.mas_bottom); make.centerX.equalTo(obj.mas_centerX); make.height.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(ws.mas_bottom); &#125;];&#125;@end简单的来测试一下UIView *sv11 = [UIView new];UIView *sv12 = [UIView new];UIView *sv13 = [UIView new];UIView *sv21 = [UIView new];UIView *sv31 = [UIView new];sv11.backgroundColor = [UIColor redColor];sv12.backgroundColor = [UIColor redColor];sv13.backgroundColor = [UIColor redColor];sv21.backgroundColor = [UIColor redColor];sv31.backgroundColor = [UIColor redColor];[sv addSubview:sv11];[sv addSubview:sv12];[sv addSubview:sv13];[sv addSubview:sv21];[sv addSubview:sv31];//给予不同的大小 测试效果[sv11 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(@[sv12,sv13]); make.centerX.equalTo(@[sv21,sv31]); make.size.mas_equalTo(CGSizeMake(40, 40));&#125;];[sv12 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(70, 20));&#125;];[sv13 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 50));&#125;];[sv21 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 20));&#125;];[sv31 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(40, 60));&#125;];[sv distributeSpacingHorizontallyWith:@[sv11,sv12,sv13]];[sv distributeSpacingVerticallyWith:@[sv11,sv21,sv31]];[sv showPlaceHolderWithAllSubviews];[sv hidePlaceHolder]; 代码效果 perfect! 简洁明了的达到了我们所要的效果 这里所用的技巧就是 使用空白的占位view来填充我们目标view的旁边 这点通过图上的空白标注可以看出来 小结通过以上5个案例 我觉得已经把Masonry的常用功能介绍得差不多了 如果你觉得意犹未尽呢 请下载官方的demo来学习 总而言之 Masonry是一个非常优秀的autolayout库 能够节省大量的开发和学习时间 尤其适合我这种纯代码的iOSer 在iPhone6发布后引发的适配潮中 Masonry一定可以助你一臂之力 😃]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods完整使用]]></title>
    <url>%2FCocoapods%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CocoaPods安装使用及配置私有库 如何安装?安装ruby环境,添加淘宝ruby镜像123$ gem sources --remove https://rubygems.org///等有反应之后再敲入以下命令$ gem sources -a https://ruby.taobao.org/ 查看是否设置成功:1$ gem sources -l 然后安装cocoapods:1$ sudo gem install cocoapods 查看cocoapods是否支持某个类库1$ pod search 类库名,支持模糊查询(如:AFNetworking) 如何使用?在项目根目录下新建一个“Podfile”的文件(记住一定得叫这个名儿,而且木有后缀)注:Podfile也可以放在任何位置,但是需要在Podfile顶部使用”xcodeproj”关键字指定工程的路径,如下: 但是执行pod install命令后,生成的文件放在了Podfile所在的目录. 编辑Podfile文件输入以下信息12platform :iOS, ‘7.0’\\所有库支持的IOS最低版本pod ‘AFNetworking’, ‘~&gt; 2.0’\\版本号 注:有些第三方库需要指明:platform 支持的IOS最低版本,否则在pod install时会报错,如下图,提示AFNetworking最低支持IOS6.0和OS X 10.8 然后在项目podfile所在目录下运行:(会在你当前项目中导入podfile所配置的库,所以要在项目目录下运行)$ pod install 注意上述命令运行完毕后终端输出的最后一段话,意思就是以后打开项目就用CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 [!] From now on useCocoaPodsDemo.xcworkspace. 经过以上步骤后,我们现在可以打开CocoaPodsDemo.xcworkspace启动我们的新工程了.新工程中已经通过cocoapods引入并配置好了我们刚在podfile写的需要依赖的第三方库了. 引入第三方库后找不到头文件?在项目的Targe-Build Settings-Search Paths-User Header Searcj Paths中添加 ${SRCROOT} 值为 recursive 如下图: 如何编译从github上checkout下来的一个已包含CocoPods类库的项目?打开终端进入你所下载项目的根目录,执行以下命令,后会得到上面的那句话: $ pod update 等待命令运行完毕后,同样最后会输出 [!] From now on usexxxxx.xcworkspace. 如何删除cocopods? 删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹 删除xcworkspace文件 使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources 这里写图片描述 CocoaPods常用命令pod install根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。 每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。等其执行完毕，即可完成第三方库的安装其中还可以调用pod update方法, 也可以达到第三方库安装的目的, 并且会更新版本 在pod install或者pod update过程中会执行podspec索引的更新，需要等待很久，因此为了提升速度可以执行如下命令, 关掉索引的更新 pod install --no-repo-update 并且在安装过程中, 我们不知道cocoapods做了什么, 还可以添加一个参数，用来提示我们，cococapods做了哪些操作 pod install --verbose --no-repo-update列表内容 pod update若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。 pod search命令格式为： $ pod search 类库名,支持模糊查询(如:AFNetworking) 红框中的信息为AFNetworking 最新版本,Version中显示了历史版本,根据这些信息来编写我们的Podfile文件如: pod ‘AFNetWorking’, ‘~&gt; 2.2.4′ 这句话具体含义是什么呢?当我们通过cocopods引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下 123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本pod ‘AFNetworking’, ‘&gt; 2.0’ //使用高于2.0的版本pod ‘AFNetworking’, ‘&gt;= 2.0’ //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘&lt; 2.0’ //使用小于2.0的版本pod ‘AFNetworking’, ‘&lt;= 2.0’ //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘~&gt; 0.1.2’ //使用大于等于0.1.2但小于0.2的版本pod ‘AFNetworking’, ‘~&gt;0.1’ //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘~&gt;0’ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 pod setup用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。 多个target中使用相同的Pods依赖库比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式： 1234567link_with ‘CocoaPodsTest’, ‘Second’platform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0’ 这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。 不同的target使用完全不同的Pods依赖库CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下： 123456789101112target :’CocoaPodsTest’ doplatform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0′endtarget :’Second’ dopod ‘OpenUDID’, ‘~&gt; 1.0.0’end 其中，do/end作为开始和结束标识符。 Podfile.lock文件在使用CocoaPods，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。该文件用于保存已经安装的Pods依赖库的版本，通过CocoaPods安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为： 123456789101112131415161718192021222324252627282930313233PODS:– AFNetworking (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/NSURLSession– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/UIKit– AFNetworking/NSURLConnection (2.1.0):– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/NSURLSession (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/Reachability (2.1.0)– AFNetworking/Security (2.1.0)– AFNetworking/Serialization (2.1.0)– AFNetworking/UIKit (2.1.0):– AFNetworking/NSURLConnection– Reachability (3.0.0)– SBJson (4.0.0)DEPENDENCIES:– AFNetworking (~&gt; 2.0)– Reachability (~&gt; 3.0.0)– SBJson (~&gt; 4.0.0)SPEC CHECKSUMS:AFNetworking: c7d7901a83f631414c7eda1737261f696101a5cdReachability: 500bd76bf6cd8ff2c6fb715fc5f44ef6e4c024f2SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220COCOAPODS: 0.29.0 Podfile.lock文件最大得用处在于多人开发。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案： 1.更改Podfile，使其指向最新版本的SBJson依赖库； 2.执行pod update命令； 鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。 如何制作自己的Cocopods库在github上新建一个工程 license类型正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。 把项目clone到本地然后在根目录下新建MyPodDemo.podspec 或使用命令 $ pod spec create MyPodDemo Spec文件编写:123456789101112131415161718192021222324Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo."s.description = &lt;&lt;-DESCA longer description of MyPodDemo in Markdown format.* Think: Why did you write this? What is the focus? What does it do?* CocoaPods will be using this to generate tags, and improve search results.* Try to keep it short, snappy and to the point.* Finally, don't worry about the indent, CocoaPods strips it!DESCs.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo/Src", "MyPodDemo/Src/**/*.&#123;h,m&#125;"s.requires_arc = true# s.framework = "SomeFramework"# s.frameworks = "SomeFramework", "AnotherFramework"# s.library = "iconv"# s.libraries = "iconv", "xml2"# s.dependency "JSONKit", "~&gt; 1.4"# s.dependency "AFNetworking", "~&gt; 2.2.4"end 自解析:123456789101112name: 导入pod后的目录名version: 当前版本号deployment_target: 配置的targetprefix_header_file: 预编译头文件路径，将该文件的内容插入到Pod的pch文件内source: 来源的具体路径，是http链接还是本地路径requires_arc: 是否需要arcsource_files: 指定该目录下包含哪些文件其他可选参数还包括：dependency: 指定依赖，如果依赖的库不存在或者依赖库的版本不符合要求将会报错libraries: 指定导入的库，比如sqlite3frameworks: 指定导入的frameworkweak_frameworks: 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。 整个podspec语法是一个嵌套结构从Pod::Spec.new do |s|到最后一个end是最大的循环，表示整个podspec导入的文件。中间每一个subspec到end结束是一个子目录，Pods会为每个subspec创建一个逻辑目录，相当于Xcode的group概念。|**|中间是subspec的名字，可以随便命名，但后面使用的名称必须一致。 通配符说明1234a&#123;bb,bc&#125;def.&#123;h,m&#125;表示四个文件abbdef.h abbdef.m abcdef.h abcdef.m*.&#123;h,m,mm&#125;表示所有的.h .m .mm文件Class/**/*.&#123;h,m&#125;表示Class目录下的所有.h .m文件 写完podspec文件后使用pod spec lint验证spec是否合格,有error则需要修改 上传代码至github上传podspec文件到CocoaPods仓库(fork一下,修改完成后在push上去等待审核) 将我们刚刚生成的MyPodDemo.spec 文件上传到Cocoapods官方specs仓库中 :链接为：https://github.com/CocoaPods/Specs 私有库实现,编写podfile如果由于某些原因我们编写的库不能公开,但是又想使用pods来进行管理,要怎么办呢? 首先我们要将我们刚刚在github上建的仓库改为Private(不然还用Public搞毛啊) 然后修改我们项目的podfile,与已加入Cocopods仓库的公有库相比我们只需要指明私有库低git地址,如下: 123platform :ios, '6.0'pod 'MyPodDemo', :git =&gt; 'https://github.com/goingta/MyPodDemo.git' //私有库pod 'CocoaLumberjack'//公有库 版本控制和冲突(引用自http://objccn.io/issue-6-4/)CocoaPods 使用语义版本控制 – Semantic Versioning 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于2.3.1，另一个依赖于 2.3.3，此时冲突解决系统可以使用最新的版本 2.3.3，因为这个可以向后与 2.3.1 兼容。 但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。 当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 1.2.5，另外一个库则依赖于 2.3.1，那么只有最终用户通过明确指定使用某个版本来解决冲突。 配置非ARC文件前几天项目中由于历史原因,导致有一个私有的pods库中某几个文件是在非ARC时代写的,如果要进行修改工程量浩大,于是乎要对这几个文件单独处理,这几个文件不使用arc其他文件使用arc,网上查了一些资料,只需要对source_file进行修改并排除那几个不使用ARC的文件就可以了,大致修改如下: 123456789101112131415161718Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo.s.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo"non_arc_files = 'MyPodDemo/NoArcFile1.&#123;h,m&#125;','MyPodDemo/NoArcFile2.&#123;h,m&#125;'s.requires_arc = trues.exclude_files = non_arc_filess.subspec 'no-arc' do |sna|sna.requires_arc = falsesna.source_files = non_arc_filesendend 回退Cocoapods历史版本查看当前安装了哪些版本 gem list --local | grep cocoapods 如果你安装了多个版本(如0.35和0.20.2)那么你将看到 123cocoapods (0.34, 0.20.2)cocoapods-core (0.33, 0.20.2)cocoapods-downloader (0.2.0, 0.1.2) 先删除已经装过的版本(可能有几个,卸载的时候会让你输入1,2…n选择卸载那个版本 sudo gem uninstall cocoapods 或者强制卸载某一个版本 gem uninstall cocoapods -v 0.20.2 安装某一个版本 sudo gem install cocoapods -v 0.35.0 处理 Use the $(inherited) flag 异常有时候在pod update之后会遇到下面错误:12Use the `$(inherited)` flag, orRemove the build settings from the target. 虽然对项目编译没什么影响,但是看着还是挺不舒服的.解决办法就是 找到工程的 targets 点击工程名 Build Settings -&gt; Other linker flags -&gt; 添加 $(inherited)]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导航栏取消View的渗透]]></title>
    <url>%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%8F%96%E6%B6%88View%E7%9A%84%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[12345678910- (void)initializeSelfVCSetting &#123; if ([self respondsToSelector:@selector(setAutomaticallyAdjustsScrollViewInsets:)]) &#123; [self setAutomaticallyAdjustsScrollViewInsets:NO]; &#125; if ([self respondsToSelector:@selector(setEdgesForExtendedLayout:)]) &#123; self.edgesForExtendedLayout=UIRectEdgeNone; &#125;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
</search>
