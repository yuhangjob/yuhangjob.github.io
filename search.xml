<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[code-push和code-push-server热更新上传到七牛云及阿里云]]></title>
    <url>%2Fcode-push%E5%92%8Ccode-push-server%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[一、自建 CodePush 服务CodePush 服务主要分为三个部分：服务端、客户端、React Native 项目。 服务端服务端需要使用 code-push-server 和MySQL 所以需要先将这两个安装好。 1.安装MySQL官网下载后直接双击安装，下载地址；打开“系统设置”，看到最新安装的MySQL，进入并启动服务。 2.安装 code-push-server 作者发布了两种安装方式（npm安装或源码安装），在此我推荐使用源码安装，为后期我们要基于这个服务修改自己的网页，源码安装方便些。 (1)、下载code-push-server代码1234// clone代码git clone https://github.com/lisong/code-push-server.git// 进入项目并安装资源cd code-push-server &amp;&amp; npm install (2)、修改config/config.js 文件，在 db 对象中添加数据库信息，参考如下：12345678910db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, (3)、创建数据库表1./bin/db init --dbhost localhost --dbuser root --dbpassword admin123 --dbname codepush 为了演示我重新创建一个 (4)、配置打包后的，bundle存储地址，这里配置loal本地也可以配置qiniu和OSS创建storage和data文件夹，用来保存打包好的资源，供用户更新下载，downloadUrl地址必须为服务器所在的地址，不然用户无法下载到包。主要配置如下： 七牛对象储存地址 123456qiniu: &#123; accessKey: "", //个人面板 &gt; 秘钥管理 &gt; AK secretKey: "", //个人面板 &gt; 秘钥管理 &gt; SK bucketName: "faweapp",//储存空间名称 downloadUrl: "http://babi.lhsea.com" //绑定的域名 &#125;, 阿里云对象储存 12345678oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo",//储存空间名称 prefix: "storage", // 目录文件夹名称 downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", //下载地址 &#125;, config.js文件路径：code-push-server/config/config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var os = require('os');var config = &#123;&#125;;config.development = &#123; // Config for database, only support mysql. db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, // Config for qiniu (http://www.qiniu.com/) cloud storage when storageType value is "qiniu". qiniu: &#123; accessKey: "", secretKey: "", bucketName: "faweapp", downloadUrl: "http://babi.lhsea.com" // Binary files download host address.http://pby2wik41.bkt.clouddn.com/Fi_BSD0I9yokJRdors-4LsZucE4_ &#125;, // Config for Amazon s3 (https://aws.amazon.com/cn/s3/) storage when storageType value is "s3". s3: &#123; accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY, sessionToken: process.env.AWS_SESSION_TOKEN, //(optional) bucketName: process.env.BUCKET_NAME, region: process.env.REGION, downloadUrl: process.env.DOWNLOAD_URL, // binary files download host address. &#125;, // Config for Aliyun OSS (https://www.aliyun.com/product/oss) when storageType value is "oss". oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo", prefix: "storage", // Key prefix in object key downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", // binary files download host address. &#125;, // Config for tencentyun COS (https://cloud.tencent.com/product/cos) when storageType value is "oss". tencentcloud: &#123; accessKeyId: "", secretAccessKey: "", bucketName: "", region: "", downloadUrl: "", // binary files download host address. &#125;, // Config for local storage when storageType value is "local". local: &#123; // Binary files storage dir, Do not use tmpdir and it's public download dir. storageDir: process.env.STORAGE_DIR || "/Users/mac/Desktop/workspaces/storage", //文件下载地址 CodePush Server 地址 + '/download' download对应app.js里面的地址 downloadUrl: process.env.LOCAL_DOWNLOAD_URL || "http://localhost:3000/download",//注意此地方是否是你的本机ip地址(如果是模拟器的话，无须更改） // public static download spacename. public: '/download' &#125;, jwt: &#123; // Recommended: 63 random alpha-numeric characters // Generate using: https://www.grc.com/passwords.htm tokenSecret: process.env.TOKEN_SECRET ||'fnoQkK2w9zEp2Sj03lYaGCkWDgkVEvaTqrYPxbaZvq2MM3ivnXKNMLzrn96MTmn' &#125;, common: &#123; /* * tryLoginTimes is control login error times to avoid force attack. * if value is 0, no limit for login auth, it may not safe for account. when it's a number, it means you can * try that times today. but it need config redis server. */ tryLoginTimes: 0, // CodePush Web(https://github.com/lisong/code-push-web) login address. //codePushWebUrl: "http://127.0.0.1:3001/login", // create patch updates's number. default value is 3 diffNums: 3, // data dir for caclulate diff files. it's optimization. dataDir: process.env.DATA_DIR || "/Users/mac/Desktop/workspaces/data", // storageType which is your binary package files store. options value is ("local" | "qiniu" | "s3"| "oss" || "tencentcloud") //选择存储类型，目前支持local,oss,qiniu,s3配置 storageType: process.env.STORAGE_TYPE || "qiniu", // options value is (true | false), when it's true, it will cache updateCheck results in redis. updateCheckCache: false, // options value is (true | false), when it's true, it will cache rollout results in redis rolloutClientUniqueIdCache: false, &#125;, (5)、改好之后，启动服务1./bin/www 在浏览其中输入：http://127.0.0.1:3000 能加载到CodePushServer登录界面即表示启动成功。点击登录，输入用户名：admin和密码：123456点击登录，然后点击获取token： (6)、进入项目根目录1cd /Users/mac/Desktop/RNCPProject (7)、登入1code-push login http://127.0.0.1:3000 会自动打开浏览器登录,获取token,把获取到的token粘贴过来, 回车 查看 1whoami (8)、添加一个应用123testApp //应用名称code-push app add testApp ios react-nativecode-push app add testApp android react-native (9)、配置Xcode info.plist 把我们获取的Staging对应的CodePushDeploymentKey填到上面就行了。 (10)、运行Xcode 启动项目以更改导航标题为示例 (11)、更改项目执行123456789101112code-push release-react testApp ios//发布命令（打包文件并上传到服务器）$ code-push release-react &lt;appName&gt; &lt;OS&gt; &lt;updateContents&gt; &lt;deploymentNmae&gt; &lt;description&gt; &lt;disabled&gt; &lt;mandatory&gt;&lt;appName&gt; //必须 app名称&lt;OS&gt; //必须 发布平台iOS/Android&lt;updateContents&gt; //非必须 Bundle文件所在目录&lt;targetBinaryVersion&gt; //非必须 需要热更的app 版本&lt;deploymentNmae&gt; //必须 需要发布的部署&lt;description&gt; //非必须 描述 (更新客户端不可见必须有"hide" eg: --description "hide xxxx")&lt;disabled&gt; //非必须 该版本客户端是否可以获得更新,默认为false&lt;mandatory&gt; //非必须 如果有则表示app强制更新 1234567//查看历史版本code-push deployment history &lt;应用名&gt; Staging/Productioncode-push deployment history testApp Staging//清空历史版本code-push deployment clear testApp Staging//查看keycode-push deployment ls testApp -k 二、集成CodePush SDKAndroid下面我们通过如下步骤在Android项目中集成CodePush。 第一步：在项目中安装 react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步：在Android project中安装插件。CodePush提供了两种方式：RNPM 和 Manual，本次演示所使用的是RNPM。运行npm i -g rnpm，来安装RNPM。 在React Native v0.27及以后版本RNPM已经被集成到了 React Native CL中，就不需要再进行安装了 第三步： 运行 rnpm link react-native-code-push。这条命令将会自动帮我们在anroid文件中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 第四步： 在 android/app/build.gradle文件里面添如下代码：1apply from: "../../node_modules/react-native-code-push/android/codepush.gradle" 然后在/android/settings.gradle中添加如下代码: 12include ':react-native-code-push'project(':react-native-code-push').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app') 第五步: 运行code-push deployment -k ls &lt;appName&gt;获取 部署秘钥。默认的部署名是 staging，所以 部署秘钥（deployment key ） 就是 staging。第六步： 添加配置。当APP启动时我们需要让app向CodePush咨询JS bundle的所在位置，这样CodePush就可以控制版本。更新 MainApplication.java文件：1234567891011121314151617181920212223242526public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected String getJSBundleFile() &#123; return CodePush.getJSBundleFile(); &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; // 3. Instantiate an instance of the CodePush runtime and add it to the list of // existing packages, specifying the right deployment key. If you don't already // have it, you can run "code-push deployment ls &lt;appName&gt; -k" to retrieve your key. return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush("deployment-key-here", MainApplication.this, BuildConfig.DEBUG) ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125;&#125; 关于deployment-key的设置 在上述代码中我们在创建CodePush实例的时候需要设置一个deployment-key,因为deployment-key分生产环境与测试环境两种,所以建议大家在build.gradle中进行设置。在build.gradle中的设置方法如下: 打开android/app/build.gradle文件,找到android { buildTypes {} }然后添加如下代码即可: 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_STAGING_KEY&gt;"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_PRODUCTION_KEY&gt;"' ... &#125; &#125; ...&#125; 心得:另外,我们也可以将deployment-key存放在local.properties中: 12code_push_key_production=erASzHa1-wTdODdPJDh6DBF2Jwo94JFH08Kvbcode_push_key_staging=mQY75RkFbX6SiZU1kVT1II7OqWst4JFH08Kvb 如图: 然后在就可以在android/app/build.gradle可以通过下面方式来引用它了: 12345678910111213141516171819202122232425Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_production")+'"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_staging")+'"' ... &#125; &#125; ...&#125; 在android/app/build.gradle设置好deployment-key之后呢,我们就可以这样使用了: 12345678@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( ... new CodePush(BuildConfig.CODEPUSH_KEY, MainApplication.this, BuildConfig.DEBUG), // Add/change this line. ... );&#125; 第七步：修改versionName。在 android/app/build.gradle中有个android.defaultConfig.versionName属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。 12345android&#123; defaultConfig&#123; versionName "1.0.0" &#125;&#125; 至此Code Push for Android的SDK已经集成完成。 iOSCodePush官方提供RNPM、CocoaPods与手动三种在iOS项目中集成CodePush的方式，接下来我就以RNPM的方式来讲解一下如何在iOS项目中集成CodePush。 第一步：在项目中安装react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步： 运行rnpm link react-native-code-push。这条命令将会自动帮我们在ios中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 关于deployment-key的设置在我们想CodePush注册App的时候，CodePush会给我们两个deployment-key分别是在生产环境与测试环境时使用的，我们可以通过如下步骤来设置deployment-key。 1.用Xcode 打开项目 ➜ Xcode的项目导航视图中的PROJECT下选择你的项目 ➜ 选择Info页签 ➜ 在Configurations节点下单击 + 按钮 ➜ 选择Duplicate &quot;Release ➜ 输入Staging(名称可以自定义)； 2.然后选择Build Settings页签 ➜ 单击 + 按钮然后选择添加User-Defined Setting 3.然后输入CODEPUSH_KEY(名称可以自定义) 提示：你可以通过code-push deployment ls &lt;APP_NAME&gt; -k命令来查看deployment key。 4.打开 Info.plist文件，在CodePushDeploymentKey列的Value中输入$(CODEPUSH_KEY) 参考: https://www.jianshu.com/p/ca4beb5973bb https://www.jianshu.com/p/417a165ca9d7 React Native应用部署/热更新-CodePush最新集成总结(新)]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类似网易新闻的滑动菜单]]></title>
    <url>%2FSwift-%E7%B1%BB%E4%BC%BC%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E7%9A%84%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[简单实现类似这种的 滑动菜单 新手Swift新手 大神就别看了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import UIKitclass HomeViewController: UIViewController,UICollectionViewDelegate,UICollectionViewDataSource,UIScrollViewDelegate &#123; let WIDTH = UIScreen.mainScreen().bounds.width / 375 let HEIGTH = UIScreen.mainScreen().bounds.height / 667 let SCREENWIDTH = UIScreen.mainScreen().bounds.width let SCREENHEIGTH = UIScreen.mainScreen().bounds.height var collectionView: UICollectionView! var buttonsArray: NSMutableArray! var titlesArray: NSMutableArray! var lineView: UIView! override func viewDidLoad() &#123; super.viewDidLoad() self.automaticallyAdjustsScrollViewInsets = false self.navigationController?.automaticallyAdjustsScrollViewInsets = false self.initButtons() self.initCollectionView() &#125; func initButtons() &#123; buttonsArray = NSMutableArray() titlesArray = ["分类","品牌","首页","专题","品牌"] for var i = 0;i&lt;titlesArray.count;i++ &#123; let button = UIButton.init(type: .System) button.frame = CGRectMake(SCREENWIDTH * CGFloat (i) / 5.0, 0, SCREENWIDTH / 5.0, 40 * HEIGTH) button.tag = i button.backgroundColor = UIColor.blackColor() button.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) if i == 2 &#123; button.titleLabel?.font = UIFont.systemFontOfSize(16.0 * WIDTH) button.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; button.titleLabel?.font = UIFont.systemFontOfSize(15.0 * WIDTH) button.setTitle(titlesArray[i] as? String, forState: .Normal) button.addTarget(self, action: "click:", forControlEvents: .TouchUpInside) self.view.addSubview(button) buttonsArray.addObject(button) &#125; lineView = UIView.init(frame: CGRectMake(15 * WIDTH + (SCREENWIDTH / 5.0) * 2, 38 * HEIGTH, SCREENWIDTH / 5.0 - 30 * WIDTH, 2 * HEIGTH)) lineView.backgroundColor = UIColor.whiteColor() self.view.addSubview(lineView) &#125; func click (btn: UIButton) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; btn.titleLabel?.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) self.collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forItem: btn.tag, inSection: 0), atScrollPosition: .None, animated: true) UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (btn.tag), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125;) &#123;(Bool) -&gt; Void in &#125; &#125; func initCollectionView() &#123; let flowLayout = UICollectionViewFlowLayout() flowLayout.scrollDirection = .Horizontal flowLayout.itemSize = CGSizeMake(UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH) flowLayout.minimumLineSpacing = 0 flowLayout.minimumInteritemSpacing = 0 collectionView = UICollectionView.init(frame: CGRectMake(0, 40 * HEIGTH, UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH), collectionViewLayout: flowLayout) collectionView.delegate = self collectionView.dataSource = self collectionView.pagingEnabled = true collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forRow: 2, inSection: 0), atScrollPosition: .None, animated: true) self.view.addSubview(collectionView) collectionView.registerClass(HomeCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "hCell") collectionView.registerClass(KindCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "kCell") collectionView.registerClass(BrandCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "bCell") collectionView.registerClass(SubjectCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "sCell") collectionView.registerClass(GiftCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "gCell") &#125; func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 5 &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; if indexPath.item == 0 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("kCell", forIndexPath: indexPath) as! KindCollectionViewCell weak var weakSelf = self cell.initClosure(&#123; (str) -&gt; Void? in // let url = "http://mobile.iliangcang.com/goods/goodsShare?a=b&amp;page=1&amp;count=10&amp;coverId=1&amp;cat_code=$&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" let common = CommonViewController()// common.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: str) common.urlStr = str common.hidesBottomBarWhenPushed = true weakSelf!.navigationController?.pushViewController(common, animated: true) return nil &#125;) return cell &#125;else if indexPath.item == 1 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("bCell", forIndexPath: indexPath) as! BrandCollectionViewCell return cell &#125;else if indexPath.item == 2 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("hCell", forIndexPath: indexPath) as! HomeCollectionViewCell cell.myClosure = &#123; (content_id: String) -&gt; Void in let shopVC = ShopViewController() let url = "http://mobile.iliangcang.com/goods/goodsList?a=b&amp;list_id=$&amp;count=10&amp;page=1&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" shopVC.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: content_id) self.navigationController?.pushViewController(shopVC, animated: true) &#125; return cell &#125;else if indexPath.item == 3 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("sCell", forIndexPath: indexPath) as! SubjectCollectionViewCell return cell &#125;else &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("gCell", forIndexPath: indexPath) as! GiftCollectionViewCell return cell &#125; &#125; func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; UIView.animateWithDuration(0.3) &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (self.collectionView.contentOffset.x / (UIScreen.mainScreen().bounds.width)), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125; let btn = buttonsArray.objectAtIndex(Int(self.collectionView.contentOffset.x / UIScreen.mainScreen().bounds.width)) btn.titleLabel?!.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift tableViewCell 高度自适应]]></title>
    <url>%2FSwift-tableViewCell-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[1234567891011 static func cellhight (content: String) -&gt; CGFloat &#123; let rect: CGRect = content.boundingRectWithSize( CGSizeMake(SCREENWIDTH - 20, 0), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName: UIFont.systemFontOfSize(14)], context: nil) return rect.height + 61 &#125; 在返回cell 的高度的方法中直接调用return TableViewCell.cellhight(“这里面填想要自适应的文字”)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS视频图片压缩上传]]></title>
    <url>%2FiOS-%E8%A7%86%E9%A2%91%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[iOS视频图片压缩上传 上传方法: iOS-AFNetworking-3-0-上传图片视频到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 获取当前时间- (NSString *)getCurrentTime&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSString *dateTime = [formatter stringFromDate:[NSDate date]];// NSString *str = [NSString stringWithFormat:@"%@mdxx",dateTime];// NSString *tokenStr = [str stringToMD5:str]; return dateTime; &#125;#pragma mark - 视频压缩/** * 视频压缩 * * @param url 视频文件的url * * @return 压缩后的url */ - (NSURL *)condenseVideoNewUrl: (NSURL *)url&#123; // 沙盒目录 NSString *docuPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *destFilePath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyh%@.MOV",[self getCurrentTime]]]; NSURL *destUrl = [NSURL fileURLWithPath:destFilePath]; //将视频文件copy到沙盒目录中 NSFileManager *manager = [NSFileManager defaultManager]; NSError *error = nil; [manager copyItemAtURL:url toURL:destUrl error:&amp;error]; NSLog(@"压缩前--%.2fk",[self getFileSize:destFilePath]); // 播放视频 /* NSURL *videoURL = [NSURL fileURLWithPath:destFilePath]; AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.view.bounds; [self.view.layer addSublayer:playerLayer]; [player play]; */ // 进行压缩 AVAsset *asset = [AVAsset assetWithURL:destUrl]; //创建视频资源导出会话 /** NSString *const AVAssetExportPresetLowQuality; // 低质量 NSString *const AVAssetExportPresetMediumQuality; NSString *const AVAssetExportPresetHighestQuality; //高质量 */ AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:asset presetName:AVAssetExportPresetLowQuality]; // 创建导出的url NSString *resultPath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyhg%@.MOV",[self getCurrentTime]]]; session.outputURL = [NSURL fileURLWithPath:resultPath]; // 必须配置输出属性 session.outputFileType = @"com.apple.quicktime-movie"; // 导出视频 [session exportAsynchronouslyWithCompletionHandler:^&#123; NSLog(@"压缩后---%.2fk",[self getFileSize:resultPath]); NSLog(@"视频导出完成"); &#125;]; return session.outputURL;&#125;// 获取视频的大小- (CGFloat) getFileSize:(NSString *)path&#123; NSFileManager *fileManager = [[NSFileManager alloc] init] ; float filesize = -1.0; if ([fileManager fileExistsAtPath:path]) &#123; NSDictionary *fileDic = [fileManager attributesOfItemAtPath:path error:nil];//获取文件的属性 unsigned long long size = [[fileDic objectForKey:NSFileSize] longLongValue]; filesize = 1.0*size/1024; &#125; return filesize;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma mark - Picker delgate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info &#123; NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) &#123; NSLog(@"选取的是照片"); // self.imageView.image = info[UIImagePickerControllerEditedImage]; // 压缩图片 NSData *fileData = UIImageJPEGRepresentation(info[UIImagePickerControllerEditedImage], 0.5); //保存到Documents NSString *imageStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *imageFile = [imageStr stringByAppendingPathComponent:@"image.jpg"]; NSLog(@"%@",imageFile); [fileData writeToFile:imageFile atomically:YES]; //保存至相册 UIImageWriteToSavedPhotosAlbum(info[UIImagePickerControllerEditedImage], self, @selector(image:didFinishSavingWithError:contextInfo:), nil); // 上传图片 NSDictionary *dict = @&#123;@"mem_id":@"600209"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:fileData name:@"photo" fileName:@"abc.jpg" mimeType:@"image/jpeg" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"success:%@ %@",responseObject, [responseObject objectForKey:@"msg"]); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125;else&#123; // 如果是视频 NSURL *url = info[UIImagePickerControllerMediaURL]; // 获取视频总时长 CGFloat lengthTime = [self getVideoLength:url]; NSLog(@"%f",lengthTime); // 保存视频至相册 (异步线程) NSString *urlStr = [url path]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(urlStr)) &#123; UISaveVideoAtPathToSavedPhotosAlbum(urlStr, self, @selector(video:didFinishSavingWithError:contextInfo:), nil); &#125; &#125;); //压缩视频 NSData *videoData = [NSData dataWithContentsOfURL:[self condenseVideoNewUrl:url]]; //视频上传 if (lengthTime &gt;10.0f) &#123; NSLog(@"文件过大只允许上传10s视频"); &#125;else &#123; NSDictionary *dict = @&#123;@"username":@"syl"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:videoData name:@"file" fileName:@"video.mov" mimeType:@"video/quicktime" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"上传成功%@",responseObject); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125;// 获取视频时间- (CGFloat) getVideoLength:(NSURL *)URL&#123; AVURLAsset *avUrl = [AVURLAsset assetWithURL:URL]; CMTime time = [avUrl duration]; int second = ceil(time.value/time.timescale); return second;&#125;#pragma mark 图片保存完毕的回调- (void) image: (UIImage *) image didFinishSavingWithError:(NSError *) error contextInfo: (void *)contextIn &#123; NSLog(@"照片保存成功");&#125;#pragma mark 视频保存完毕的回调- (void)video:(NSString *)videoPath didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextIn &#123; if (error) &#123; NSLog(@"保存视频过程中发生错误，错误信息:%@",error.localizedDescription); &#125;else&#123; NSLog(@"视频保存成功."); &#125;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS AFNetworking 3.0 上传图片视频到服务器]]></title>
    <url>%2FiOS-AFNetworking-3-0-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于AFNetworking 3.0图片上传的封装 .h1234567891011typedef NS_ENUM(NSUInteger, ResposeStyle) &#123; JSON, XML, Data,&#125;;typedef NS_ENUM(NSUInteger, RequestStyle) &#123; RequestJSON, RequestString, RequestDefault&#125;; .m @param url 服务器地址 @param parameters 字典 token @param fileData 要上传的数据 @param name 服务器参数名称 后台给你 @param fileName 文件名称 图片:xxx.jpg,xxx.png 视频:video.mov @param mimeType 文件类型 图片:image/jpg,image/png 视频:video/quicktime @param style 返回的数据类型 @param progress @param success @param failure 123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (void)upLoadToUrlString:(NSString *)url parameters:(NSDictionary *)parameters fileData:(NSData *)fileData name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType response:(ResposeStyle)style progress:(void (^)(NSProgress *))progress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123; //1.获取单例的网络管理对象 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.根据style 的类型 去选择返回值得类型 switch (style) &#123; case JSON: manager.responseSerializer = [AFJSONResponseSerializer serializer]; break; case XML: manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; break; case Data: manager.responseSerializer = [AFHTTPResponseSerializer serializer]; break; default: break; &#125; //3.设置相应数据支持的类型 [manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript",@"text/html",@"text/css",@"text/plain", @"application/javascript",@"application/json", @"application/x-www-form-urlencoded", nil]]; [manager POST:url parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; [formData appendPartWithFileData:fileData name:name fileName:fileName mimeType:mimeType]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(task, responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(task, error); &#125; &#125;];&#125; PS:上传图片前，必须先压缩图片，不然图片过大，可能会导致上传失败！ 具体上传操作:iOS-视频图片压缩上传]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView添加类似微信的进度条]]></title>
    <url>%2FiOS-WKWebView%E6%B7%BB%E5%8A%A0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[WKWebView添加类似微信的进度条 1.m中声明两个属性@property (nonatomic, strong) WKWebView *wkWebView;@property (nonatomic, strong) UIProgressView *progressView;@property (nonatomic, assign) NSUInteger loadCount; 2.初始化方法…省略 3.添加KVO12通过监听estimatedProgress可以获取它的加载进度 还可以监听它的title ,URL, loading[wkWebView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:nil]; 4.计算进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@"loading"]) &#123; &#125; else if ([keyPath isEqualToString:@"title"]) &#123; self.title = self.wKWebView.title; &#125; else if ([keyPath isEqualToString:@"URL"]) &#123; &#125; else if ([keyPath isEqualToString:@"estimatedProgress"]) &#123; self.progressView.progress = self.wKWebView.estimatedProgress; &#125; if (object == self.wKWebView &amp;&amp; [keyPath isEqualToString:@"estimatedProgress"]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; if (newprogress == 1) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; [self.progressView setProgress:newprogress animated:YES]; &#125; &#125;&#125; - (void)setLoadCount:(NSUInteger)loadCount &#123; _loadCount = loadCount; if (loadCount == 0) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; CGFloat oldP = self.progressView.progress; CGFloat newP = (1.0 - oldP) / (loadCount + 1) + oldP; if (newP &gt; 0.95) &#123; newP = 0.95; &#125; [self.progressView setProgress:newP animated:YES]; &#125;&#125;// 页面开始加载时调用 - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123; self.loadCount ++;&#125;// 内容返回时 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123; self.loadCount --; &#125;//失败 - (void)webView:(WKWebView *)webView didFailNavigation: (null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123; self.loadCount --; NSLog(@"%@",error);&#125; 最后别忘记在dealloc 中取消监听]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
</search>
