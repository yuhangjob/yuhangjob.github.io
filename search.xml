<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[code-push和code-push-server热更新上传到七牛云及阿里云]]></title>
    <url>%2Fcode-push%E5%92%8Ccode-push-server%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[一、自建 CodePush 服务CodePush 服务主要分为三个部分：服务端、客户端、React Native 项目。 服务端服务端需要使用 code-push-server 和MySQL 所以需要先将这两个安装好。 1.安装MySQL官网下载后直接双击安装，下载地址；打开“系统设置”，看到最新安装的MySQL，进入并启动服务。 2.安装 code-push-server 作者发布了两种安装方式（npm安装或源码安装），在此我推荐使用源码安装，为后期我们要基于这个服务修改自己的网页，源码安装方便些。 (1)、下载code-push-server代码1234// clone代码git clone https://github.com/lisong/code-push-server.git// 进入项目并安装资源cd code-push-server &amp;&amp; npm install (2)、修改config/config.js 文件，在 db 对象中添加数据库信息，参考如下：12345678910db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, (3)、创建数据库表1./bin/db init --dbhost localhost --dbuser root --dbpassword admin123 --dbname codepush 为了演示我重新创建一个 (4)、配置打包后的，bundle存储地址，这里配置loal本地也可以配置qiniu和OSS创建storage和data文件夹，用来保存打包好的资源，供用户更新下载，downloadUrl地址必须为服务器所在的地址，不然用户无法下载到包。主要配置如下： 七牛对象储存地址 123456qiniu: &#123; accessKey: "", //个人面板 &gt; 秘钥管理 &gt; AK secretKey: "", //个人面板 &gt; 秘钥管理 &gt; SK bucketName: "faweapp",//储存空间名称 downloadUrl: "http://babi.lhsea.com" //绑定的域名 &#125;, 阿里云对象储存 12345678oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo",//储存空间名称 prefix: "storage", // 目录文件夹名称 downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", //下载地址 &#125;, config.js文件路径：code-push-server/config/config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var os = require('os');var config = &#123;&#125;;config.development = &#123; // Config for database, only support mysql. db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, // Config for qiniu (http://www.qiniu.com/) cloud storage when storageType value is "qiniu". qiniu: &#123; accessKey: "", secretKey: "", bucketName: "faweapp", downloadUrl: "http://babi.lhsea.com" // Binary files download host address.http://pby2wik41.bkt.clouddn.com/Fi_BSD0I9yokJRdors-4LsZucE4_ &#125;, // Config for Amazon s3 (https://aws.amazon.com/cn/s3/) storage when storageType value is "s3". s3: &#123; accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY, sessionToken: process.env.AWS_SESSION_TOKEN, //(optional) bucketName: process.env.BUCKET_NAME, region: process.env.REGION, downloadUrl: process.env.DOWNLOAD_URL, // binary files download host address. &#125;, // Config for Aliyun OSS (https://www.aliyun.com/product/oss) when storageType value is "oss". oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo", prefix: "storage", // Key prefix in object key downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", // binary files download host address. &#125;, // Config for tencentyun COS (https://cloud.tencent.com/product/cos) when storageType value is "oss". tencentcloud: &#123; accessKeyId: "", secretAccessKey: "", bucketName: "", region: "", downloadUrl: "", // binary files download host address. &#125;, // Config for local storage when storageType value is "local". local: &#123; // Binary files storage dir, Do not use tmpdir and it's public download dir. storageDir: process.env.STORAGE_DIR || "/Users/mac/Desktop/workspaces/storage", //文件下载地址 CodePush Server 地址 + '/download' download对应app.js里面的地址 downloadUrl: process.env.LOCAL_DOWNLOAD_URL || "http://localhost:3000/download",//注意此地方是否是你的本机ip地址(如果是模拟器的话，无须更改） // public static download spacename. public: '/download' &#125;, jwt: &#123; // Recommended: 63 random alpha-numeric characters // Generate using: https://www.grc.com/passwords.htm tokenSecret: process.env.TOKEN_SECRET ||'fnoQkK2w9zEp2Sj03lYaGCkWDgkVEvaTqrYPxbaZvq2MM3ivnXKNMLzrn96MTmn' &#125;, common: &#123; /* * tryLoginTimes is control login error times to avoid force attack. * if value is 0, no limit for login auth, it may not safe for account. when it's a number, it means you can * try that times today. but it need config redis server. */ tryLoginTimes: 0, // CodePush Web(https://github.com/lisong/code-push-web) login address. //codePushWebUrl: "http://127.0.0.1:3001/login", // create patch updates's number. default value is 3 diffNums: 3, // data dir for caclulate diff files. it's optimization. dataDir: process.env.DATA_DIR || "/Users/mac/Desktop/workspaces/data", // storageType which is your binary package files store. options value is ("local" | "qiniu" | "s3"| "oss" || "tencentcloud") //选择存储类型，目前支持local,oss,qiniu,s3配置 storageType: process.env.STORAGE_TYPE || "qiniu", // options value is (true | false), when it's true, it will cache updateCheck results in redis. updateCheckCache: false, // options value is (true | false), when it's true, it will cache rollout results in redis rolloutClientUniqueIdCache: false, &#125;, (5)、改好之后，启动服务1./bin/www 在浏览其中输入：http://127.0.0.1:3000 能加载到CodePushServer登录界面即表示启动成功。点击登录，输入用户名：admin和密码：123456点击登录，然后点击获取token： (6)、进入项目根目录1cd /Users/mac/Desktop/RNCPProject (7)、登入1code-push login http://127.0.0.1:3000 会自动打开浏览器登录,获取token,把获取到的token粘贴过来, 回车 查看 1whoami (8)、添加一个应用123testApp //应用名称code-push app add testApp ios react-nativecode-push app add testApp android react-native (9)、配置Xcode info.plist 把我们获取的Staging对应的CodePushDeploymentKey填到上面就行了。 (10)、运行Xcode 启动项目以更改导航标题为示例 (11)、更改项目执行123456789101112code-push release-react testApp ios//发布命令（打包文件并上传到服务器）$ code-push release-react &lt;appName&gt; &lt;OS&gt; &lt;updateContents&gt; &lt;deploymentNmae&gt; &lt;description&gt; &lt;disabled&gt; &lt;mandatory&gt;&lt;appName&gt; //必须 app名称&lt;OS&gt; //必须 发布平台iOS/Android&lt;updateContents&gt; //非必须 Bundle文件所在目录&lt;targetBinaryVersion&gt; //非必须 需要热更的app 版本&lt;deploymentNmae&gt; //必须 需要发布的部署&lt;description&gt; //非必须 描述 (更新客户端不可见必须有"hide" eg: --description "hide xxxx")&lt;disabled&gt; //非必须 该版本客户端是否可以获得更新,默认为false&lt;mandatory&gt; //非必须 如果有则表示app强制更新 1234567//查看历史版本code-push deployment history &lt;应用名&gt; Staging/Productioncode-push deployment history testApp Staging//清空历史版本code-push deployment clear testApp Staging//查看keycode-push deployment ls testApp -k 二、集成CodePush SDKAndroid下面我们通过如下步骤在Android项目中集成CodePush。 第一步：在项目中安装 react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步：在Android project中安装插件。CodePush提供了两种方式：RNPM 和 Manual，本次演示所使用的是RNPM。运行npm i -g rnpm，来安装RNPM。 在React Native v0.27及以后版本RNPM已经被集成到了 React Native CL中，就不需要再进行安装了 第三步： 运行 rnpm link react-native-code-push。这条命令将会自动帮我们在anroid文件中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 第四步： 在 android/app/build.gradle文件里面添如下代码：1apply from: "../../node_modules/react-native-code-push/android/codepush.gradle" 然后在/android/settings.gradle中添加如下代码: 12include ':react-native-code-push'project(':react-native-code-push').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app') 第五步: 运行code-push deployment -k ls &lt;appName&gt;获取 部署秘钥。默认的部署名是 staging，所以 部署秘钥（deployment key ） 就是 staging。第六步： 添加配置。当APP启动时我们需要让app向CodePush咨询JS bundle的所在位置，这样CodePush就可以控制版本。更新 MainApplication.java文件：1234567891011121314151617181920212223242526public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected String getJSBundleFile() &#123; return CodePush.getJSBundleFile(); &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; // 3. Instantiate an instance of the CodePush runtime and add it to the list of // existing packages, specifying the right deployment key. If you don't already // have it, you can run "code-push deployment ls &lt;appName&gt; -k" to retrieve your key. return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush("deployment-key-here", MainApplication.this, BuildConfig.DEBUG) ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125;&#125; 关于deployment-key的设置 在上述代码中我们在创建CodePush实例的时候需要设置一个deployment-key,因为deployment-key分生产环境与测试环境两种,所以建议大家在build.gradle中进行设置。在build.gradle中的设置方法如下: 打开android/app/build.gradle文件,找到android { buildTypes {} }然后添加如下代码即可: 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_STAGING_KEY&gt;"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_PRODUCTION_KEY&gt;"' ... &#125; &#125; ...&#125; 心得:另外,我们也可以将deployment-key存放在local.properties中: 12code_push_key_production=erASzHa1-wTdODdPJDh6DBF2Jwo94JFH08Kvbcode_push_key_staging=mQY75RkFbX6SiZU1kVT1II7OqWst4JFH08Kvb 如图: 然后在就可以在android/app/build.gradle可以通过下面方式来引用它了: 12345678910111213141516171819202122232425Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_production")+'"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_staging")+'"' ... &#125; &#125; ...&#125; 在android/app/build.gradle设置好deployment-key之后呢,我们就可以这样使用了: 12345678@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( ... new CodePush(BuildConfig.CODEPUSH_KEY, MainApplication.this, BuildConfig.DEBUG), // Add/change this line. ... );&#125; 第七步：修改versionName。在 android/app/build.gradle中有个android.defaultConfig.versionName属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。 12345android&#123; defaultConfig&#123; versionName "1.0.0" &#125;&#125; 至此Code Push for Android的SDK已经集成完成。 iOSCodePush官方提供RNPM、CocoaPods与手动三种在iOS项目中集成CodePush的方式，接下来我就以RNPM的方式来讲解一下如何在iOS项目中集成CodePush。 第一步：在项目中安装react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步： 运行rnpm link react-native-code-push。这条命令将会自动帮我们在ios中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 关于deployment-key的设置在我们想CodePush注册App的时候，CodePush会给我们两个deployment-key分别是在生产环境与测试环境时使用的，我们可以通过如下步骤来设置deployment-key。 1.用Xcode 打开项目 ➜ Xcode的项目导航视图中的PROJECT下选择你的项目 ➜ 选择Info页签 ➜ 在Configurations节点下单击 + 按钮 ➜ 选择Duplicate &quot;Release ➜ 输入Staging(名称可以自定义)； 2.然后选择Build Settings页签 ➜ 单击 + 按钮然后选择添加User-Defined Setting 3.然后输入CODEPUSH_KEY(名称可以自定义) 提示：你可以通过code-push deployment ls &lt;APP_NAME&gt; -k命令来查看deployment key。 4.打开 Info.plist文件，在CodePushDeploymentKey列的Value中输入$(CODEPUSH_KEY) 参考: https://www.jianshu.com/p/ca4beb5973bb https://www.jianshu.com/p/417a165ca9d7 React Native应用部署/热更新-CodePush最新集成总结(新)]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类似网易新闻的滑动菜单]]></title>
    <url>%2FSwift-%E7%B1%BB%E4%BC%BC%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E7%9A%84%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[简单实现类似这种的 滑动菜单 新手Swift新手 大神就别看了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import UIKitclass HomeViewController: UIViewController,UICollectionViewDelegate,UICollectionViewDataSource,UIScrollViewDelegate &#123; let WIDTH = UIScreen.mainScreen().bounds.width / 375 let HEIGTH = UIScreen.mainScreen().bounds.height / 667 let SCREENWIDTH = UIScreen.mainScreen().bounds.width let SCREENHEIGTH = UIScreen.mainScreen().bounds.height var collectionView: UICollectionView! var buttonsArray: NSMutableArray! var titlesArray: NSMutableArray! var lineView: UIView! override func viewDidLoad() &#123; super.viewDidLoad() self.automaticallyAdjustsScrollViewInsets = false self.navigationController?.automaticallyAdjustsScrollViewInsets = false self.initButtons() self.initCollectionView() &#125; func initButtons() &#123; buttonsArray = NSMutableArray() titlesArray = ["分类","品牌","首页","专题","品牌"] for var i = 0;i&lt;titlesArray.count;i++ &#123; let button = UIButton.init(type: .System) button.frame = CGRectMake(SCREENWIDTH * CGFloat (i) / 5.0, 0, SCREENWIDTH / 5.0, 40 * HEIGTH) button.tag = i button.backgroundColor = UIColor.blackColor() button.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) if i == 2 &#123; button.titleLabel?.font = UIFont.systemFontOfSize(16.0 * WIDTH) button.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; button.titleLabel?.font = UIFont.systemFontOfSize(15.0 * WIDTH) button.setTitle(titlesArray[i] as? String, forState: .Normal) button.addTarget(self, action: "click:", forControlEvents: .TouchUpInside) self.view.addSubview(button) buttonsArray.addObject(button) &#125; lineView = UIView.init(frame: CGRectMake(15 * WIDTH + (SCREENWIDTH / 5.0) * 2, 38 * HEIGTH, SCREENWIDTH / 5.0 - 30 * WIDTH, 2 * HEIGTH)) lineView.backgroundColor = UIColor.whiteColor() self.view.addSubview(lineView) &#125; func click (btn: UIButton) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; btn.titleLabel?.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) self.collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forItem: btn.tag, inSection: 0), atScrollPosition: .None, animated: true) UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (btn.tag), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125;) &#123;(Bool) -&gt; Void in &#125; &#125; func initCollectionView() &#123; let flowLayout = UICollectionViewFlowLayout() flowLayout.scrollDirection = .Horizontal flowLayout.itemSize = CGSizeMake(UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH) flowLayout.minimumLineSpacing = 0 flowLayout.minimumInteritemSpacing = 0 collectionView = UICollectionView.init(frame: CGRectMake(0, 40 * HEIGTH, UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH), collectionViewLayout: flowLayout) collectionView.delegate = self collectionView.dataSource = self collectionView.pagingEnabled = true collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forRow: 2, inSection: 0), atScrollPosition: .None, animated: true) self.view.addSubview(collectionView) collectionView.registerClass(HomeCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "hCell") collectionView.registerClass(KindCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "kCell") collectionView.registerClass(BrandCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "bCell") collectionView.registerClass(SubjectCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "sCell") collectionView.registerClass(GiftCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "gCell") &#125; func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 5 &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; if indexPath.item == 0 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("kCell", forIndexPath: indexPath) as! KindCollectionViewCell weak var weakSelf = self cell.initClosure(&#123; (str) -&gt; Void? in // let url = "http://mobile.iliangcang.com/goods/goodsShare?a=b&amp;page=1&amp;count=10&amp;coverId=1&amp;cat_code=$&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" let common = CommonViewController()// common.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: str) common.urlStr = str common.hidesBottomBarWhenPushed = true weakSelf!.navigationController?.pushViewController(common, animated: true) return nil &#125;) return cell &#125;else if indexPath.item == 1 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("bCell", forIndexPath: indexPath) as! BrandCollectionViewCell return cell &#125;else if indexPath.item == 2 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("hCell", forIndexPath: indexPath) as! HomeCollectionViewCell cell.myClosure = &#123; (content_id: String) -&gt; Void in let shopVC = ShopViewController() let url = "http://mobile.iliangcang.com/goods/goodsList?a=b&amp;list_id=$&amp;count=10&amp;page=1&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" shopVC.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: content_id) self.navigationController?.pushViewController(shopVC, animated: true) &#125; return cell &#125;else if indexPath.item == 3 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("sCell", forIndexPath: indexPath) as! SubjectCollectionViewCell return cell &#125;else &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("gCell", forIndexPath: indexPath) as! GiftCollectionViewCell return cell &#125; &#125; func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; UIView.animateWithDuration(0.3) &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (self.collectionView.contentOffset.x / (UIScreen.mainScreen().bounds.width)), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125; let btn = buttonsArray.objectAtIndex(Int(self.collectionView.contentOffset.x / UIScreen.mainScreen().bounds.width)) btn.titleLabel?!.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift tableViewCell 高度自适应]]></title>
    <url>%2FSwift-tableViewCell-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[1234567891011 static func cellhight (content: String) -&gt; CGFloat &#123; let rect: CGRect = content.boundingRectWithSize( CGSizeMake(SCREENWIDTH - 20, 0), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName: UIFont.systemFontOfSize(14)], context: nil) return rect.height + 61 &#125; 在返回cell 的高度的方法中直接调用return TableViewCell.cellhight(“这里面填想要自适应的文字”)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS视频图片压缩上传]]></title>
    <url>%2FiOS-%E8%A7%86%E9%A2%91%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[iOS视频图片压缩上传 上传方法: iOS-AFNetworking-3-0-上传图片视频到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 获取当前时间- (NSString *)getCurrentTime&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSString *dateTime = [formatter stringFromDate:[NSDate date]];// NSString *str = [NSString stringWithFormat:@"%@mdxx",dateTime];// NSString *tokenStr = [str stringToMD5:str]; return dateTime; &#125;#pragma mark - 视频压缩/** * 视频压缩 * * @param url 视频文件的url * * @return 压缩后的url */ - (NSURL *)condenseVideoNewUrl: (NSURL *)url&#123; // 沙盒目录 NSString *docuPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *destFilePath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyh%@.MOV",[self getCurrentTime]]]; NSURL *destUrl = [NSURL fileURLWithPath:destFilePath]; //将视频文件copy到沙盒目录中 NSFileManager *manager = [NSFileManager defaultManager]; NSError *error = nil; [manager copyItemAtURL:url toURL:destUrl error:&amp;error]; NSLog(@"压缩前--%.2fk",[self getFileSize:destFilePath]); // 播放视频 /* NSURL *videoURL = [NSURL fileURLWithPath:destFilePath]; AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.view.bounds; [self.view.layer addSublayer:playerLayer]; [player play]; */ // 进行压缩 AVAsset *asset = [AVAsset assetWithURL:destUrl]; //创建视频资源导出会话 /** NSString *const AVAssetExportPresetLowQuality; // 低质量 NSString *const AVAssetExportPresetMediumQuality; NSString *const AVAssetExportPresetHighestQuality; //高质量 */ AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:asset presetName:AVAssetExportPresetLowQuality]; // 创建导出的url NSString *resultPath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyhg%@.MOV",[self getCurrentTime]]]; session.outputURL = [NSURL fileURLWithPath:resultPath]; // 必须配置输出属性 session.outputFileType = @"com.apple.quicktime-movie"; // 导出视频 [session exportAsynchronouslyWithCompletionHandler:^&#123; NSLog(@"压缩后---%.2fk",[self getFileSize:resultPath]); NSLog(@"视频导出完成"); &#125;]; return session.outputURL;&#125;// 获取视频的大小- (CGFloat) getFileSize:(NSString *)path&#123; NSFileManager *fileManager = [[NSFileManager alloc] init] ; float filesize = -1.0; if ([fileManager fileExistsAtPath:path]) &#123; NSDictionary *fileDic = [fileManager attributesOfItemAtPath:path error:nil];//获取文件的属性 unsigned long long size = [[fileDic objectForKey:NSFileSize] longLongValue]; filesize = 1.0*size/1024; &#125; return filesize;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma mark - Picker delgate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info &#123; NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) &#123; NSLog(@"选取的是照片"); // self.imageView.image = info[UIImagePickerControllerEditedImage]; // 压缩图片 NSData *fileData = UIImageJPEGRepresentation(info[UIImagePickerControllerEditedImage], 0.5); //保存到Documents NSString *imageStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *imageFile = [imageStr stringByAppendingPathComponent:@"image.jpg"]; NSLog(@"%@",imageFile); [fileData writeToFile:imageFile atomically:YES]; //保存至相册 UIImageWriteToSavedPhotosAlbum(info[UIImagePickerControllerEditedImage], self, @selector(image:didFinishSavingWithError:contextInfo:), nil); // 上传图片 NSDictionary *dict = @&#123;@"mem_id":@"600209"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:fileData name:@"photo" fileName:@"abc.jpg" mimeType:@"image/jpeg" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"success:%@ %@",responseObject, [responseObject objectForKey:@"msg"]); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125;else&#123; // 如果是视频 NSURL *url = info[UIImagePickerControllerMediaURL]; // 获取视频总时长 CGFloat lengthTime = [self getVideoLength:url]; NSLog(@"%f",lengthTime); // 保存视频至相册 (异步线程) NSString *urlStr = [url path]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(urlStr)) &#123; UISaveVideoAtPathToSavedPhotosAlbum(urlStr, self, @selector(video:didFinishSavingWithError:contextInfo:), nil); &#125; &#125;); //压缩视频 NSData *videoData = [NSData dataWithContentsOfURL:[self condenseVideoNewUrl:url]]; //视频上传 if (lengthTime &gt;10.0f) &#123; NSLog(@"文件过大只允许上传10s视频"); &#125;else &#123; NSDictionary *dict = @&#123;@"username":@"syl"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:videoData name:@"file" fileName:@"video.mov" mimeType:@"video/quicktime" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"上传成功%@",responseObject); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125;// 获取视频时间- (CGFloat) getVideoLength:(NSURL *)URL&#123; AVURLAsset *avUrl = [AVURLAsset assetWithURL:URL]; CMTime time = [avUrl duration]; int second = ceil(time.value/time.timescale); return second;&#125;#pragma mark 图片保存完毕的回调- (void) image: (UIImage *) image didFinishSavingWithError:(NSError *) error contextInfo: (void *)contextIn &#123; NSLog(@"照片保存成功");&#125;#pragma mark 视频保存完毕的回调- (void)video:(NSString *)videoPath didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextIn &#123; if (error) &#123; NSLog(@"保存视频过程中发生错误，错误信息:%@",error.localizedDescription); &#125;else&#123; NSLog(@"视频保存成功."); &#125;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS AFNetworking 3.0 上传图片视频到服务器]]></title>
    <url>%2FiOS-AFNetworking-3-0-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于AFNetworking 3.0图片上传的封装 .h1234567891011typedef NS_ENUM(NSUInteger, ResposeStyle) &#123; JSON, XML, Data,&#125;;typedef NS_ENUM(NSUInteger, RequestStyle) &#123; RequestJSON, RequestString, RequestDefault&#125;; .m @param url 服务器地址 @param parameters 字典 token @param fileData 要上传的数据 @param name 服务器参数名称 后台给你 @param fileName 文件名称 图片:xxx.jpg,xxx.png 视频:video.mov @param mimeType 文件类型 图片:image/jpg,image/png 视频:video/quicktime @param style 返回的数据类型 @param progress @param success @param failure 123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (void)upLoadToUrlString:(NSString *)url parameters:(NSDictionary *)parameters fileData:(NSData *)fileData name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType response:(ResposeStyle)style progress:(void (^)(NSProgress *))progress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123; //1.获取单例的网络管理对象 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.根据style 的类型 去选择返回值得类型 switch (style) &#123; case JSON: manager.responseSerializer = [AFJSONResponseSerializer serializer]; break; case XML: manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; break; case Data: manager.responseSerializer = [AFHTTPResponseSerializer serializer]; break; default: break; &#125; //3.设置相应数据支持的类型 [manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript",@"text/html",@"text/css",@"text/plain", @"application/javascript",@"application/json", @"application/x-www-form-urlencoded", nil]]; [manager POST:url parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; [formData appendPartWithFileData:fileData name:name fileName:fileName mimeType:mimeType]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(task, responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(task, error); &#125; &#125;];&#125; PS:上传图片前，必须先压缩图片，不然图片过大，可能会导致上传失败！ 具体上传操作:iOS-视频图片压缩上传]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView添加类似微信的进度条]]></title>
    <url>%2FiOS-WKWebView%E6%B7%BB%E5%8A%A0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[WKWebView添加类似微信的进度条 1.m中声明两个属性@property (nonatomic, strong) WKWebView *wkWebView;@property (nonatomic, strong) UIProgressView *progressView;@property (nonatomic, assign) NSUInteger loadCount; 2.初始化方法…省略 3.添加KVO12通过监听estimatedProgress可以获取它的加载进度 还可以监听它的title ,URL, loading[wkWebView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:nil]; 4.计算进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@"loading"]) &#123; &#125; else if ([keyPath isEqualToString:@"title"]) &#123; self.title = self.wKWebView.title; &#125; else if ([keyPath isEqualToString:@"URL"]) &#123; &#125; else if ([keyPath isEqualToString:@"estimatedProgress"]) &#123; self.progressView.progress = self.wKWebView.estimatedProgress; &#125; if (object == self.wKWebView &amp;&amp; [keyPath isEqualToString:@"estimatedProgress"]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; if (newprogress == 1) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; [self.progressView setProgress:newprogress animated:YES]; &#125; &#125;&#125; - (void)setLoadCount:(NSUInteger)loadCount &#123; _loadCount = loadCount; if (loadCount == 0) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; CGFloat oldP = self.progressView.progress; CGFloat newP = (1.0 - oldP) / (loadCount + 1) + oldP; if (newP &gt; 0.95) &#123; newP = 0.95; &#125; [self.progressView setProgress:newP animated:YES]; &#125;&#125;// 页面开始加载时调用 - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123; self.loadCount ++;&#125;// 内容返回时 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123; self.loadCount --; &#125;//失败 - (void)webView:(WKWebView *)webView didFailNavigation: (null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123; self.loadCount --; NSLog(@"%@",error);&#125; 最后别忘记在dealloc 中取消监听]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS9 新增 UIStackView 官方文档翻译]]></title>
    <url>%2FiOS9-%E6%96%B0%E5%A2%9E-UIStackView-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[iOS9 新增 UIStackView 官方文档翻译 一、继承关系、遵守协议、隶属框架及可用平台 UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。Stack视图管理着所有在它的 arrangedSubviews 属性中的视图的布局。这些视图根据它们在 arrangedSubviews 数组中的顺序沿着 Stack 视图的轴向排列。精确的布局变量根据 Stack 视图的 axis, distribution,alignment, spacing, 和其它属性共同决定。 使用 stack 视图，打开一个你希望编辑的 Storyboard，从对象库中拖拽出一个 Horizontal Stack View 或者一个 Vertical Stack View，并放置到你希望的位置上 。下一步，将控件或视图拖拽放置到 stack 中,也可以先拖拽控件再合并为 Stack View，如果需要你可以继续添加视图或者控件给指定的 stack。Interface Builder 将根据 stack 的内容自动调节尺寸。你也可以通过修改属性面板中 Stack视图的属性调整 stack 内容的外观。 注意：你需要负责指定 stack 视图的位置和尺寸（可选的）。然后 stack 视图将管理其内容的布局和尺寸。 二、Stack 视图与自动布局 Stack 视图使用自动布局来定位和控制其管理的视图的尺寸。stack 视图沿着它的轴向拼凑第一个和最后一个被管理视图，使其边界平齐。对于一个水平 stack 视图，这意味着第一个被管理视图的左边界是与 stack 的左边界平齐的，并且最后一个被管理视图右边界与 stack的右边界平齐。对于垂直 stack，上边界和下边界是各自平齐的。如果你设置了 stack 视图的 layoutMarginsRelativeArrangement 属性为 YES，stack 视图将使用相关的边距与其内容对齐，而不是边界。 对于除去 UIStackViewDistributionFillEqually 分布以外的分布方式，stack 视图使用被管理视图的 intrinsicContentSize 属性来计算沿着 stack 轴向的视图尺寸。UIStackViewDistributionFillEqually 分布将调节所有被管理视图的在 stack 轴向上拥有相同尺寸，以填充 stack 视图。如果可能，stack 视图将拉伸所有被管理视图，来匹配其在 stack 轴向上最长的原有尺寸（译注：保证长宽比的情况下根据 stack 轴向长度拉伸视图）。 对于除去 UIStackViewAlignmentFill 对齐方式以外的对齐方式，stack 视图使用其管理的视图的 intrinsicContentSize 属性来计算视图垂直于 stack 轴向的尺寸。 UIStackViewAlignmentFill 重新调节了所有其管理的视图，使这些视图填充 stack 视图垂直于其轴向空间。如果可能，stack 视图将拉伸其所有管理的视图来匹配其垂直于 stack 轴向的最大固有尺寸。 三、定位和调整 Stack 视图尺寸当 Stack 视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位 stack 视图。通常情况下，这意味着需要拼凑至少两个边界相邻的stack来定义它的位置。没有额外约束的情况下，系统会为 stack 视图计算一个尺寸来适应其内容： 沿着 stack 视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和； 垂直于 stack 视图轴向，其适应尺寸等于其管理的视图中最大的视图的尺寸； 如果 stack 视图的 layoutMarginsRelativeArrangement 属性设置为 YES，stack 视图的适应尺寸会包括边距空间。 你可以提供额外的约束来具体说明 stack 视图的高度、宽度或者两者兼有。在这些情况下，stack 视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据 stack 视图的属性获得。可以通过查看 UIStackViewDistribution 和 UIStackViewAlignment 枚举，以获得一个完整的 stack 视图在其内容空间多余或空间不足情况下的处理描述。 你也可以根据 stack 视图的第一条或最后一条基线定位它，而不是使用顶部、底部或者中心的Y值。类似于 stack 视图的适应尺寸，这些基线都是基于 stack 视图的内容计算得到的。 一个水平的 stack 视图调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法时返回它最高的视图。如果最高的视图也是一个 stack 视图，那么其返回的将是在嵌套的 stack 视图上调用 viewForFirstBaselineLayout 方法或viewForLastBaselineLayout 方法的结果。 一个垂直的 stack 视图当调用 viewForFirstBaselineLayout 方法时返回的是其管理的第一个视图，当调用viewForLastBaselineLayout 方法时返回的是其管理的最后一个视图。如果这两个视图之一也是 stack 视图，那么其返回的将是在嵌套的 stack 视图上对应调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法的结果。 注意：基线对齐方式只作用于那些高度匹配其原本内容高度的视图。如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。 四、通用 Stack 视图布局 这有一些通用方法用于 stack 视图。这个清单是要高亮一些有用的示例来显示 stack 视图的灵活性。目前这还不是一个完整的清单。 只是定义位置。你可以通过固定两个与其父视图相邻的边界来定义 stack 视图的位置。在这里，stack 视图的尺寸将根据其管理的视图在两个维度上自由扩展。当你想要 stack 视图的内容展现其原有内容尺寸，和你想要管理其他与 stack 视图有关联的用户接口元素时是特别有用的。 举个例子，在 Figure 1中，stack 视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基线校准。这对于相对于其本身左对齐的 stack 视图内容是有效的。 Figure 1.定义位置 定义沿着 stack 视图轴向的尺寸。这里，你固定了沿着 stack 视图轴向相对于其父视图的两个边界，定义了 stack 视图沿着其轴向的尺寸。你将需要固定其他边界中的一个来定义 stack 视图的位置。stack 视图将沿着其轴向改变尺寸和位置来填充定义的空间；然而，未固定的边界将根据其管理的最大视图的尺寸自由移动。 举例如 Figure 2，stack 视图的左、上、右边界都已经相对于其父视图固定了。使用 UIStackViewDistributionFill 分布使得其内容重设尺寸来填充它的宽度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。 Figure 2.定义沿着 stack 视图轴向的尺寸 定义垂直于 stack 视图轴向的尺寸。这类似于上一个示例，但是你固定了垂直于 stack 视图轴向的两个边界和沿着轴向的一个边界。这使得 stack 视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了 UIStackViewDistributionFillEqually 分布，被管理的视图将根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其 stack 视图的对其模式在其定义的范围内平铺。 举例，Figure 3展示了一个包含了四个标签和一个按钮的垂直 stack 视图。这个 stack 视图使用了8个点的间隙和UIStackViewAlignmentCenter 对齐方式。stack 视图的高度将根据 stack 内部的元素的增减而增大或回缩。 Figure 3.定义垂直于 stack 视图轴向的尺寸 同时定义 stack 视图的位置和尺寸。这里你固定了 stack 视图的所有四个边界。stack 视图将在提供的范围之内平铺其内容。举例，Figure 4展示了一个所有四个边界都相对于其父视图固定的垂直 stack 视图。通过使用 UIStackViewAlignmentCenter 对齐方式和UIStackViewDistributionFill 分布方式，stack 视图确保其内容将水平和垂直居中填充屏幕。然而，获得想要的布局需要两个额外的步骤。默认情况下，stack视图会垂直拉伸标签而不是图片。要缩放图片控件，就要降低其内容紧凑优先级到低于标签。额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit。增加一个图片视图与 stack 视图间宽度相等约束将有助于确保图片将被缩放来填充可用范围。 Figure 4.同时定义 stack 视图的位置和尺寸 五、管理 Stack 视图的展现UIStackView 是 UIView 的非渲染型子类。它没有提供其自有的任何用户接口。相反的，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如 backgroundColor)在 stack 视图上是无效的。类似的，你无法重写 layerClass，drawRect: 或 drawLayer:inContext: 方法。 这里有一系列的属性来定义 stack 视图如何平铺其内容。 axis(轴向) 属性决定了 stack 的朝向，只有垂直或水平；distribution(分布) 属性决定了其管理的视图在沿着其轴向上的布局； alignment(对齐) 属性决定了其管理的视图在垂直于其轴向上的布局； spacing(空隙) 属性决定了其管理的视图间的最小间隙； baselineRelativeArrangement 属性决定了其视图间的垂直间隙是否根据基线测量得到； layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距 通常情况下，你会使用一个 stack 视图来布局小数量的视图。你可以通过在其他 stack 视图中嵌套多个 stack 视图的方式创建更加复杂的视图层次结构。举例，Figure 5展示了一个包含两个水平 stack 视图的垂直 stack 视图。每一个水平 stack 视图各包含一个标签和一个文本框。 Figure 5.Stack 视图的嵌套 你也可以通过增加被管理的视图的额外约束来完美的调节一个被管理视图的展现。举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度。或者你可以定义一个长宽比。当平铺其内容时，stack 视图将使用这些约束。举例来说，在Figure 4中，当图片被缩放时，图片视图的一个长宽比约束被强行赋予了一个长宽比常数。 注意：当给一个 stack 视图内的视图增加约束时要特别注意避免传入冲突。作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容尺寸，那么你可以安全的在这个维度上增加约束。 六、维护其管理的视图与子视图之间的统一性Stack 视图确保它的 arrangedSubviews 属性将一直是其 subviews 属性的子集合。明确的说，stack 视图强制实施了以下规定： 无论何时 stack 视图增加了一个视图到它的 arrangedSubviews 数组，其也将把这个视图作为子视图增加，如果还未增加的话。 无论何时一个子视图从 stack 视图中被移除，那么 stack 视图也将将其从 arrangedSubviews 数组中移除。 从 arrangedSubviews 移除一个视图并不会将其作为子视图移除。stack 视图将不再管理该视图的尺寸和位置，但是该视图仍将是视图结构的一部分，并且当其可见的情况下仍会被渲染到屏幕上。 当 arrangedSubviews 数组一直包含着 subviews 数组的子集合，这些数组间的顺序仍然是独立的。 arrangedSubviews 数组的顺序定义了展现在 stack 中的视图的顺序。对于水平 stack 视图，这些视图将以阅读顺序平铺，即较小索引的视图在较大索引视图的左侧。对于垂直 stack 视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。 subviews 数组中的顺序定义了子视图在Z轴上是顺序。如果视图重叠，有较小索引的子视图将出现在有较大索引的子视图后方。 七、动态改变 Stack 视图内容当视图被加入、移出或插入 arrangedSubviews 数组时，或当一个被管理的子视图的 hidden 属性改变时，stack 视图都会自动更新它的布局。 OC代码如下 : 1234// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES; Swift代码如下： 12345// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. let firstView = stackView.arrangedSubviews[0] firstView.hidden = true stack 视图也会自动响应其任何属性的改变。举例，你可以更新 stack 视图的 axis 属性来动态改变的朝向。 OC代码如下： 12345678// Toggle between a vertical and horizontal stackif (self.stackView.axis == UILayoutConstraintAxisHorizontal) &#123; self.stackView.axis = UILayoutConstraintAxisVertical;&#125;else &#123; self.stackView.axis = UILayoutConstraintAxisHorizontal;&#125; Swift代码如下： 123456789// Toggle between a vertical and horizontal stackif stackView.axis == .Horizontal &#123; stackView.axis = .Vertical&#125;else &#123; stackView.axis = .Horizontal&#125; 对于被管理的子视图的 hidden 属性的变化和 stack 视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画方式展现。 OC代码如下： 12345// Animates removing the first item in the stack.[UIView animateWithDuration:0.25 animations:^&#123; UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES;&#125;]; Swift代码如下： 12345// Animates removing the first item in the stack.UIView.animateWithDuration(0.25) &#123; () -&gt; Void in let firstView = stackView.arrangedSubviews[0] firstView.hidden = true&#125; 最后，你可以直接在Interface Builder中给很多 stack 视图属性定义特定的 “尺寸类” 类型值。系统将在 stack 视图的尺寸类改变时动画展现这些改变。 八、常用的方法创建 Stack 视图 - initWithArrangedSubviews: (New in iOS 9.0) 管理安排的子视图 1234567addArrangedSubview: (New in iOS 9.0)arrangedSubviews Property (New in iOS 9.0)insertArrangedSubview:atIndex: (New in iOS 9.0)removeArrangedSubview: (New in iOS 9.0) 设置布局 1234567891011alignment Property (New in iOS 9.0)axis Property (New in iOS 9.0)baselineRelativeArrangement Property (New in iOS 9.0)distribution Property (New in iOS 9.0)layoutMarginsRelativeArrangement Property (New in iOS 9.0)spacing Property (New in iOS 9.0) 常量 12UIStackViewDistributionUIStackViewAlignment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Masonry介绍与使用实践]]></title>
    <url>%2FMasonry%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Masonry介绍与使用实践前言MagicNumber -&gt; autoresizingMask -&gt; autolayout 以上是纯手写代码所经历的关于页面布局的三个时期 在iphone1-iphone3gs时代 window的size固定为(320,480) 我们只需要简单计算一下相对位置就好了 在iphone4-iphone4s时代 苹果推出了retina屏 但是给了码农们非常大的福利:window的size不变 在iphone5-iphone5s时代 window的size变了(320,568) 这时autoresizingMask派上了用场(为啥这时候不用Autolayout? 因为还要支持ios5呗) 简单的适配一下即可 在iphone6+时代 window的width也发生了变化(相对5和5s的屏幕比例没有变化) 终于是时候抛弃autoresizingMask改用autolayout了(不用支持ios5了 相对于屏幕适配的多样性来说autoresizingMask也已经过时了) 那如何快速的上手autolayout呢? 说实话 当年ios6推出的同时新增了autolayout的特性 我看了一下官方文档和demo 就立马抛弃到一边了 因为实在过于的繁琐和啰嗦(有过经验的朋友肯定有同感) 直到iPhone6发布之后 我知道使用autolayout势在必行了 这时想起了以前在浏览Github看到过的一个第三方库Masonry 在花了几个小时的研究使用后 我就将autolayout掌握了(重点是我并没有学习任何的官方文档或者其他的关于autolayout的知识) 这就是我为什么要写下这篇文章来推荐它的原因. 介绍Masonry 源码：https://github.com/Masonry/Masonry Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。 我们先来看一段官方的sample code来认识一下Masonry 123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).with.insets(padding);&#125;]; 看到block里面的那句话: make edges equalTo superview with insets 通过链式的自然语言 就把view1给autolayout好了 是不是简单易懂? 使用看一下Masonry支持哪一些属性1234567891011@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;@property (nonatomic, strong, readonly) MASConstraint *leading;@property (nonatomic, strong, readonly) MASConstraint *trailing;@property (nonatomic, strong, readonly) MASConstraint *width;@property (nonatomic, strong, readonly) MASConstraint *height;@property (nonatomic, strong, readonly) MASConstraint *centerX;@property (nonatomic, strong, readonly) MASConstraint *centerY;@property (nonatomic, strong, readonly) MASConstraint *baseline; 在ios8发布后 又新增了一堆奇奇怪怪的属性(有兴趣的朋友可以去瞅瞅) Masonry暂时还不支持(不过你要支持ios6,ios7 就没必要去管那么多了) 在讲实例之前 先介绍一个MACRO #define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self; 快速的定义一个weakSelf 当然是用于block里面啦 下面进入正题(为了方便 我们测试的superView都是一个size为(300,300)的UIView) 下面 通过一些简单的实例来简单介绍如何轻松愉快的使用Masonry: [基础] 居中显示一个view123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view. WS(ws); UIView *sv = [UIView new]; [sv showPlaceHolder]; sv.backgroundColor = [UIColor blackColor]; [self.view addSubview:sv]; [sv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(ws.view); make.size.mas_equalTo(CGSizeMake(300, 300)); &#125;];&#125; 代码效果 使用我之间写的MMPlaceHolder 可以看到superview已经按照我们预期居中并且设置成了适当的大小 那么先看看这几行代码 //从此以后基本可以抛弃CGRectMake了1UIView *sv = [UIView new]; //在做autoLayout之前 一定要先将view添加到superview上 否则会报错 1[self.view addSubview:sv]; //mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了 123456[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;//将sv居中(很容易理解吧?) make.center.equalTo(ws.view); //将size设置成(300,300) make.size.mas_equalTo(CGSizeMake(300, 300));&#125;]; 这里有两个问题要分解一下首先在Masonry中能够添加autolayout约束有三个函数 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 其次 equalTo 和 mas_equalTo的区别在哪里呢? 其实 mas_equalTo是一个MACRO #define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) #define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__))) 可以看到 mas_equalTo只是对其参数进行了一个BOX操作(装箱) MASBoxValue的定义具体可以看看源代码 太长就不贴出来了 所支持的类型 除了NSNumber支持的那些数值类型之外 就只支持CGPoint CGSize UIEdgeInsets 介绍完这几个问题 我们就继续往下了 PS:刚才定义的sv会成为我们接下来所有sample的superView [初级] 让一个view略小于其superView(边距为10)12345678910111213141516UIView *sv1 = [UIView new];[sv1 showPlaceHolder];sv1.backgroundColor = [UIColor redColor];[sv addSubview:sv1];[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); /* 等价于 make.top.equalTo(sv).with.offset(10); make.left.equalTo(sv).with.offset(10); make.bottom.equalTo(sv).with.offset(-10); make.right.equalTo(sv).with.offset(-10); */ /* 也等价于 make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); */&#125;]; 代码效果 这里写图片描述可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事 那么为什么bottom和right里的offset是负数呢? 因为这里计算的是绝对的数值 计算的bottom需要小鱼sv的底部高度 所以要-10 同理用于right 这里有意思的地方是and和with 其实这两个函数什么事情都没做 123456- (MASConstraint *)with &#123; return self;&#125;- (MASConstraint *)and &#123; return self;&#125; 但是用在这种链式语法中 就非常的巧妙和易懂 不得不佩服作者的心思(虽然我现在基本都会省略) [初级] 让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算其宽度)123456789101112131415int padding1 = 10;[sv2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv.mas_left).with.offset(padding1); make.right.equalTo(sv3.mas_left).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv3);&#125;];[sv3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv2.mas_right).with.offset(padding1); make.right.equalTo(sv.mas_right).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv2);&#125;]; 代码效果 这里我们在两个子view之间互相设置的约束 可以看到他们的宽度在约束下自动的被计算出来了 [中级] 在UIScrollView顺序排列一些view并自动计算contentSize123456789101112131415161718192021222324252627282930313233343536373839404142434445UIScrollView *scrollView = [UIScrollView new];scrollView.backgroundColor = [UIColor whiteColor];[sv addSubview:scrollView];[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(5,5,5,5));&#125;];UIView *container = [UIView new];[scrollView addSubview:container];[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(scrollView); make.width.equalTo(scrollView);&#125;];int count = 10;UIView *lastView = nil;for ( int i = 1 ; i &lt;= count ; ++i )&#123; UIView *subv = [UIView new]; [container addSubview:subv]; subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 ) saturation:( arc4random() % 128 / 256.0 ) + 0.5 brightness:( arc4random() % 128 / 256.0 ) + 0.5 alpha:1]; [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(container); make.height.mas_equalTo(@(20*i)); if ( lastView ) &#123; make.top.mas_equalTo(lastView.mas_bottom); &#125; else &#123; make.top.mas_equalTo(container.mas_top); &#125; &#125;]; lastView = subv;&#125;[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(lastView.mas_bottom);&#125;]; 头部效果 尾部效果 从scrollView的scrollIndicator可以看出 scrollView的内部已如我们所想排列好了 这里的关键就在于container这个view起到了一个中间层的作用 能够自动的计算uiscrollView的contentSize [高级] 横向或者纵向等间隙的排列一组view很遗憾 autoLayout并没有直接提供等间隙排列的方法(Masonry的官方demo中也没有对应的案例) 但是参考案例3 我们可以通过一个小技巧来实现这个目的 为此我写了一个Category 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@implementation UIView(Masonry_LJC)- (void) distributeSpacingHorizontallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(ws.mas_left); make.centerY.equalTo(((UIView*)views[0]).mas_centerY); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(lastSpace.mas_right); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(obj.mas_right); make.centerY.equalTo(obj.mas_centerY); make.width.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.right.equalTo(ws.mas_right); &#125;];&#125;- (void) distributeSpacingVerticallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(ws.mas_top); make.centerX.equalTo(((UIView*)views[0]).mas_centerX); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(lastSpace.mas_bottom); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(obj.mas_bottom); make.centerX.equalTo(obj.mas_centerX); make.height.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(ws.mas_bottom); &#125;];&#125;@end简单的来测试一下UIView *sv11 = [UIView new];UIView *sv12 = [UIView new];UIView *sv13 = [UIView new];UIView *sv21 = [UIView new];UIView *sv31 = [UIView new];sv11.backgroundColor = [UIColor redColor];sv12.backgroundColor = [UIColor redColor];sv13.backgroundColor = [UIColor redColor];sv21.backgroundColor = [UIColor redColor];sv31.backgroundColor = [UIColor redColor];[sv addSubview:sv11];[sv addSubview:sv12];[sv addSubview:sv13];[sv addSubview:sv21];[sv addSubview:sv31];//给予不同的大小 测试效果[sv11 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(@[sv12,sv13]); make.centerX.equalTo(@[sv21,sv31]); make.size.mas_equalTo(CGSizeMake(40, 40));&#125;];[sv12 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(70, 20));&#125;];[sv13 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 50));&#125;];[sv21 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 20));&#125;];[sv31 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(40, 60));&#125;];[sv distributeSpacingHorizontallyWith:@[sv11,sv12,sv13]];[sv distributeSpacingVerticallyWith:@[sv11,sv21,sv31]];[sv showPlaceHolderWithAllSubviews];[sv hidePlaceHolder]; 代码效果 perfect! 简洁明了的达到了我们所要的效果 这里所用的技巧就是 使用空白的占位view来填充我们目标view的旁边 这点通过图上的空白标注可以看出来 小结通过以上5个案例 我觉得已经把Masonry的常用功能介绍得差不多了 如果你觉得意犹未尽呢 请下载官方的demo来学习 总而言之 Masonry是一个非常优秀的autolayout库 能够节省大量的开发和学习时间 尤其适合我这种纯代码的iOSer 在iPhone6发布后引发的适配潮中 Masonry一定可以助你一臂之力 😃]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods完整使用]]></title>
    <url>%2FCocoapods%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CocoaPods安装使用及配置私有库 如何安装?1.安装ruby环境,添加淘宝ruby镜像123$ gem sources --remove https://rubygems.org///等有反应之后再敲入以下命令$ gem sources -a https://ruby.taobao.org/ 2.查看是否设置成功:1$ gem sources -l 3.然后安装cocoapods:1$ sudo gem install cocoapods 4.查看cocoapods是否支持某个类库1$ pod search 类库名,支持模糊查询(如:AFNetworking) 如何使用?在项目根目录下新建一个“Podfile”的文件(记住一定得叫这个名儿,而且木有后缀)注:Podfile也可以放在任何位置,但是需要在Podfile顶部使用”xcodeproj”关键字指定工程的路径,如下: 但是执行pod install命令后,生成的文件放在了Podfile所在的目录. 编辑Podfile文件输入以下信息12platform :iOS, ‘7.0’\\所有库支持的IOS最低版本pod ‘AFNetworking’, ‘~&gt; 2.0’\\版本号 注:有些第三方库需要指明:platform 支持的IOS最低版本,否则在pod install时会报错,如下图,提示AFNetworking最低支持IOS6.0和OS X 10.8 然后在项目podfile所在目录下运行:(会在你当前项目中导入podfile所配置的库,所以要在项目目录下运行)$ pod install 注意上述命令运行完毕后终端输出的最后一段话,意思就是以后打开项目就用CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 [!] From now on useCocoaPodsDemo.xcworkspace. 经过以上步骤后,我们现在可以打开CocoaPodsDemo.xcworkspace启动我们的新工程了.新工程中已经通过cocoapods引入并配置好了我们刚在podfile写的需要依赖的第三方库了. 引入第三方库后找不到头文件?在项目的Targe-Build Settings-Search Paths-User Header Searcj Paths中添加 ${SRCROOT} 值为 recursive 如下图: 如何编译从github上checkout下来的一个已包含CocoPods类库的项目?打开终端进入你所下载项目的根目录,执行以下命令,后会得到上面的那句话: $ pod update 等待命令运行完毕后,同样最后会输出 [!] From now on usexxxxx.xcworkspace. 如何删除cocopods? 删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹 删除xcworkspace文件 使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources 这里写图片描述 CocoaPods常用命令1、pod install根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。 每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。等其执行完毕，即可完成第三方库的安装其中还可以调用pod update方法, 也可以达到第三方库安装的目的, 并且会更新版本 在pod install或者pod update过程中会执行podspec索引的更新，需要等待很久，因此为了提升速度可以执行如下命令, 关掉索引的更新 pod install --no-repo-update 并且在安装过程中, 我们不知道cocoapods做了什么, 还可以添加一个参数，用来提示我们，cococapods做了哪些操作 pod install --verbose --no-repo-update列表内容 2、pod update若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。 3、pod search命令格式为： $ pod search 类库名,支持模糊查询(如:AFNetworking) 红框中的信息为AFNetworking 最新版本,Version中显示了历史版本,根据这些信息来编写我们的Podfile文件如: pod ‘AFNetWorking’, ‘~&gt; 2.2.4′ 这句话具体含义是什么呢?当我们通过cocopods引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下 123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本pod ‘AFNetworking’, ‘&gt; 2.0’ //使用高于2.0的版本pod ‘AFNetworking’, ‘&gt;= 2.0’ //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘&lt; 2.0’ //使用小于2.0的版本pod ‘AFNetworking’, ‘&lt;= 2.0’ //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘~&gt; 0.1.2’ //使用大于等于0.1.2但小于0.2的版本pod ‘AFNetworking’, ‘~&gt;0.1’ //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘~&gt;0’ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 4、pod setup用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。 1.多个target中使用相同的Pods依赖库比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式： 1234567link_with ‘CocoaPodsTest’, ‘Second’platform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0’ 这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。 2.不同的target使用完全不同的Pods依赖库CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下： 123456789101112target :’CocoaPodsTest’ doplatform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0′endtarget :’Second’ dopod ‘OpenUDID’, ‘~&gt; 1.0.0’end 其中，do/end作为开始和结束标识符。 Podfile.lock文件在使用CocoaPods，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。该文件用于保存已经安装的Pods依赖库的版本，通过CocoaPods安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为： 123456789101112131415161718192021222324252627282930313233PODS:– AFNetworking (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/NSURLSession– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/UIKit– AFNetworking/NSURLConnection (2.1.0):– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/NSURLSession (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/Reachability (2.1.0)– AFNetworking/Security (2.1.0)– AFNetworking/Serialization (2.1.0)– AFNetworking/UIKit (2.1.0):– AFNetworking/NSURLConnection– Reachability (3.0.0)– SBJson (4.0.0)DEPENDENCIES:– AFNetworking (~&gt; 2.0)– Reachability (~&gt; 3.0.0)– SBJson (~&gt; 4.0.0)SPEC CHECKSUMS:AFNetworking: c7d7901a83f631414c7eda1737261f696101a5cdReachability: 500bd76bf6cd8ff2c6fb715fc5f44ef6e4c024f2SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220COCOAPODS: 0.29.0 Podfile.lock文件最大得用处在于多人开发。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案： 1.更改Podfile，使其指向最新版本的SBJson依赖库； 2.执行pod update命令； 鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。 如何制作自己的Cocopods库在github上新建一个工程 license类型正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。 把项目clone到本地然后在根目录下新建MyPodDemo.podspec 或使用命令 $ pod spec create MyPodDemo Spec文件编写:123456789101112131415161718192021222324Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo."s.description = &lt;&lt;-DESCA longer description of MyPodDemo in Markdown format.* Think: Why did you write this? What is the focus? What does it do?* CocoaPods will be using this to generate tags, and improve search results.* Try to keep it short, snappy and to the point.* Finally, don't worry about the indent, CocoaPods strips it!DESCs.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo/Src", "MyPodDemo/Src/**/*.&#123;h,m&#125;"s.requires_arc = true# s.framework = "SomeFramework"# s.frameworks = "SomeFramework", "AnotherFramework"# s.library = "iconv"# s.libraries = "iconv", "xml2"# s.dependency "JSONKit", "~&gt; 1.4"# s.dependency "AFNetworking", "~&gt; 2.2.4"end 自解析:123456789101112name: 导入pod后的目录名version: 当前版本号deployment_target: 配置的targetprefix_header_file: 预编译头文件路径，将该文件的内容插入到Pod的pch文件内source: 来源的具体路径，是http链接还是本地路径requires_arc: 是否需要arcsource_files: 指定该目录下包含哪些文件其他可选参数还包括：dependency: 指定依赖，如果依赖的库不存在或者依赖库的版本不符合要求将会报错libraries: 指定导入的库，比如sqlite3frameworks: 指定导入的frameworkweak_frameworks: 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。 整个podspec语法是一个嵌套结构从Pod::Spec.new do |s|到最后一个end是最大的循环，表示整个podspec导入的文件。中间每一个subspec到end结束是一个子目录，Pods会为每个subspec创建一个逻辑目录，相当于Xcode的group概念。|**|中间是subspec的名字，可以随便命名，但后面使用的名称必须一致。 通配符说明1234a&#123;bb,bc&#125;def.&#123;h,m&#125;表示四个文件abbdef.h abbdef.m abcdef.h abcdef.m*.&#123;h,m,mm&#125;表示所有的.h .m .mm文件Class/**/*.&#123;h,m&#125;表示Class目录下的所有.h .m文件 写完podspec文件后使用pod spec lint验证spec是否合格,有error则需要修改 上传代码至github上传podspec文件到CocoaPods仓库(fork一下,修改完成后在push上去等待审核) 将我们刚刚生成的MyPodDemo.spec 文件上传到Cocoapods官方specs仓库中 :链接为：https://github.com/CocoaPods/Specs 私有库实现,编写podfile如果由于某些原因我们编写的库不能公开,但是又想使用pods来进行管理,要怎么办呢? 首先我们要将我们刚刚在github上建的仓库改为Private(不然还用Public搞毛啊) 然后修改我们项目的podfile,与已加入Cocopods仓库的公有库相比我们只需要指明私有库低git地址,如下: 123platform :ios, '6.0'pod 'MyPodDemo', :git =&gt; 'https://github.com/goingta/MyPodDemo.git' //私有库pod 'CocoaLumberjack'//公有库 版本控制和冲突(引用自http://objccn.io/issue-6-4/)CocoaPods 使用语义版本控制 – Semantic Versioning 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于2.3.1，另一个依赖于 2.3.3，此时冲突解决系统可以使用最新的版本 2.3.3，因为这个可以向后与 2.3.1 兼容。 但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。 当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 1.2.5，另外一个库则依赖于 2.3.1，那么只有最终用户通过明确指定使用某个版本来解决冲突。 配置非ARC文件前几天项目中由于历史原因,导致有一个私有的pods库中某几个文件是在非ARC时代写的,如果要进行修改工程量浩大,于是乎要对这几个文件单独处理,这几个文件不使用arc其他文件使用arc,网上查了一些资料,只需要对source_file进行修改并排除那几个不使用ARC的文件就可以了,大致修改如下: 123456789101112131415161718Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo.s.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo"non_arc_files = 'MyPodDemo/NoArcFile1.&#123;h,m&#125;','MyPodDemo/NoArcFile2.&#123;h,m&#125;'s.requires_arc = trues.exclude_files = non_arc_filess.subspec 'no-arc' do |sna|sna.requires_arc = falsesna.source_files = non_arc_filesendend 回退Cocoapods历史版本查看当前安装了哪些版本 gem list --local | grep cocoapods 如果你安装了多个版本(如0.35和0.20.2)那么你将看到 123cocoapods (0.34, 0.20.2)cocoapods-core (0.33, 0.20.2)cocoapods-downloader (0.2.0, 0.1.2) 先删除已经装过的版本(可能有几个,卸载的时候会让你输入1,2…n选择卸载那个版本 sudo gem uninstall cocoapods 或者强制卸载某一个版本 gem uninstall cocoapods -v 0.20.2 安装某一个版本 sudo gem install cocoapods -v 0.35.0 处理 Use the $(inherited) flag 异常有时候在pod update之后会遇到下面错误:12Use the `$(inherited)` flag, orRemove the build settings from the target. 虽然对项目编译没什么影响,但是看着还是挺不舒服的.解决办法就是 找到工程的 targets 点击工程名 Build Settings -&gt; Other linker flags -&gt; 添加 $(inherited)]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
</search>
