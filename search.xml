<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[code-push和code-push-server热更新上传到七牛云及阿里云]]></title>
    <url>%2Fcode-push%E5%92%8Ccode-push-server%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[自建 CodePush 服务CodePush 服务主要分为三个部分：服务端、客户端、React Native 项目。 服务端服务端需要使用 code-push-server 和MySQL 所以需要先将这两个安装好。 安装MySQL官网下载后直接双击安装，下载地址；打开“系统设置”，看到最新安装的MySQL，进入并启动服务。 安装 code-push-server 作者发布了两种安装方式（npm安装或源码安装），在此我推荐使用源码安装，为后期我们要基于这个服务修改自己的网页，源码安装方便些。 下载code-push-server代码1234// clone代码git clone https://github.com/lisong/code-push-server.git// 进入项目并安装资源cd code-push-server &amp;&amp; npm install 修改config/config.js 文件，在 db 对象中添加数据库信息，参考如下：12345678910db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, 创建数据库表1./bin/db init --dbhost localhost --dbuser root --dbpassword admin123 --dbname codepush 为了演示我重新创建一个 配置打包后的，bundle存储地址，这里配置loal本地也可以配置qiniu和OSS创建storage和data文件夹，用来保存打包好的资源，供用户更新下载，downloadUrl地址必须为服务器所在的地址，不然用户无法下载到包。主要配置如下： 七牛对象储存地址 123456qiniu: &#123; accessKey: "", //个人面板 &gt; 秘钥管理 &gt; AK secretKey: "", //个人面板 &gt; 秘钥管理 &gt; SK bucketName: "faweapp",//储存空间名称 downloadUrl: "http://babi.lhsea.com" //绑定的域名 &#125;, 阿里云对象储存 12345678oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo",//储存空间名称 prefix: "storage", // 目录文件夹名称 downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", //下载地址 &#125;, config.js文件路径：code-push-server/config/config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var os = require('os');var config = &#123;&#125;;config.development = &#123; // Config for database, only support mysql. db: &#123; username: process.env.RDS_USERNAME || "root", password: process.env.RDS_PASSWORD || "admin123",//你的MySQL访问密码,如果没有就null database: process.env.DATA_BASE || "codepush",//如果你init的时候指定了数据库名字的话，也需要改 host: process.env.RDS_HOST || "127.0.0.1", port: process.env.RDS_PORT || 3306, dialect: "mysql", logging: false, operatorsAliases: false, &#125;, // Config for qiniu (http://www.qiniu.com/) cloud storage when storageType value is "qiniu". qiniu: &#123; accessKey: "", secretKey: "", bucketName: "faweapp", downloadUrl: "http://babi.lhsea.com" // Binary files download host address.http://pby2wik41.bkt.clouddn.com/Fi_BSD0I9yokJRdors-4LsZucE4_ &#125;, // Config for Amazon s3 (https://aws.amazon.com/cn/s3/) storage when storageType value is "s3". s3: &#123; accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY, sessionToken: process.env.AWS_SESSION_TOKEN, //(optional) bucketName: process.env.BUCKET_NAME, region: process.env.REGION, downloadUrl: process.env.DOWNLOAD_URL, // binary files download host address. &#125;, // Config for Aliyun OSS (https://www.aliyun.com/product/oss) when storageType value is "oss". oss: &#123; accessKeyId: "", secretAccessKey: "", endpoint: "https://oss-cn-qingdao.aliyuncs.com", bucketName: "babizhibo", prefix: "storage", // Key prefix in object key downloadUrl: "http://babizhibo.oss-cn-qingdao.aliyuncs.com/storage", // binary files download host address. &#125;, // Config for tencentyun COS (https://cloud.tencent.com/product/cos) when storageType value is "oss". tencentcloud: &#123; accessKeyId: "", secretAccessKey: "", bucketName: "", region: "", downloadUrl: "", // binary files download host address. &#125;, // Config for local storage when storageType value is "local". local: &#123; // Binary files storage dir, Do not use tmpdir and it's public download dir. storageDir: process.env.STORAGE_DIR || "/Users/mac/Desktop/workspaces/storage", //文件下载地址 CodePush Server 地址 + '/download' download对应app.js里面的地址 downloadUrl: process.env.LOCAL_DOWNLOAD_URL || "http://localhost:3000/download",//注意此地方是否是你的本机ip地址(如果是模拟器的话，无须更改） // public static download spacename. public: '/download' &#125;, jwt: &#123; // Recommended: 63 random alpha-numeric characters // Generate using: https://www.grc.com/passwords.htm tokenSecret: process.env.TOKEN_SECRET ||'fnoQkK2w9zEp2Sj03lYaGCkWDgkVEvaTqrYPxbaZvq2MM3ivnXKNMLzrn96MTmn' &#125;, common: &#123; /* * tryLoginTimes is control login error times to avoid force attack. * if value is 0, no limit for login auth, it may not safe for account. when it's a number, it means you can * try that times today. but it need config redis server. */ tryLoginTimes: 0, // CodePush Web(https://github.com/lisong/code-push-web) login address. //codePushWebUrl: "http://127.0.0.1:3001/login", // create patch updates's number. default value is 3 diffNums: 3, // data dir for caclulate diff files. it's optimization. dataDir: process.env.DATA_DIR || "/Users/mac/Desktop/workspaces/data", // storageType which is your binary package files store. options value is ("local" | "qiniu" | "s3"| "oss" || "tencentcloud") //选择存储类型，目前支持local,oss,qiniu,s3配置 storageType: process.env.STORAGE_TYPE || "qiniu", // options value is (true | false), when it's true, it will cache updateCheck results in redis. updateCheckCache: false, // options value is (true | false), when it's true, it will cache rollout results in redis rolloutClientUniqueIdCache: false, &#125;, 改好之后，启动服务1./bin/www 在浏览其中输入：http://127.0.0.1:3000 能加载到CodePushServer登录界面即表示启动成功。点击登录，输入用户名：admin和密码：123456点击登录，然后点击获取token： 进入项目根目录1cd /Users/mac/Desktop/RNCPProject 登入1code-push login http://127.0.0.1:3000 会自动打开浏览器登录,获取token,把获取到的token粘贴过来, 回车 查看 1whoami 添加一个应用123testApp //应用名称code-push app add testApp ios react-nativecode-push app add testApp android react-native 配置Xcode info.plist 把我们获取的Staging对应的CodePushDeploymentKey填到上面就行了。 运行Xcode 启动项目以更改导航标题为示例 更改项目执行123456789101112code-push release-react testApp ios//发布命令（打包文件并上传到服务器）$ code-push release-react &lt;appName&gt; &lt;OS&gt; &lt;updateContents&gt; &lt;deploymentNmae&gt; &lt;description&gt; &lt;disabled&gt; &lt;mandatory&gt;&lt;appName&gt; //必须 app名称&lt;OS&gt; //必须 发布平台iOS/Android&lt;updateContents&gt; //非必须 Bundle文件所在目录&lt;targetBinaryVersion&gt; //非必须 需要热更的app 版本&lt;deploymentNmae&gt; //必须 需要发布的部署&lt;description&gt; //非必须 描述 (更新客户端不可见必须有"hide" eg: --description "hide xxxx")&lt;disabled&gt; //非必须 该版本客户端是否可以获得更新,默认为false&lt;mandatory&gt; //非必须 如果有则表示app强制更新 1234567//查看历史版本code-push deployment history &lt;应用名&gt; Staging/Productioncode-push deployment history testApp Staging//清空历史版本code-push deployment clear testApp Staging//查看keycode-push deployment ls testApp -k 集成CodePush SDKAndroid下面我们通过如下步骤在Android项目中集成CodePush。 第一步：在项目中安装 react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步：在Android project中安装插件。CodePush提供了两种方式：RNPM 和 Manual，本次演示所使用的是RNPM。运行npm i -g rnpm，来安装RNPM。 在React Native v0.27及以后版本RNPM已经被集成到了 React Native CL中，就不需要再进行安装了 第三步：运行 rnpm link react-native-code-push。这条命令将会自动帮我们在anroid文件中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 第四步： 在 android/app/build.gradle文件里面添如下代码：1apply from: "../../node_modules/react-native-code-push/android/codepush.gradle" 然后在/android/settings.gradle中添加如下代码: 12include ':react-native-code-push'project(':react-native-code-push').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-code-push/android/app') 第五步: 运行code-push deployment -k ls &lt;appName&gt;获取 部署秘钥。默认的部署名是 staging，所以 部署秘钥（deployment key ） 就是 staging。第六步： 添加配置。当APP启动时我们需要让app向CodePush咨询JS bundle的所在位置，这样CodePush就可以控制版本。更新 MainApplication.java文件：1234567891011121314151617181920212223242526public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override protected boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected String getJSBundleFile() &#123; return CodePush.getJSBundleFile(); &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; // 3. Instantiate an instance of the CodePush runtime and add it to the list of // existing packages, specifying the right deployment key. If you don't already // have it, you can run "code-push deployment ls &lt;appName&gt; -k" to retrieve your key. return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush("deployment-key-here", MainApplication.this, BuildConfig.DEBUG) ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125;&#125; 关于deployment-key的设置 在上述代码中我们在创建CodePush实例的时候需要设置一个deployment-key,因为deployment-key分生产环境与测试环境两种,所以建议大家在build.gradle中进行设置。在build.gradle中的设置方法如下: 打开android/app/build.gradle文件,找到android { buildTypes {} }然后添加如下代码即可: 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_STAGING_KEY&gt;"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"&lt;INSERT_PRODUCTION_KEY&gt;"' ... &#125; &#125; ...&#125; 心得:另外,我们也可以将deployment-key存放在local.properties中: 12code_push_key_production=erASzHa1-wTdODdPJDh6DBF2Jwo94JFH08Kvbcode_push_key_staging=mQY75RkFbX6SiZU1kVT1II7OqWst4JFH08Kvb 如图: 然后在就可以在android/app/build.gradle可以通过下面方式来引用它了: 12345678910111213141516171819202122232425Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())android &#123; ... buildTypes &#123; debug &#123; ... // CodePush updates should not be tested in Debug mode ... &#125; releaseStaging &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_production")+'"' ... &#125; release &#123; ... buildConfigField "String", "CODEPUSH_KEY", '"'+properties.getProperty("code_push_key_staging")+'"' ... &#125; &#125; ...&#125; 在android/app/build.gradle设置好deployment-key之后呢,我们就可以这样使用了: 12345678@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( ... new CodePush(BuildConfig.CODEPUSH_KEY, MainApplication.this, BuildConfig.DEBUG), // Add/change this line. ... );&#125; 第七步：修改versionName。在 android/app/build.gradle中有个android.defaultConfig.versionName属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。 12345android&#123; defaultConfig&#123; versionName "1.0.0" &#125;&#125; 至此Code Push for Android的SDK已经集成完成。 iOSCodePush官方提供RNPM、CocoaPods与手动三种在iOS项目中集成CodePush的方式，接下来我就以RNPM的方式来讲解一下如何在iOS项目中集成CodePush。 第一步：在项目中安装react-native-code-push插件，终端进入你的项目根目录然后运行1npm install --save react-native-code-push 第二步： 运行rnpm link react-native-code-push。这条命令将会自动帮我们在ios中添加好设置。 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可，如果不输入则直接单击enter跳过即可。 关于deployment-key的设置在我们想CodePush注册App的时候，CodePush会给我们两个deployment-key分别是在生产环境与测试环境时使用的，我们可以通过如下步骤来设置deployment-key。 用Xcode 打开项目 ➜ Xcode的项目导航视图中的PROJECT下选择你的项目 ➜ 选择Info页签 ➜ 在Configurations节点下单击 + 按钮 ➜ 选择Duplicate &quot;Release ➜ 输入Staging(名称可以自定义)； 然后选择Build Settings页签 ➜ 单击 + 按钮然后选择添加User-Defined Setting 然后输入CODEPUSH_KEY(名称可以自定义) 提示：你可以通过code-push deployment ls &lt;APP_NAME&gt; -k命令来查看deployment key。 打开 Info.plist文件，在CodePushDeploymentKey列的Value中输入$(CODEPUSH_KEY) 参考: https://www.jianshu.com/p/ca4beb5973bb https://www.jianshu.com/p/417a165ca9d7 React Native应用部署/热更新-CodePush最新集成总结(新)]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类似网易新闻的滑动菜单]]></title>
    <url>%2FSwift-%E7%B1%BB%E4%BC%BC%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E7%9A%84%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[简单实现类似这种的 滑动菜单 新手Swift新手 大神就别看了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import UIKitclass HomeViewController: UIViewController,UICollectionViewDelegate,UICollectionViewDataSource,UIScrollViewDelegate &#123; let WIDTH = UIScreen.mainScreen().bounds.width / 375 let HEIGTH = UIScreen.mainScreen().bounds.height / 667 let SCREENWIDTH = UIScreen.mainScreen().bounds.width let SCREENHEIGTH = UIScreen.mainScreen().bounds.height var collectionView: UICollectionView! var buttonsArray: NSMutableArray! var titlesArray: NSMutableArray! var lineView: UIView! override func viewDidLoad() &#123; super.viewDidLoad() self.automaticallyAdjustsScrollViewInsets = false self.navigationController?.automaticallyAdjustsScrollViewInsets = false self.initButtons() self.initCollectionView() &#125; func initButtons() &#123; buttonsArray = NSMutableArray() titlesArray = ["分类","品牌","首页","专题","品牌"] for var i = 0;i&lt;titlesArray.count;i++ &#123; let button = UIButton.init(type: .System) button.frame = CGRectMake(SCREENWIDTH * CGFloat (i) / 5.0, 0, SCREENWIDTH / 5.0, 40 * HEIGTH) button.tag = i button.backgroundColor = UIColor.blackColor() button.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) if i == 2 &#123; button.titleLabel?.font = UIFont.systemFontOfSize(16.0 * WIDTH) button.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; button.titleLabel?.font = UIFont.systemFontOfSize(15.0 * WIDTH) button.setTitle(titlesArray[i] as? String, forState: .Normal) button.addTarget(self, action: "click:", forControlEvents: .TouchUpInside) self.view.addSubview(button) buttonsArray.addObject(button) &#125; lineView = UIView.init(frame: CGRectMake(15 * WIDTH + (SCREENWIDTH / 5.0) * 2, 38 * HEIGTH, SCREENWIDTH / 5.0 - 30 * WIDTH, 2 * HEIGTH)) lineView.backgroundColor = UIColor.whiteColor() self.view.addSubview(lineView) &#125; func click (btn: UIButton) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; btn.titleLabel?.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) self.collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forItem: btn.tag, inSection: 0), atScrollPosition: .None, animated: true) UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (btn.tag), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125;) &#123;(Bool) -&gt; Void in &#125; &#125; func initCollectionView() &#123; let flowLayout = UICollectionViewFlowLayout() flowLayout.scrollDirection = .Horizontal flowLayout.itemSize = CGSizeMake(UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH) flowLayout.minimumLineSpacing = 0 flowLayout.minimumInteritemSpacing = 0 collectionView = UICollectionView.init(frame: CGRectMake(0, 40 * HEIGTH, UIScreen.mainScreen().bounds.width, UIScreen.mainScreen().bounds.height - 88 * HEIGTH), collectionViewLayout: flowLayout) collectionView.delegate = self collectionView.dataSource = self collectionView.pagingEnabled = true collectionView.scrollToItemAtIndexPath(NSIndexPath.init(forRow: 2, inSection: 0), atScrollPosition: .None, animated: true) self.view.addSubview(collectionView) collectionView.registerClass(HomeCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "hCell") collectionView.registerClass(KindCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "kCell") collectionView.registerClass(BrandCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "bCell") collectionView.registerClass(SubjectCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "sCell") collectionView.registerClass(GiftCollectionViewCell.classForKeyedArchiver(), forCellWithReuseIdentifier: "gCell") &#125; func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return 5 &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; if indexPath.item == 0 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("kCell", forIndexPath: indexPath) as! KindCollectionViewCell weak var weakSelf = self cell.initClosure(&#123; (str) -&gt; Void? in // let url = "http://mobile.iliangcang.com/goods/goodsShare?a=b&amp;page=1&amp;count=10&amp;coverId=1&amp;cat_code=$&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" let common = CommonViewController()// common.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: str) common.urlStr = str common.hidesBottomBarWhenPushed = true weakSelf!.navigationController?.pushViewController(common, animated: true) return nil &#125;) return cell &#125;else if indexPath.item == 1 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("bCell", forIndexPath: indexPath) as! BrandCollectionViewCell return cell &#125;else if indexPath.item == 2 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("hCell", forIndexPath: indexPath) as! HomeCollectionViewCell cell.myClosure = &#123; (content_id: String) -&gt; Void in let shopVC = ShopViewController() let url = "http://mobile.iliangcang.com/goods/goodsList?a=b&amp;list_id=$&amp;count=10&amp;page=1&amp;app_key=iPhone&amp;v=3.0.0&amp;sig=97E9576F-B96F-48FD-BE0E-CD84610BC975" shopVC.urlStr = url.stringByReplacingOccurrencesOfString("$", withString: content_id) self.navigationController?.pushViewController(shopVC, animated: true) &#125; return cell &#125;else if indexPath.item == 3 &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("sCell", forIndexPath: indexPath) as! SubjectCollectionViewCell return cell &#125;else &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier("gCell", forIndexPath: indexPath) as! GiftCollectionViewCell return cell &#125; &#125; func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; for btt in buttonsArray &#123; btt.titleLabel?!.font = UIFont.systemFontOfSize(15) btt.setTitleColor(UIColor.lightGrayColor(), forState: .Normal) &#125; UIView.animateWithDuration(0.3) &#123; () -&gt; Void in self.lineView.frame = CGRectMake(15 * WIDTH + (UIScreen.mainScreen().bounds.width / 5.0) * CGFloat (self.collectionView.contentOffset.x / (UIScreen.mainScreen().bounds.width)), 38 * HEIGTH, UIScreen.mainScreen().bounds.width / 5.0 - 30 * WIDTH, 2) &#125; let btn = buttonsArray.objectAtIndex(Int(self.collectionView.contentOffset.x / UIScreen.mainScreen().bounds.width)) btn.titleLabel?!.font = UIFont.systemFontOfSize(16 * WIDTH) btn.setTitleColor(UIColor.whiteColor(), forState: .Normal) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift tableViewCell 高度自适应]]></title>
    <url>%2FSwift-tableViewCell-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[1234567891011 static func cellhight (content: String) -&gt; CGFloat &#123; let rect: CGRect = content.boundingRectWithSize( CGSizeMake(SCREENWIDTH - 20, 0), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName: UIFont.systemFontOfSize(14)], context: nil) return rect.height + 61 &#125; 在返回cell 的高度的方法中直接调用return TableViewCell.cellhight(“这里面填想要自适应的文字”)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS视频图片压缩上传]]></title>
    <url>%2FiOS-%E8%A7%86%E9%A2%91%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[iOS视频图片压缩上传 上传方法: iOS-AFNetworking-3-0-上传图片视频到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 获取当前时间- (NSString *)getCurrentTime&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"]; NSString *dateTime = [formatter stringFromDate:[NSDate date]];// NSString *str = [NSString stringWithFormat:@"%@mdxx",dateTime];// NSString *tokenStr = [str stringToMD5:str]; return dateTime; &#125;#pragma mark - 视频压缩/** * 视频压缩 * * @param url 视频文件的url * * @return 压缩后的url */ - (NSURL *)condenseVideoNewUrl: (NSURL *)url&#123; // 沙盒目录 NSString *docuPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *destFilePath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyh%@.MOV",[self getCurrentTime]]]; NSURL *destUrl = [NSURL fileURLWithPath:destFilePath]; //将视频文件copy到沙盒目录中 NSFileManager *manager = [NSFileManager defaultManager]; NSError *error = nil; [manager copyItemAtURL:url toURL:destUrl error:&amp;error]; NSLog(@"压缩前--%.2fk",[self getFileSize:destFilePath]); // 播放视频 /* NSURL *videoURL = [NSURL fileURLWithPath:destFilePath]; AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.view.bounds; [self.view.layer addSublayer:playerLayer]; [player play]; */ // 进行压缩 AVAsset *asset = [AVAsset assetWithURL:destUrl]; //创建视频资源导出会话 /** NSString *const AVAssetExportPresetLowQuality; // 低质量 NSString *const AVAssetExportPresetMediumQuality; NSString *const AVAssetExportPresetHighestQuality; //高质量 */ AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:asset presetName:AVAssetExportPresetLowQuality]; // 创建导出的url NSString *resultPath = [docuPath stringByAppendingPathComponent:[NSString stringWithFormat:@"lyhg%@.MOV",[self getCurrentTime]]]; session.outputURL = [NSURL fileURLWithPath:resultPath]; // 必须配置输出属性 session.outputFileType = @"com.apple.quicktime-movie"; // 导出视频 [session exportAsynchronouslyWithCompletionHandler:^&#123; NSLog(@"压缩后---%.2fk",[self getFileSize:resultPath]); NSLog(@"视频导出完成"); &#125;]; return session.outputURL;&#125;// 获取视频的大小- (CGFloat) getFileSize:(NSString *)path&#123; NSFileManager *fileManager = [[NSFileManager alloc] init] ; float filesize = -1.0; if ([fileManager fileExistsAtPath:path]) &#123; NSDictionary *fileDic = [fileManager attributesOfItemAtPath:path error:nil];//获取文件的属性 unsigned long long size = [[fileDic objectForKey:NSFileSize] longLongValue]; filesize = 1.0*size/1024; &#125; return filesize;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma mark - Picker delgate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info &#123; NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) &#123; NSLog(@"选取的是照片"); // self.imageView.image = info[UIImagePickerControllerEditedImage]; // 压缩图片 NSData *fileData = UIImageJPEGRepresentation(info[UIImagePickerControllerEditedImage], 0.5); //保存到Documents NSString *imageStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *imageFile = [imageStr stringByAppendingPathComponent:@"image.jpg"]; NSLog(@"%@",imageFile); [fileData writeToFile:imageFile atomically:YES]; //保存至相册 UIImageWriteToSavedPhotosAlbum(info[UIImagePickerControllerEditedImage], self, @selector(image:didFinishSavingWithError:contextInfo:), nil); // 上传图片 NSDictionary *dict = @&#123;@"mem_id":@"600209"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:fileData name:@"photo" fileName:@"abc.jpg" mimeType:@"image/jpeg" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"success:%@ %@",responseObject, [responseObject objectForKey:@"msg"]); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125;else&#123; // 如果是视频 NSURL *url = info[UIImagePickerControllerMediaURL]; // 获取视频总时长 CGFloat lengthTime = [self getVideoLength:url]; NSLog(@"%f",lengthTime); // 保存视频至相册 (异步线程) NSString *urlStr = [url path]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(urlStr)) &#123; UISaveVideoAtPathToSavedPhotosAlbum(urlStr, self, @selector(video:didFinishSavingWithError:contextInfo:), nil); &#125; &#125;); //压缩视频 NSData *videoData = [NSData dataWithContentsOfURL:[self condenseVideoNewUrl:url]]; //视频上传 if (lengthTime &gt;10.0f) &#123; NSLog(@"文件过大只允许上传10s视频"); &#125;else &#123; NSDictionary *dict = @&#123;@"username":@"syl"&#125;; [AFNetworkTool upLoadToUrlString:@"http://www.baidu.com" parameters:dict fileData:videoData name:@"file" fileName:@"video.mov" mimeType:@"video/quicktime" response:JSON progress:^(NSProgress *uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123; NSLog(@"上传成功%@",responseObject); &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; NSLog(@"%@",error); &#125;]; &#125; &#125; [self dismissViewControllerAnimated:YES completion:nil];&#125;// 获取视频时间- (CGFloat) getVideoLength:(NSURL *)URL&#123; AVURLAsset *avUrl = [AVURLAsset assetWithURL:URL]; CMTime time = [avUrl duration]; int second = ceil(time.value/time.timescale); return second;&#125;#pragma mark 图片保存完毕的回调- (void) image: (UIImage *) image didFinishSavingWithError:(NSError *) error contextInfo: (void *)contextIn &#123; NSLog(@"照片保存成功");&#125;#pragma mark 视频保存完毕的回调- (void)video:(NSString *)videoPath didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextIn &#123; if (error) &#123; NSLog(@"保存视频过程中发生错误，错误信息:%@",error.localizedDescription); &#125;else&#123; NSLog(@"视频保存成功."); &#125;&#125;]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS AFNetworking 3.0 上传图片视频到服务器]]></title>
    <url>%2FiOS-AFNetworking-3-0-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基于AFNetworking 3.0图片上传的封装 .h1234567891011typedef NS_ENUM(NSUInteger, ResposeStyle) &#123; JSON, XML, Data,&#125;;typedef NS_ENUM(NSUInteger, RequestStyle) &#123; RequestJSON, RequestString, RequestDefault&#125;; .m @param url 服务器地址 @param parameters 字典 token @param fileData 要上传的数据 @param name 服务器参数名称 后台给你 @param fileName 文件名称 图片:xxx.jpg,xxx.png 视频:video.mov @param mimeType 文件类型 图片:image/jpg,image/png 视频:video/quicktime @param style 返回的数据类型 @param progress @param success @param failure 123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (void)upLoadToUrlString:(NSString *)url parameters:(NSDictionary *)parameters fileData:(NSData *)fileData name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType response:(ResposeStyle)style progress:(void (^)(NSProgress *))progress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure &#123; //1.获取单例的网络管理对象 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.根据style 的类型 去选择返回值得类型 switch (style) &#123; case JSON: manager.responseSerializer = [AFJSONResponseSerializer serializer]; break; case XML: manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; break; case Data: manager.responseSerializer = [AFHTTPResponseSerializer serializer]; break; default: break; &#125; //3.设置相应数据支持的类型 [manager.responseSerializer setAcceptableContentTypes:[NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript",@"text/html",@"text/css",@"text/plain", @"application/javascript",@"application/json", @"application/x-www-form-urlencoded", nil]]; [manager POST:url parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123; [formData appendPartWithFileData:fileData name:name fileName:fileName mimeType:mimeType]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; if (success) &#123; success(task, responseObject); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; if (failure) &#123; failure(task, error); &#125; &#125;];&#125; PS:上传图片前，必须先压缩图片，不然图片过大，可能会导致上传失败！ 具体上传操作:iOS-视频图片压缩上传]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView添加类似微信的进度条]]></title>
    <url>%2FiOS-WKWebView%E6%B7%BB%E5%8A%A0%E7%B1%BB%E4%BC%BC%E5%BE%AE%E4%BF%A1%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[WKWebView添加类似微信的进度条 1.m中声明两个属性@property (nonatomic, strong) WKWebView *wkWebView;@property (nonatomic, strong) UIProgressView *progressView;@property (nonatomic, assign) NSUInteger loadCount; 2.初始化方法…省略 3.添加KVO12通过监听estimatedProgress可以获取它的加载进度 还可以监听它的title ,URL, loading[wkWebView addObserver:self forKeyPath:@"estimatedProgress" options:NSKeyValueObservingOptionNew context:nil]; 4.计算进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@"loading"]) &#123; &#125; else if ([keyPath isEqualToString:@"title"]) &#123; self.title = self.wKWebView.title; &#125; else if ([keyPath isEqualToString:@"URL"]) &#123; &#125; else if ([keyPath isEqualToString:@"estimatedProgress"]) &#123; self.progressView.progress = self.wKWebView.estimatedProgress; &#125; if (object == self.wKWebView &amp;&amp; [keyPath isEqualToString:@"estimatedProgress"]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; if (newprogress == 1) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; [self.progressView setProgress:newprogress animated:YES]; &#125; &#125;&#125; - (void)setLoadCount:(NSUInteger)loadCount &#123; _loadCount = loadCount; if (loadCount == 0) &#123; self.progressView.hidden = YES; [self.progressView setProgress:0 animated:NO]; &#125;else &#123; self.progressView.hidden = NO; CGFloat oldP = self.progressView.progress; CGFloat newP = (1.0 - oldP) / (loadCount + 1) + oldP; if (newP &gt; 0.95) &#123; newP = 0.95; &#125; [self.progressView setProgress:newP animated:YES]; &#125;&#125;// 页面开始加载时调用 - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123; self.loadCount ++;&#125;// 内容返回时 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123; self.loadCount --; &#125;//失败 - (void)webView:(WKWebView *)webView didFailNavigation: (null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123; self.loadCount --; NSLog(@"%@",error);&#125; 最后别忘记在dealloc 中取消监听]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 线程同步方法]]></title>
    <url>%2FiOS-GCD-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们使用GCD的时候如何让线程同步，目前我能想到的就三种 dispatch_group dispatch_barrier dispatch_semaphore dispatch_group 线程组线程组，是一种同步机制，可以让某些线程先执行，某些线程最后执行，以控制线程的执行顺序。 有这么一个需要，分别执行2个耗时的异步操作，等2个异步操作都执行完毕后在回到主线程执行操作。如果想要快速高效地实现这个需求，可以考虑使用线程组。 线程组的创建代码如下： 创建dispatch_group_t1dispatch_group_t group = dispatch_group_create(); 往线程组里面添加任务的函数如下自己创建队列：使用dispatch_group_async。 无法直接使用队列变量（如使用AFNetworking添加异步任务）：使用dispatch_group_enter，dispatch_group_leave调用了dispatch_group_enter(dispatch_group_t group)之后,必须有与之对应的dispatch_group_leave(dispatch_group_t group)才行 第一种: 12345678group 负责监控任务，queue 负责调度任务 dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; i = 1; &#125;); dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; j = 2; &#125;); 第二种: 1234567891011121314151617AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];//Enter groupdispatch_group_enter(group);[manager GET:@"http://www.baidu.com" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //Deal with result... //Leave group dispatch_group_leave(group);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //Deal with error... //Leave group dispatch_group_leave(group);&#125;];//More request... 监听所有任务完成 － 等到 group 中的所有任务执行完毕后，”由队列调度 block 中的任务异步执行”在当前线程阻塞的同步等待：dispatch_group_wait。添加一个异步执行的任务作为结束任务：dispatch_group_notify 123 dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"%d",i+j); &#125;); 适用于后台批量下载 结束后主线程统一刷新UI dispatch_barrier 栅栏块 dispatch_barrier_async,对于同一个队列中的不同任务而言，在dispatch_barrier_async之前的先执行，在dispatch_barrier_async后面的后执行 . 123456789101112131415161718192021222324_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);- (NSString *)someString&#123; __weak NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString *)someString&#123; // barrier dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 函数dispatch_barrier_sync和 dispatch_barrier_async 可以让队列中派发的 block 变成 barrier（栅栏） 使用，这种 block 称为 barrier block。队列中的 barrier block 必须等当前并发队列中的 block 都执行结束才开始执行，时序图如下： 在这个并发队列中,读取操作是用普通的块来实现的,而写入操作则是用栅栏块来实现的,读取操作可以并行,但写入操作必须单独执行,因为他是栅栏快.注意dispatch_barrier_async的同步控制和线程组、信号量的同步机制是不一样的，dispatch_barrier_async是对于同一个队列中的不同任务而言的，线程组和信号量是对于不同线程而言的。 dispatch_semaphore 信号量 创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要先去增加它的数量（增加信号量也叫作发射信号量）。 初始value = 0时，信号量–，小于0，wait线程阻塞。然后执行signal，信号量++，激活wait线程。 123456789101112131415 dispatch_semaphore_t sema = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); NSLog(@"等你"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"发送信号"); [NSThread sleepForTimeInterval:5]; dispatch_semaphore_signal(sema); &#125;);]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 的使用技巧]]></title>
    <url>%2FiOS-GCD-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用dispatch_once来执行只需要运行一次的线程安全代码假设写一个ViewController类的单例方法 12345678+ (id)sharedInstance&#123; static ViewController *vc = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; vc = [ViewController new]; &#125;); return vc;&#125; 注: 使用dispatch_once 可以简化代码并且彻底保证线程安全，根本无需担心加锁或同步。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。把该变量定义在static作用域中，可以保证保证编译器在每次执行sharedInstance方法时都会复用这个变量而不会创建新的变量。采用dispatch_once方式来实现sharedInstance方法的速度几乎是@synchronized的两倍。 dispatch_after功能：延迟一段时间把一项任务提交到队列中执行，返回之后就不能取消，常用来在在主队列上延迟执行一项任务 官方文档说明: 1Enqueue a block for execution at the specified time. Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中 代码示例: 12345 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@"延迟5s在这执行..."); &#125;); 注意 : 使用dispatch_after实现延迟执行某动作，时间并不是很精确，实际上是过多久将Block追加到main Queue中，而不是执行该动作，如果此时main queue中的任务很多，没有执行完毕，那么新添加的这个动作就要继续推迟。 如果对时间的精确度没有高要求，只是为了推迟执行，那么使用dispatch_after`还是很不错的。 正确创建dispatch_time_t 用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用dispatch_time函数，其原型如下： 1dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta )*;* 第一个参数一般是DISPATCH_TIME_NOW，表示从现在开始。那么第二个参数就是真正的延时的具体时间。 这里要特别注意的是，delta参数是“纳秒！”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下： 123#define NSEC_PER_SEC 1000000000ull#define USEC_PER_SEC 1000000ull#define NSEC_PER_USEC 1000ull 关键词解释：NSEC：纳秒。USEC：微妙。SEC：秒PER：每 所以：NSEC_PER_SEC，每秒有多少纳秒。USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）NSEC_PER_USEC，每毫秒有多少纳秒。 所以，延时1秒可以写成如下几种： 123dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC)dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC)dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC) 最后一个“USEC_PER_SEC * NSEC_PER_USEC”，翻译过来就是“每秒的毫秒数乘以每毫秒的纳秒数”，也就是“每秒的纳秒数”。 dispatch_suspend dispatch_resume 挂起、恢复队列代码示例: 123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create("", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"5s后执行此操作"); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@"5s后执行此操作"); &#125;); //挂起 dispatch_suspend(queue); NSLog(@"挂起"); // 恢复 dispatch_resume(queue); NSLog(@"恢复"); 这里要注意的是: dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧 dispatch_applydispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，其实就是简化了用循环去向队列依次添加block任务。代码示例: //创建异步串行队列1234567 dispatch_queue_t queue = dispatch_queue_create("test.gcd", DISPATCH_QUEUE_SERIAL); //运行block3次 dispatch_apply(3, queue, ^(size_t i) &#123; NSLog(@"%zu", i); &#125;); //打印信息 NSLog(@"After apply"); 注意: dispatch_apply会“等待”其所有的循环运行完毕才往下执行.会阻塞主线程]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS GCD 的简单使用(基础)]]></title>
    <url>%2FiOS-GCD-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言在iOS开发中，苹果提供了三种多线程技术，分别是： NSThread NSOperation GCD 简单介绍一下GCD的使用。GCD全称 Grand Central Dispatch，可以称之为大中央调度。实际上GCD是管理着一个线程池，如何创建线程，如何回收线程，以及分配多少个线程，这些都是GCD来控制的。在开发中，程序员是不用操作线程的相关事情，程序员只需要把应该做的操作放到相应的队列里面即可。 自定义队列GCD中有多种队列，其中自定义的队列有两种：串行队列和并行队列 串行队列：队列中的任务只会顺序执行，且一次只能够执行一个任务。也就是说，执行完一个任务后，才会执行下一个任务。 并行队列：可以一次执行多个任务。比如说并行队列中有10个任务，可以一次执行3个任务，这三个任务哪个先执行完了，再接着执行剩下的任务。 注意：无论是串行队列还是并行队列，他们都是FIFO（先进先出）的。也就是说，无论是哪种队列，任务进队列的时间越早，其执行的时间就越早（只不过某些情况下任务执行的结束时间是不确定的）。 GCD中有两种操作，分别是同步操作和异步操作 同步操作：不会新开线程 异步操作：会开启新的线程 两种操作和两种队列，组合为4种情况，实际上，在开发中，有些组合基本上是不会用到的。下面用程序描述一下四种组合。 串行队列 + 同步操作 (不会新建线程，而且任务是一个一个的执行，因此实际上就是顺序执行），代码如下：1234567891011121314- (void)serialAndSync &#123; dispatch_queue_t queue = dispatch_queue_create("serialSync", DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ -- %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果:number = 1,说明是主线程，没有新开线程。 串行队列+异步操作（因为任务要一个一个的执行，但是因为是异步操作，所以会开启一个新的线程，所有的任务都在新的线程上执行），代码如下：123456789101112- (void)serialAndAsync &#123; dispatch_queue_t queue = dispatch_queue_create("serialAsync", DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@ -- %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: number = 2，说明开启了一个新的子线程，但仍然是顺序执行。 并行队列+同步操作（因为同步操作不会开启新的线程，因此，即使并行队列可以一次开始多个任务，但实际上仍旧是每个任务都在主线程上执行，且按顺序执行）。代码如下：12345678910- (void)concurrentAndSync &#123; dispatch_queue_t queue = dispatch_queue_create("concurrentSync", DISPATCH_QUEUE_CONCURRENT); for(int i = 0; i &lt; 10; ++i)&#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125;&#125; 运行结果: 没有开启新的线程，且按顺序执行。 并行队列+异步操作（并行队列会一次开始多个任务，且异步操作可以开启新的线程，因此同一时刻可能会同时执行多个任务，开启多个线程，且每个任务的结束时间是不确定的）。代码如下：12345678910- (void)concurrentAndAsync &#123; dispatch_queue_t queue = dispatch_queue_create("concurrentAsync", DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@%d",[NSThread currentThread],i); &#125;); &#125;&#125; 运行结果: 可以看到，开启了多个线程，且任务不是按顺序执行完的。 全局队列为了方便开发，苹果还提供了有全局队列，全局队列实际上是并行队列，因此，全局队列的执行结果和并行队列的执行结果是一致的。代码如下： 全局队列+同步任务：1234567891011- (void)globalSync &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int i = 0; i &lt; 10; ++i)&#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 全局队列+异步任务：12345678910- (void)golbalAsync &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int i = 0; i &lt; 10; ++i)&#123; dispatch_async(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 主队列苹果还提供了一种队列是主队列，主队列是串行队列，但是和串行队列又有差异。主队列上的任务都应该在主线程上顺序执行，没有异步的概念。也就是说，即使是异步任务在主队列上执行，也不会开启新的线程。 主队列+异步任务：1234567891011- (void)mainAsync &#123; dispatch_queue_t queue = dispatch_get_main_queue(); for (int i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 运行结果: 主队列+同步任务（会阻塞线程），代码如下：1234567891011- (void)mainSync &#123; dispatch_queue_t queue = dispatch_get_main_queue(); for (int i = 0; i &lt; 10; i++) &#123; dispatch_sync(queue, ^&#123; NSLog(@"%@ %d",[NSThread currentThread],i); &#125;); &#125; &#125; 阻塞原因： 主队列中本身是有一个任务A的（主任务），且该任务A还没有执行完。在执行任务A的过程中，又插入了新的同步任务B。我们知道，串行队列中，必须先执行完一个任务后，才能继续执行另一个任务。此时的情况时：若想继续执行任务A，需要先把任务B执行完，若想继续执行任务B，需要先把任务A执行完，因此造成了阻塞。在开发中，应该避免这种阻塞的情况。]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS的三种多线程技术]]></title>
    <url>%2FiOS%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[iOS的三种多线程技术 NSThread 每个NSThread对象对应一个线程，量级较轻（真正的多线程） 以下两点是苹果专门开发的“并发”技术，使得程序员可以不再去关心线程的具体使用问题 NSOperation/NSOperationQueue 面向对象的线程技术 GCD —— Grand Central Dispatch（派发） 是基于C语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术 以上这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的，在项目中很多框架技术分别使用了不同多线程技术。 三种多线程技术的对比NSThread: 优点：NSThread 比其他两个轻量级，使用简单 缺点：需要自己管理线程的生命周期、线程同步、加锁、睡眠以及唤醒等。线程同步对数据的加锁会有一定的系统开销 NSOperation： 不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上 NSOperation是面向对象的 GCD： Grand Central Dispatch是由苹果开发的一个多核编程的解决方案。iOS4.0+才能使用，是替代NSThread， NSOperation的高效和强大的技术 GCD是基于C语言的 三种多线程技术的实现NSThread的多线程技术，类方法直接开启后台线程，并执行选择器方法detachNewThreadSelector 123//新建一个线程，调用@selector方法 [NSThread detachNewThreadSelector:@selector(bigDemo) toTarget:self withObject:nil]; 成员方法，在实例化线程对象之后，需要使用start执行选择器方法`initWithTarget` 1234//成员方法 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(bigDemo) object:nil]; // 启动start线程[thread start]; 对于NSThread的简单使用，可以用NSObject的performSelectorInBackground替代 12//performSelectorInBackground是将bigDemo的任务放在后台线程中执行[self performSelectorInBackground:@selector(bigDemo) withObject:nil]; 同时，在NSThread调用的方法中，同样要使用autoreleasepool进行内存管理，否则容易出现内存泄露。 12345// 自动释放池// 负责其他线程上的内存管理，在使用NSThread或者NSObject的线程方法时，一定要使用自动释放池// 否则容易出现内存泄露。 @autoreleasepool &#123; &#125; NSOperation，面向对象的多线程技术使用步骤：实例化操作队列_queue = [[NSOperationQueue alloc] init]; //NSInvocationOperation 123456NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(opAction) object:nil];// 如果使用start，会在当前线程启动操作// [op1 start];// 一旦将操作添加到操作队列，操作就会启动 [_queue addOperation:op1]; //NSBlockOpera 123456789101112131415161718192021222324252627#pragma mark 模仿下载网络图像- (IBAction)operationDemo3:(id)sender&#123; // 1. 下载 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"下载 %@" , [NSThread currentThread]); &#125;]; // 2. 滤镜 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"滤镜 %@" , [NSThread currentThread]); &#125;]; // 3. 显示 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"更新UI %@" , [NSThread currentThread]); &#125;]; // 添加操作之间的依赖关系，所谓“依赖”关系，就是等待前一个任务完成后，后一个任务才能启动 // 依赖关系可以跨线程队列实现 // 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。 [op2 addDependency:op1]; [op3 addDependency:op2];// [op1 addDependency:op3]; [_queue addOperation:op1]; [_queue addOperation:op2]; [[NSOperationQueue mainQueue] addOperation:op3];&#125; 将操作添加到队列NSOperationQueue即可启动多线程执行12[_queue addOperation:op1];[_queue addOperation:op2]; 更新UI使用主线程队列123456//两方式[NSOpeationQueue mainQueue] addOperation ^&#123; &#125;; [[NSOperationQueue mainQueue] addOperation:op3]; 3.操作队列的setMaxConcurrentOperationCount可以设置同时并发的线程数量！12// 控制同时最大并发的线程数量[_queue setMaxConcurrentOperationCount:2]; 提示：此功能仅有NSOperation有 使用addDependency可以设置任务的执行先后顺序，同时可以跨操作队列指定依赖关系12345678// 添加操作之间的依赖关系，所谓“依赖”关系，就是等待前一个任务完成后，后一个任务才能启动// 依赖关系可以跨线程队列实现// 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。[op2 addDependency:op1];[op3 addDependency:op2];[op1 addDependency:op3]; 提示：在指定依赖关系时，注意不要循环依赖，否则不工作。 GCD，C语言GCD就是为了在“多核”上使用多线程技术 要使用GCD，所有的方法都是dispatch开头的名词解释 global 全局 queue 队列 async 异步 sync 同步 要执行异步的任务，就在全局队列中执行即可 dispatch_async 异步执行控制不住先后顺序 关于GCD的队列全局队列 dispatch_get_global_queue123456参数：优先级 `DISPATCH_QUEUE_PRIORITY_DEFAULT` 始终是 0dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);可同步 可异步 串行队列123456789101112dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL);是创建得到的，不能直接获取只能同步``` ##### 主队列: dispatch_get_main_queue``` bashdispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"main - &gt; %@", [NSThread currentThread]);&#125;);只能同歩 异步和同步与方法名无关，与运行所在的队列有关！同步主要用来控制方法的被调用的顺序]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现对UIAlertController和UIAlertView判断系统后的简单封装]]></title>
    <url>%2F%E5%AE%9E%E7%8E%B0%E5%AF%B9UIAlertController%E5%92%8CUIAlertView%E5%88%A4%E6%96%AD%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[iOS8之后用UIAlertController代替了UIAlertView,所以每次有需要弹窗的时候,都需要先判断系统,最近在做的项目中弹窗较多,如果每次都判断,真是太麻烦了,索性对UIAlertController和UIAlertView进行的封装了,封装在一个工具类中,在工具类中就对系统进行判断,然后在你需要弹窗的界面直接调用这个工具类的方法就可以了,减少了代码的耦合. 这个工具类其实也封装的特别简单,因为都是用的系统的,分享出来给大家参考下: 首先是.h文件12345[objc] view plaincopy@interface UIAlertTool : NSObject-(void)showAlertView:(UIViewController *)viewController :(NSString *)title :(NSString *)message :(NSString *)cancelButtonTitle :(NSString *)otherButtonTitle :(void (^)())confirm :(void (^)())cancle;@end 只有这么一个简单的方法 把你需要在弹窗中显示的内容以参数的形式传入就可以了 然后是.m文件的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[objc] view plaincopy#define IAIOS8 ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)#import "UIAlertTool.h"typedef void (^confirm)();typedef void (^cancle)();@interface UIAlertTool()&#123; confirm confirmParam; cancle cancleParam;&#125;@end@implementation UIAlertTool-(void)showAlertView:(UIViewController *)viewController :(NSString *)title :(NSString *)message :(NSString *)cancelButtonTitle :(NSString *)otherButtonTitle :(void (^)())confirm :(void (^)())cancle&#123; confirmParam=confirm; cancleParam=cancle; if (IAIOS8) &#123; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:title message:message preferredStyle:UIAlertControllerStyleAlert]; // Create the actions. UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:cancelButtonTitle style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; cancle(); &#125;]; UIAlertAction *otherAction = [UIAlertAction actionWithTitle:otherButtonTitle style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123; confirm(); &#125;]; // Add the actions. [alertController addAction:cancelAction]; [alertController addAction:otherAction]; [viewController presentViewController:alertController animated:YES completion:nil]; &#125; else&#123; UIAlertView *TitleAlert = [[UIAlertView alloc] initWithTitle:title message:message delegate:self cancelButtonTitle:otherButtonTitle otherButtonTitles:cancelButtonTitle,nil]; [TitleAlert show]; &#125;&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex==0) &#123; confirmParam(); &#125; else&#123; cancleParam(); &#125;&#125;@end]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS9 新增 UIStackView 官方文档翻译]]></title>
    <url>%2FiOS9-%E6%96%B0%E5%A2%9E-UIStackView-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[iOS9 新增 UIStackView 官方文档翻译 一、继承关系、遵守协议、隶属框架及可用平台 UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。Stack视图管理着所有在它的 arrangedSubviews 属性中的视图的布局。这些视图根据它们在 arrangedSubviews 数组中的顺序沿着 Stack 视图的轴向排列。精确的布局变量根据 Stack 视图的 axis, distribution,alignment, spacing, 和其它属性共同决定。 使用 stack 视图，打开一个你希望编辑的 Storyboard，从对象库中拖拽出一个 Horizontal Stack View 或者一个 Vertical Stack View，并放置到你希望的位置上 。下一步，将控件或视图拖拽放置到 stack 中,也可以先拖拽控件再合并为 Stack View，如果需要你可以继续添加视图或者控件给指定的 stack。Interface Builder 将根据 stack 的内容自动调节尺寸。你也可以通过修改属性面板中 Stack视图的属性调整 stack 内容的外观。 注意：你需要负责指定 stack 视图的位置和尺寸（可选的）。然后 stack 视图将管理其内容的布局和尺寸。 二、Stack 视图与自动布局Stack 视图使用自动布局来定位和控制其管理的视图的尺寸。stack 视图沿着它的轴向拼凑第一个和最后一个被管理视图，使其边界平齐。对于一个水平 stack 视图，这意味着第一个被管理视图的左边界是与 stack 的左边界平齐的，并且最后一个被管理视图右边界与 stack的右边界平齐。对于垂直 stack，上边界和下边界是各自平齐的。如果你设置了 stack 视图的 layoutMarginsRelativeArrangement 属性为 YES，stack 视图将使用相关的边距与其内容对齐，而不是边界。 对于除去 UIStackViewDistributionFillEqually 分布以外的分布方式，stack 视图使用被管理视图的 intrinsicContentSize 属性来计算沿着 stack 轴向的视图尺寸。UIStackViewDistributionFillEqually 分布将调节所有被管理视图的在 stack 轴向上拥有相同尺寸，以填充 stack 视图。如果可能，stack 视图将拉伸所有被管理视图，来匹配其在 stack 轴向上最长的原有尺寸（译注：保证长宽比的情况下根据 stack 轴向长度拉伸视图）。 对于除去 UIStackViewAlignmentFill 对齐方式以外的对齐方式，stack 视图使用其管理的视图的 intrinsicContentSize 属性来计算视图垂直于 stack 轴向的尺寸。 UIStackViewAlignmentFill 重新调节了所有其管理的视图，使这些视图填充 stack 视图垂直于其轴向空间。如果可能，stack 视图将拉伸其所有管理的视图来匹配其垂直于 stack 轴向的最大固有尺寸。 三、定位和调整 Stack 视图尺寸当 Stack 视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位 stack 视图。通常情况下，这意味着需要拼凑至少两个边界相邻的stack来定义它的位置。没有额外约束的情况下，系统会为 stack 视图计算一个尺寸来适应其内容： 沿着 stack 视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和； 垂直于 stack 视图轴向，其适应尺寸等于其管理的视图中最大的视图的尺寸； 如果 stack 视图的 layoutMarginsRelativeArrangement 属性设置为 YES，stack 视图的适应尺寸会包括边距空间。 你可以提供额外的约束来具体说明 stack 视图的高度、宽度或者两者兼有。在这些情况下，stack 视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据 stack 视图的属性获得。可以通过查看 UIStackViewDistribution 和 UIStackViewAlignment 枚举，以获得一个完整的 stack 视图在其内容空间多余或空间不足情况下的处理描述。 你也可以根据 stack 视图的第一条或最后一条基线定位它，而不是使用顶部、底部或者中心的Y值。类似于 stack 视图的适应尺寸，这些基线都是基于 stack 视图的内容计算得到的。 一个水平的 stack 视图调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法时返回它最高的视图。如果最高的视图也是一个 stack 视图，那么其返回的将是在嵌套的 stack 视图上调用 viewForFirstBaselineLayout 方法或viewForLastBaselineLayout 方法的结果。 一个垂直的 stack 视图当调用 viewForFirstBaselineLayout 方法时返回的是其管理的第一个视图，当调用viewForLastBaselineLayout 方法时返回的是其管理的最后一个视图。如果这两个视图之一也是 stack 视图，那么其返回的将是在嵌套的 stack 视图上对应调用 viewForFirstBaselineLayout 方法或 viewForLastBaselineLayout 方法的结果。 注意：基线对齐方式只作用于那些高度匹配其原本内容高度的视图。如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。 四、通用 Stack 视图布局 这有一些通用方法用于 stack 视图。这个清单是要高亮一些有用的示例来显示 stack 视图的灵活性。目前这还不是一个完整的清单。 只是定义位置。你可以通过固定两个与其父视图相邻的边界来定义 stack 视图的位置。在这里，stack 视图的尺寸将根据其管理的视图在两个维度上自由扩展。当你想要 stack 视图的内容展现其原有内容尺寸，和你想要管理其他与 stack 视图有关联的用户接口元素时是特别有用的。 举个例子，在 Figure 1中，stack 视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基线校准。这对于相对于其本身左对齐的 stack 视图内容是有效的。 Figure 1.定义位置 定义沿着 stack 视图轴向的尺寸。这里，你固定了沿着 stack 视图轴向相对于其父视图的两个边界，定义了 stack 视图沿着其轴向的尺寸。你将需要固定其他边界中的一个来定义 stack 视图的位置。stack 视图将沿着其轴向改变尺寸和位置来填充定义的空间；然而，未固定的边界将根据其管理的最大视图的尺寸自由移动。 举例如 Figure 2，stack 视图的左、上、右边界都已经相对于其父视图固定了。使用 UIStackViewDistributionFill 分布使得其内容重设尺寸来填充它的宽度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。 Figure 2.定义沿着 stack 视图轴向的尺寸 定义垂直于 stack 视图轴向的尺寸。这类似于上一个示例，但是你固定了垂直于 stack 视图轴向的两个边界和沿着轴向的一个边界。这使得 stack 视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了 UIStackViewDistributionFillEqually 分布，被管理的视图将根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其 stack 视图的对其模式在其定义的范围内平铺。 举例，Figure 3展示了一个包含了四个标签和一个按钮的垂直 stack 视图。这个 stack 视图使用了8个点的间隙和UIStackViewAlignmentCenter 对齐方式。stack 视图的高度将根据 stack 内部的元素的增减而增大或回缩。 Figure 3.定义垂直于 stack 视图轴向的尺寸 同时定义 stack 视图的位置和尺寸。这里你固定了 stack 视图的所有四个边界。stack 视图将在提供的范围之内平铺其内容。举例，Figure 4展示了一个所有四个边界都相对于其父视图固定的垂直 stack 视图。通过使用 UIStackViewAlignmentCenter 对齐方式和UIStackViewDistributionFill 分布方式，stack 视图确保其内容将水平和垂直居中填充屏幕。然而，获得想要的布局需要两个额外的步骤。默认情况下，stack视图会垂直拉伸标签而不是图片。要缩放图片控件，就要降低其内容紧凑优先级到低于标签。额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit。增加一个图片视图与 stack 视图间宽度相等约束将有助于确保图片将被缩放来填充可用范围。 Figure 4.同时定义 stack 视图的位置和尺寸 五、管理 Stack 视图的展现UIStackView 是 UIView 的非渲染型子类。它没有提供其自有的任何用户接口。相反的，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如 backgroundColor)在 stack 视图上是无效的。类似的，你无法重写 layerClass，drawRect: 或 drawLayer:inContext: 方法。 这里有一系列的属性来定义 stack 视图如何平铺其内容。 axis(轴向) 属性决定了 stack 的朝向，只有垂直或水平；distribution(分布) 属性决定了其管理的视图在沿着其轴向上的布局； alignment(对齐) 属性决定了其管理的视图在垂直于其轴向上的布局； spacing(空隙) 属性决定了其管理的视图间的最小间隙； baselineRelativeArrangement 属性决定了其视图间的垂直间隙是否根据基线测量得到； layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距 通常情况下，你会使用一个 stack 视图来布局小数量的视图。你可以通过在其他 stack 视图中嵌套多个 stack 视图的方式创建更加复杂的视图层次结构。举例，Figure 5展示了一个包含两个水平 stack 视图的垂直 stack 视图。每一个水平 stack 视图各包含一个标签和一个文本框。 Figure 5.Stack 视图的嵌套 你也可以通过增加被管理的视图的额外约束来完美的调节一个被管理视图的展现。举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度。或者你可以定义一个长宽比。当平铺其内容时，stack 视图将使用这些约束。举例来说，在Figure 4中，当图片被缩放时，图片视图的一个长宽比约束被强行赋予了一个长宽比常数。 注意：当给一个 stack 视图内的视图增加约束时要特别注意避免传入冲突。作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容尺寸，那么你可以安全的在这个维度上增加约束。 六、维护其管理的视图与子视图之间的统一性Stack 视图确保它的 arrangedSubviews 属性将一直是其 subviews 属性的子集合。明确的说，stack 视图强制实施了以下规定： 无论何时 stack 视图增加了一个视图到它的 arrangedSubviews 数组，其也将把这个视图作为子视图增加，如果还未增加的话。 无论何时一个子视图从 stack 视图中被移除，那么 stack 视图也将将其从 arrangedSubviews 数组中移除。 从 arrangedSubviews 移除一个视图并不会将其作为子视图移除。stack 视图将不再管理该视图的尺寸和位置，但是该视图仍将是视图结构的一部分，并且当其可见的情况下仍会被渲染到屏幕上。 当 arrangedSubviews 数组一直包含着 subviews 数组的子集合，这些数组间的顺序仍然是独立的。 arrangedSubviews 数组的顺序定义了展现在 stack 中的视图的顺序。对于水平 stack 视图，这些视图将以阅读顺序平铺，即较小索引的视图在较大索引视图的左侧。对于垂直 stack 视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。 subviews 数组中的顺序定义了子视图在Z轴上是顺序。如果视图重叠，有较小索引的子视图将出现在有较大索引的子视图后方。 七、动态改变 Stack 视图内容当视图被加入、移出或插入 arrangedSubviews 数组时，或当一个被管理的子视图的 hidden 属性改变时，stack 视图都会自动更新它的布局。 OC代码如下 : 1234// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES; Swift代码如下： 12345// Appears to remove the first arranged view from the stack. // The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout. let firstView = stackView.arrangedSubviews[0] firstView.hidden = true stack 视图也会自动响应其任何属性的改变。举例，你可以更新 stack 视图的 axis 属性来动态改变的朝向。 OC代码如下： 12345678// Toggle between a vertical and horizontal stackif (self.stackView.axis == UILayoutConstraintAxisHorizontal) &#123; self.stackView.axis = UILayoutConstraintAxisVertical;&#125;else &#123; self.stackView.axis = UILayoutConstraintAxisHorizontal;&#125; Swift代码如下： 123456789// Toggle between a vertical and horizontal stackif stackView.axis == .Horizontal &#123; stackView.axis = .Vertical&#125;else &#123; stackView.axis = .Horizontal&#125; 对于被管理的子视图的 hidden 属性的变化和 stack 视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画方式展现。 OC代码如下： 12345// Animates removing the first item in the stack.[UIView animateWithDuration:0.25 animations:^&#123; UIView * firstView = self.stackView.arrangedSubviews[0]; firstView.hidden = YES;&#125;]; Swift代码如下： 12345// Animates removing the first item in the stack.UIView.animateWithDuration(0.25) &#123; () -&gt; Void in let firstView = stackView.arrangedSubviews[0] firstView.hidden = true&#125; 最后，你可以直接在Interface Builder中给很多 stack 视图属性定义特定的 “尺寸类” 类型值。系统将在 stack 视图的尺寸类改变时动画展现这些改变。 八、常用的方法创建 Stack 视图 - initWithArrangedSubviews: (New in iOS 9.0) 管理安排的子视图 1234567addArrangedSubview: (New in iOS 9.0)arrangedSubviews Property (New in iOS 9.0)insertArrangedSubview:atIndex: (New in iOS 9.0)removeArrangedSubview: (New in iOS 9.0) 设置布局 1234567891011alignment Property (New in iOS 9.0)axis Property (New in iOS 9.0)baselineRelativeArrangement Property (New in iOS 9.0)distribution Property (New in iOS 9.0)layoutMarginsRelativeArrangement Property (New in iOS 9.0)spacing Property (New in iOS 9.0) 常量 12UIStackViewDistributionUIStackViewAlignment]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解RunLoop]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop%2F</url>
    <content type="text"><![CDATA[RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。 目录 RunLoop 的概念 RunLoop 与线程的关系 RunLoop 对外的接口 RunLoop 的 Mode RunLoop 的内部逻辑 RunLoop 的底层实现 苹果用 RunLoop 实现的功能 AutoreleasePool 事件响应 手势识别 界面更新 定时器 PerformSelecter 关于GCD 关于网络请求 RunLoop 的实际应用举例 AFNetworking AsyncDisplayKit RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit); &#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 1234567struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... &#125;; 1234567struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// ? 一个基于 port 的Source 的事件。 /// ? 一个 Timer 到时间了 /// ? RunLoop 自身的超时时间到了 /// ? 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次： 应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。 应用框架层即开发人员接触到的 Cocoa 等框架。 核心框架层包括各种核心框架、OpenGL 等内容。 Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。 XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。 BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。 IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t;typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg(mach_msg_header_t *msg,mach_msg_option_t option,mach_msg_size_t send_size,mach_msg_size_t rcv_size,mach_port_name_t rcv_name,mach_msg_timeout_t timeout,mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing)。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里的中文翻译 。 关于Mach的历史可以看看这篇很有趣的文章：Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePool App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别 当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新 当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器 NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD 实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求 iOS 中，关于网络请求的接口自下至上有如下几层: 123CFSocket CFNetwork -&gt;ASIHttpRequest NSURLConnection -&gt;AFNetworking NSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworking AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"AFNetworking"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKit AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。 UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry介绍与使用实践]]></title>
    <url>%2FMasonry%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Masonry介绍与使用实践前言MagicNumber -&gt; autoresizingMask -&gt; autolayout 以上是纯手写代码所经历的关于页面布局的三个时期 在iphone1-iphone3gs时代 window的size固定为(320,480) 我们只需要简单计算一下相对位置就好了 在iphone4-iphone4s时代 苹果推出了retina屏 但是给了码农们非常大的福利:window的size不变 在iphone5-iphone5s时代 window的size变了(320,568) 这时autoresizingMask派上了用场(为啥这时候不用Autolayout? 因为还要支持ios5呗) 简单的适配一下即可 在iphone6+时代 window的width也发生了变化(相对5和5s的屏幕比例没有变化) 终于是时候抛弃autoresizingMask改用autolayout了(不用支持ios5了 相对于屏幕适配的多样性来说autoresizingMask也已经过时了) 那如何快速的上手autolayout呢? 说实话 当年ios6推出的同时新增了autolayout的特性 我看了一下官方文档和demo 就立马抛弃到一边了 因为实在过于的繁琐和啰嗦(有过经验的朋友肯定有同感) 直到iPhone6发布之后 我知道使用autolayout势在必行了 这时想起了以前在浏览Github看到过的一个第三方库Masonry 在花了几个小时的研究使用后 我就将autolayout掌握了(重点是我并没有学习任何的官方文档或者其他的关于autolayout的知识) 这就是我为什么要写下这篇文章来推荐它的原因. 介绍Masonry 源码：https://github.com/Masonry/Masonry Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。 我们先来看一段官方的sample code来认识一下Masonry 123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).with.insets(padding);&#125;]; 看到block里面的那句话: make edges equalTo superview with insets 通过链式的自然语言 就把view1给autolayout好了 是不是简单易懂? 使用看一下Masonry支持哪一些属性1234567891011@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;@property (nonatomic, strong, readonly) MASConstraint *leading;@property (nonatomic, strong, readonly) MASConstraint *trailing;@property (nonatomic, strong, readonly) MASConstraint *width;@property (nonatomic, strong, readonly) MASConstraint *height;@property (nonatomic, strong, readonly) MASConstraint *centerX;@property (nonatomic, strong, readonly) MASConstraint *centerY;@property (nonatomic, strong, readonly) MASConstraint *baseline; 在ios8发布后 又新增了一堆奇奇怪怪的属性(有兴趣的朋友可以去瞅瞅) Masonry暂时还不支持(不过你要支持ios6,ios7 就没必要去管那么多了) 在讲实例之前 先介绍一个MACRO #define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self; 快速的定义一个weakSelf 当然是用于block里面啦 下面进入正题(为了方便 我们测试的superView都是一个size为(300,300)的UIView) 下面 通过一些简单的实例来简单介绍如何轻松愉快的使用Masonry: [基础] 居中显示一个view123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; // Do any additional setup after loading the view. WS(ws); UIView *sv = [UIView new]; [sv showPlaceHolder]; sv.backgroundColor = [UIColor blackColor]; [self.view addSubview:sv]; [sv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(ws.view); make.size.mas_equalTo(CGSizeMake(300, 300)); &#125;];&#125; 代码效果 使用我之间写的MMPlaceHolder 可以看到superview已经按照我们预期居中并且设置成了适当的大小 那么先看看这几行代码 //从此以后基本可以抛弃CGRectMake了1UIView *sv = [UIView new]; //在做autoLayout之前 一定要先将view添加到superview上 否则会报错 1[self.view addSubview:sv]; //mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了 123456[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;//将sv居中(很容易理解吧?) make.center.equalTo(ws.view); //将size设置成(300,300) make.size.mas_equalTo(CGSizeMake(300, 300));&#125;]; 这里有两个问题要分解一下首先在Masonry中能够添加autolayout约束有三个函数 123456789- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束三种函数善加利用 就可以应对各种情况了*/ 其次 equalTo 和 mas_equalTo的区别在哪里呢? 其实 mas_equalTo是一个MACRO #define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) #define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__))) #define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__))) 可以看到 mas_equalTo只是对其参数进行了一个BOX操作(装箱) MASBoxValue的定义具体可以看看源代码 太长就不贴出来了 所支持的类型 除了NSNumber支持的那些数值类型之外 就只支持CGPoint CGSize UIEdgeInsets 介绍完这几个问题 我们就继续往下了 PS:刚才定义的sv会成为我们接下来所有sample的superView [初级] 让一个view略小于其superView(边距为10)12345678910111213141516UIView *sv1 = [UIView new];[sv1 showPlaceHolder];sv1.backgroundColor = [UIColor redColor];[sv addSubview:sv1];[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); /* 等价于 make.top.equalTo(sv).with.offset(10); make.left.equalTo(sv).with.offset(10); make.bottom.equalTo(sv).with.offset(-10); make.right.equalTo(sv).with.offset(-10); */ /* 也等价于 make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); */&#125;]; 代码效果 这里写图片描述可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事 那么为什么bottom和right里的offset是负数呢? 因为这里计算的是绝对的数值 计算的bottom需要小鱼sv的底部高度 所以要-10 同理用于right 这里有意思的地方是and和with 其实这两个函数什么事情都没做 123456- (MASConstraint *)with &#123; return self;&#125;- (MASConstraint *)and &#123; return self;&#125; 但是用在这种链式语法中 就非常的巧妙和易懂 不得不佩服作者的心思(虽然我现在基本都会省略) [初级] 让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算其宽度)123456789101112131415int padding1 = 10;[sv2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv.mas_left).with.offset(padding1); make.right.equalTo(sv3.mas_left).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv3);&#125;];[sv3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv.mas_centerY); make.left.equalTo(sv2.mas_right).with.offset(padding1); make.right.equalTo(sv.mas_right).with.offset(-padding1); make.height.mas_equalTo(@150); make.width.equalTo(sv2);&#125;]; 代码效果 这里我们在两个子view之间互相设置的约束 可以看到他们的宽度在约束下自动的被计算出来了 [中级] 在UIScrollView顺序排列一些view并自动计算contentSize123456789101112131415161718192021222324252627282930313233343536373839404142434445UIScrollView *scrollView = [UIScrollView new];scrollView.backgroundColor = [UIColor whiteColor];[sv addSubview:scrollView];[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(5,5,5,5));&#125;];UIView *container = [UIView new];[scrollView addSubview:container];[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(scrollView); make.width.equalTo(scrollView);&#125;];int count = 10;UIView *lastView = nil;for ( int i = 1 ; i &lt;= count ; ++i )&#123; UIView *subv = [UIView new]; [container addSubview:subv]; subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 ) saturation:( arc4random() % 128 / 256.0 ) + 0.5 brightness:( arc4random() % 128 / 256.0 ) + 0.5 alpha:1]; [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(container); make.height.mas_equalTo(@(20*i)); if ( lastView ) &#123; make.top.mas_equalTo(lastView.mas_bottom); &#125; else &#123; make.top.mas_equalTo(container.mas_top); &#125; &#125;]; lastView = subv;&#125;[container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(lastView.mas_bottom);&#125;]; 头部效果 尾部效果 从scrollView的scrollIndicator可以看出 scrollView的内部已如我们所想排列好了 这里的关键就在于container这个view起到了一个中间层的作用 能够自动的计算uiscrollView的contentSize [高级] 横向或者纵向等间隙的排列一组view很遗憾 autoLayout并没有直接提供等间隙排列的方法(Masonry的官方demo中也没有对应的案例) 但是参考案例3 我们可以通过一个小技巧来实现这个目的 为此我写了一个Category 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@implementation UIView(Masonry_LJC)- (void) distributeSpacingHorizontallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(ws.mas_left); make.centerY.equalTo(((UIView*)views[0]).mas_centerY); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(lastSpace.mas_right); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(obj.mas_right); make.centerY.equalTo(obj.mas_centerY); make.width.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.right.equalTo(ws.mas_right); &#125;];&#125;- (void) distributeSpacingVerticallyWith:(NSArray*)views&#123; NSMutableArray *spaces = [NSMutableArray arrayWithCapacity:views.count+1]; for ( int i = 0 ; i &lt; views.count+1 ; ++i ) &#123; UIView *v = [UIView new]; [spaces addObject:v]; [self addSubview:v]; [v mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(v.mas_height); &#125;]; &#125; UIView *v0 = spaces[0]; __weak __typeof(&amp;*self)ws = self; [v0 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(ws.mas_top); make.centerX.equalTo(((UIView*)views[0]).mas_centerX); &#125;]; UIView *lastSpace = v0; for ( int i = 0 ; i &lt; views.count; ++i ) &#123; UIView *obj = views[i]; UIView *space = spaces[i+1]; [obj mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(lastSpace.mas_bottom); &#125;]; [space mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(obj.mas_bottom); make.centerX.equalTo(obj.mas_centerX); make.height.equalTo(v0); &#125;]; lastSpace = space; &#125; [lastSpace mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(ws.mas_bottom); &#125;];&#125;@end简单的来测试一下UIView *sv11 = [UIView new];UIView *sv12 = [UIView new];UIView *sv13 = [UIView new];UIView *sv21 = [UIView new];UIView *sv31 = [UIView new];sv11.backgroundColor = [UIColor redColor];sv12.backgroundColor = [UIColor redColor];sv13.backgroundColor = [UIColor redColor];sv21.backgroundColor = [UIColor redColor];sv31.backgroundColor = [UIColor redColor];[sv addSubview:sv11];[sv addSubview:sv12];[sv addSubview:sv13];[sv addSubview:sv21];[sv addSubview:sv31];//给予不同的大小 测试效果[sv11 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(@[sv12,sv13]); make.centerX.equalTo(@[sv21,sv31]); make.size.mas_equalTo(CGSizeMake(40, 40));&#125;];[sv12 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(70, 20));&#125;];[sv13 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 50));&#125;];[sv21 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(50, 20));&#125;];[sv31 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(CGSizeMake(40, 60));&#125;];[sv distributeSpacingHorizontallyWith:@[sv11,sv12,sv13]];[sv distributeSpacingVerticallyWith:@[sv11,sv21,sv31]];[sv showPlaceHolderWithAllSubviews];[sv hidePlaceHolder]; 代码效果 perfect! 简洁明了的达到了我们所要的效果 这里所用的技巧就是 使用空白的占位view来填充我们目标view的旁边 这点通过图上的空白标注可以看出来 小结通过以上5个案例 我觉得已经把Masonry的常用功能介绍得差不多了 如果你觉得意犹未尽呢 请下载官方的demo来学习 总而言之 Masonry是一个非常优秀的autolayout库 能够节省大量的开发和学习时间 尤其适合我这种纯代码的iOSer 在iPhone6发布后引发的适配潮中 Masonry一定可以助你一臂之力 😃]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods完整使用]]></title>
    <url>%2FCocoapods%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CocoaPods安装使用及配置私有库 如何安装?安装ruby环境,添加淘宝ruby镜像123$ gem sources --remove https://rubygems.org///等有反应之后再敲入以下命令$ gem sources -a https://ruby.taobao.org/ 查看是否设置成功:1$ gem sources -l 然后安装cocoapods:1$ sudo gem install cocoapods 查看cocoapods是否支持某个类库1$ pod search 类库名,支持模糊查询(如:AFNetworking) 如何使用?在项目根目录下新建一个“Podfile”的文件(记住一定得叫这个名儿,而且木有后缀)注:Podfile也可以放在任何位置,但是需要在Podfile顶部使用”xcodeproj”关键字指定工程的路径,如下: 但是执行pod install命令后,生成的文件放在了Podfile所在的目录. 编辑Podfile文件输入以下信息12platform :iOS, ‘7.0’\\所有库支持的IOS最低版本pod ‘AFNetworking’, ‘~&gt; 2.0’\\版本号 注:有些第三方库需要指明:platform 支持的IOS最低版本,否则在pod install时会报错,如下图,提示AFNetworking最低支持IOS6.0和OS X 10.8 然后在项目podfile所在目录下运行:(会在你当前项目中导入podfile所配置的库,所以要在项目目录下运行)$ pod install 注意上述命令运行完毕后终端输出的最后一段话,意思就是以后打开项目就用CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 [!] From now on useCocoaPodsDemo.xcworkspace. 经过以上步骤后,我们现在可以打开CocoaPodsDemo.xcworkspace启动我们的新工程了.新工程中已经通过cocoapods引入并配置好了我们刚在podfile写的需要依赖的第三方库了. 引入第三方库后找不到头文件?在项目的Targe-Build Settings-Search Paths-User Header Searcj Paths中添加 ${SRCROOT} 值为 recursive 如下图: 如何编译从github上checkout下来的一个已包含CocoPods类库的项目?打开终端进入你所下载项目的根目录,执行以下命令,后会得到上面的那句话: $ pod update 等待命令运行完毕后,同样最后会输出 [!] From now on usexxxxx.xcworkspace. 如何删除cocopods? 删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹 删除xcworkspace文件 使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources 这里写图片描述 CocoaPods常用命令pod install根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。 每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。等其执行完毕，即可完成第三方库的安装其中还可以调用pod update方法, 也可以达到第三方库安装的目的, 并且会更新版本 在pod install或者pod update过程中会执行podspec索引的更新，需要等待很久，因此为了提升速度可以执行如下命令, 关掉索引的更新 pod install --no-repo-update 并且在安装过程中, 我们不知道cocoapods做了什么, 还可以添加一个参数，用来提示我们，cococapods做了哪些操作 pod install --verbose --no-repo-update列表内容 pod update若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。 pod search命令格式为： $ pod search 类库名,支持模糊查询(如:AFNetworking) 红框中的信息为AFNetworking 最新版本,Version中显示了历史版本,根据这些信息来编写我们的Podfile文件如: pod ‘AFNetWorking’, ‘~&gt; 2.2.4′ 这句话具体含义是什么呢?当我们通过cocopods引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下 123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本pod ‘AFNetworking’, ‘&gt; 2.0’ //使用高于2.0的版本pod ‘AFNetworking’, ‘&gt;= 2.0’ //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘&lt; 2.0’ //使用小于2.0的版本pod ‘AFNetworking’, ‘&lt;= 2.0’ //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘~&gt; 0.1.2’ //使用大于等于0.1.2但小于0.2的版本pod ‘AFNetworking’, ‘~&gt;0.1’ //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘~&gt;0’ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 pod setup用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。 多个target中使用相同的Pods依赖库比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式： 1234567link_with ‘CocoaPodsTest’, ‘Second’platform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0’ 这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。 不同的target使用完全不同的Pods依赖库CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下： 123456789101112target :’CocoaPodsTest’ doplatform :iospod ‘Reachability’, ‘~&gt; 3.0.0’pod ‘SBJson’, ‘~&gt; 4.0.0’platform :ios, ‘7.0’pod ‘AFNetworking’, ‘~&gt; 2.0′endtarget :’Second’ dopod ‘OpenUDID’, ‘~&gt; 1.0.0’end 其中，do/end作为开始和结束标识符。 Podfile.lock文件在使用CocoaPods，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。该文件用于保存已经安装的Pods依赖库的版本，通过CocoaPods安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为： 123456789101112131415161718192021222324252627282930313233PODS:– AFNetworking (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/NSURLSession– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/UIKit– AFNetworking/NSURLConnection (2.1.0):– AFNetworking/Reachability– AFNetworking/Security– AFNetworking/Serialization– AFNetworking/NSURLSession (2.1.0):– AFNetworking/NSURLConnection– AFNetworking/Reachability (2.1.0)– AFNetworking/Security (2.1.0)– AFNetworking/Serialization (2.1.0)– AFNetworking/UIKit (2.1.0):– AFNetworking/NSURLConnection– Reachability (3.0.0)– SBJson (4.0.0)DEPENDENCIES:– AFNetworking (~&gt; 2.0)– Reachability (~&gt; 3.0.0)– SBJson (~&gt; 4.0.0)SPEC CHECKSUMS:AFNetworking: c7d7901a83f631414c7eda1737261f696101a5cdReachability: 500bd76bf6cd8ff2c6fb715fc5f44ef6e4c024f2SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220COCOAPODS: 0.29.0 Podfile.lock文件最大得用处在于多人开发。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案： 1.更改Podfile，使其指向最新版本的SBJson依赖库； 2.执行pod update命令； 鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。 如何制作自己的Cocopods库在github上新建一个工程 license类型正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。 把项目clone到本地然后在根目录下新建MyPodDemo.podspec 或使用命令 $ pod spec create MyPodDemo Spec文件编写:123456789101112131415161718192021222324Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo."s.description = &lt;&lt;-DESCA longer description of MyPodDemo in Markdown format.* Think: Why did you write this? What is the focus? What does it do?* CocoaPods will be using this to generate tags, and improve search results.* Try to keep it short, snappy and to the point.* Finally, don't worry about the indent, CocoaPods strips it!DESCs.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo/Src", "MyPodDemo/Src/**/*.&#123;h,m&#125;"s.requires_arc = true# s.framework = "SomeFramework"# s.frameworks = "SomeFramework", "AnotherFramework"# s.library = "iconv"# s.libraries = "iconv", "xml2"# s.dependency "JSONKit", "~&gt; 1.4"# s.dependency "AFNetworking", "~&gt; 2.2.4"end 自解析:123456789101112name: 导入pod后的目录名version: 当前版本号deployment_target: 配置的targetprefix_header_file: 预编译头文件路径，将该文件的内容插入到Pod的pch文件内source: 来源的具体路径，是http链接还是本地路径requires_arc: 是否需要arcsource_files: 指定该目录下包含哪些文件其他可选参数还包括：dependency: 指定依赖，如果依赖的库不存在或者依赖库的版本不符合要求将会报错libraries: 指定导入的库，比如sqlite3frameworks: 指定导入的frameworkweak_frameworks: 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。 整个podspec语法是一个嵌套结构从Pod::Spec.new do |s|到最后一个end是最大的循环，表示整个podspec导入的文件。中间每一个subspec到end结束是一个子目录，Pods会为每个subspec创建一个逻辑目录，相当于Xcode的group概念。|**|中间是subspec的名字，可以随便命名，但后面使用的名称必须一致。 通配符说明1234a&#123;bb,bc&#125;def.&#123;h,m&#125;表示四个文件abbdef.h abbdef.m abcdef.h abcdef.m*.&#123;h,m,mm&#125;表示所有的.h .m .mm文件Class/**/*.&#123;h,m&#125;表示Class目录下的所有.h .m文件 写完podspec文件后使用pod spec lint验证spec是否合格,有error则需要修改 上传代码至github上传podspec文件到CocoaPods仓库(fork一下,修改完成后在push上去等待审核) 将我们刚刚生成的MyPodDemo.spec 文件上传到Cocoapods官方specs仓库中 :链接为：https://github.com/CocoaPods/Specs 私有库实现,编写podfile如果由于某些原因我们编写的库不能公开,但是又想使用pods来进行管理,要怎么办呢? 首先我们要将我们刚刚在github上建的仓库改为Private(不然还用Public搞毛啊) 然后修改我们项目的podfile,与已加入Cocopods仓库的公有库相比我们只需要指明私有库低git地址,如下: 123platform :ios, '6.0'pod 'MyPodDemo', :git =&gt; 'https://github.com/goingta/MyPodDemo.git' //私有库pod 'CocoaLumberjack'//公有库 版本控制和冲突(引用自http://objccn.io/issue-6-4/)CocoaPods 使用语义版本控制 – Semantic Versioning 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于2.3.1，另一个依赖于 2.3.3，此时冲突解决系统可以使用最新的版本 2.3.3，因为这个可以向后与 2.3.1 兼容。 但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。 当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 1.2.5，另外一个库则依赖于 2.3.1，那么只有最终用户通过明确指定使用某个版本来解决冲突。 配置非ARC文件前几天项目中由于历史原因,导致有一个私有的pods库中某几个文件是在非ARC时代写的,如果要进行修改工程量浩大,于是乎要对这几个文件单独处理,这几个文件不使用arc其他文件使用arc,网上查了一些资料,只需要对source_file进行修改并排除那几个不使用ARC的文件就可以了,大致修改如下: 123456789101112131415161718Pod::Spec.new do |s|s.name = "MyPodDemo"s.version = "0.0.1"s.summary = "A short description of MyPodDemo.s.homepage = "https://github.com/goingta/MyPodDemo"s.license = "MIT"s.author = &#123; "goingta" =&gt; "tangle1128@gmail.com" &#125;s.source = &#123; :git =&gt; "https://github.com/goingta/MyPodDemo.git", :tag =&gt; "0.0.1" &#125;s.source_files = "MyPodDemo"non_arc_files = 'MyPodDemo/NoArcFile1.&#123;h,m&#125;','MyPodDemo/NoArcFile2.&#123;h,m&#125;'s.requires_arc = trues.exclude_files = non_arc_filess.subspec 'no-arc' do |sna|sna.requires_arc = falsesna.source_files = non_arc_filesendend 回退Cocoapods历史版本查看当前安装了哪些版本 gem list --local | grep cocoapods 如果你安装了多个版本(如0.35和0.20.2)那么你将看到 123cocoapods (0.34, 0.20.2)cocoapods-core (0.33, 0.20.2)cocoapods-downloader (0.2.0, 0.1.2) 先删除已经装过的版本(可能有几个,卸载的时候会让你输入1,2…n选择卸载那个版本 sudo gem uninstall cocoapods 或者强制卸载某一个版本 gem uninstall cocoapods -v 0.20.2 安装某一个版本 sudo gem install cocoapods -v 0.35.0 处理 Use the $(inherited) flag 异常有时候在pod update之后会遇到下面错误:12Use the `$(inherited)` flag, orRemove the build settings from the target. 虽然对项目编译没什么影响,但是看着还是挺不舒服的.解决办法就是 找到工程的 targets 点击工程名 Build Settings -&gt; Other linker flags -&gt; 添加 $(inherited)]]></content>
      <categories>
        <category>iOS开发记录</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
</search>
